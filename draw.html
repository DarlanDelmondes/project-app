<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas v43 - Font Control & Heavy Arrows</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --grid-color: #cbd5e1;
            --box-border: #94a3b8;
            --handle-color: #3b82f6;
        }

        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: var(--bg-color); }

        /* UI Toolbar */
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 0; z-index: 9999; }
        #toolbar {
            position: absolute; top: 20px; left: 20px;
            background: white; padding: 10px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; gap: 10px; align-items: center;
            pointer-events: auto; flex-wrap: wrap; max-width: 90vw;
        }
        button.btn-primary { background-color: #2563eb; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: 600; white-space: nowrap;}
        button.btn-primary:hover { background-color: #1d4ed8; }
        button.btn-dark { background-color: #1e293b; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: 600; white-space: nowrap;}
        button.btn-dark:hover { background-color: #334155; }
        button.btn-outline { background-color: white; color: #334155; border: 1px solid #cbd5e1; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: 600; white-space: nowrap;}
        button.btn-outline:hover { background-color: #f1f5f9; }
        
        #btn-mode.locked { background-color: #ef4444; color: white; border: none; }
        .icon-btn { border: none; background: transparent; cursor: pointer; color: #64748b; padding: 4px; border-radius: 4px; transition: color 0.2s, background 0.2s; }
        .icon-btn:hover { background: #e2e8f0; color: #0f172a; }
        .btn-delete:hover { color: #ef4444; background: #fee2e2; }

        /* Auto Save Indicator */
        #autosave-status { font-size: 11px; color: #64748b; margin-left: 5px; min-width: 80px; text-align: right; }

        /* --- TOAST --- */
        #toast-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 20000; display: flex; flex-direction: column; gap: 10px; pointer-events: none; align-items: center; }
        .toast { background: #1e293b; color: #f8fafc; padding: 12px 24px; border-radius: 50px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3); display: flex; align-items: center; gap: 15px; font-size: 14px; font-weight: 500; pointer-events: auto; animation: slideUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); opacity: 0.95; }
        .toast-action-btn { background: rgba(255,255,255,0.15); border: none; color: #fbbf24; padding: 6px 14px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 12px; transition: background 0.2s; text-transform: uppercase; }
        .toast-action-btn:hover { background: rgba(255,255,255,0.3); }
        .toast-btn-yes { color: #4ade80; background: rgba(74, 222, 128, 0.1); } .toast-btn-yes:hover { background: rgba(74, 222, 128, 0.2); }
        .toast-btn-no { color: #f87171; background: rgba(248, 113, 113, 0.1); } .toast-btn-no:hover { background: rgba(248, 113, 113, 0.2); }
        @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 0.95; transform: translateY(0); } }
        @keyframes fadeOut { to { opacity: 0; transform: translateY(-10px); } }

        /* --- DASHBOARD --- */
        #dashboard-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px); z-index: 10000; display: none; justify-content: center; align-items: center; pointer-events: auto; }
        #dashboard-panel { background: white; width: 600px; max-height: 80vh; border-radius: 12px; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1); display: flex; flex-direction: column; overflow: hidden; }
        .dash-header { padding: 20px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; }
        .dash-title { font-size: 20px; font-weight: bold; color: #1e293b; }
        .dash-close { cursor: pointer; font-size: 24px; color: #64748b; }
        .dash-content { padding: 20px; overflow-y: auto; background: #f8fafc; flex-grow: 1; }
        .project-card { background: white; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin-bottom: 10px; display: flex; align-items: center; transition: transform 0.1s, box-shadow 0.1s; }
        .project-card:hover { transform: translateY(-2px); box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        .p-info { flex-grow: 1; } .p-name { font-weight: bold; color: #334155; font-size: 16px; } .p-date { font-size: 12px; color: #94a3b8; } .p-actions { display: flex; gap: 10px; }
        .btn-load { background: #3b82f6; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; }
        .btn-trash { background: #fee2e2; color: #ef4444; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; }

        /* Viewport */
        #viewport { width: 100vw; height: 100vh; overflow: hidden; cursor: grab; } #viewport:active { cursor: grabbing; }
        #world { position: absolute; top: 0; left: 0; width: 0; height: 0; transform-origin: 0 0; }
        .grid-background { position: absolute; top: -50000px; left: -50000px; width: 100000px; height: 100000px; background-image: radial-gradient(var(--grid-color) 1px, transparent 1px); background-size: 40px 40px; z-index: -1; pointer-events: none; }
        
        /* CONNECTIONS */
        #connections-layer { position: absolute; top: -50000px; left: -50000px; width: 100000px; height: 100000px; z-index: 500; pointer-events: none; overflow: visible; }
        .conn-visual { fill: none; stroke: #64748b; stroke-width: 2px; pointer-events: none; transition: stroke 0.2s, stroke-width 0.2s; }
        .conn-hitbox { fill: none; stroke: transparent; stroke-width: 25px; cursor: pointer; pointer-events: stroke; }
        .conn-group:hover .conn-visual { stroke: #3b82f6; }
        .drag-line { stroke: #3b82f6; stroke-width: 4; stroke-dasharray: 5,5; opacity: 0.8; }
        .proxy-line { stroke-dasharray: 4,4; } 

        /* Boxes */
        .box {
            position: absolute; background: white; border: 2px solid var(--box-border); border-radius: 16px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05); display: flex; flex-direction: column; z-index: 10;
            min-width: 200px; min-height: 180px; 
            --dynamic-font-size: 16px; 
            --header-height: 36px;
            --balloon-scale: 1;
            cursor: grab; 
            transition: box-shadow 0.2s, border-color 0.2s, background-color 0.2s, width 0.8s cubic-bezier(0.25, 0.8, 0.25, 1), height 0.8s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .no-transition { transition: none !important; }
        .box.selected { border-color: var(--handle-color); z-index: 100; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); }
        
        .box-title-bar {
            height: var(--header-height); background: transparent; border-radius: 10px 10px 0 0; 
            display: flex; align-items: center; justify-content: center;
            padding: 25px 15px 15px 15px; 
            cursor: move; user-select: none; flex-shrink: 0; 
            font-size: calc(var(--header-height) * 0.35); position: relative; 
        }
        .box-title-bar:active { cursor: grabbing; }
        
        input.title { 
            width: 90%; border: none; font-weight: bold; background: transparent; outline: none; 
            font-size: var(--dynamic-font-size); color: #1e293b; 
            transition: font-size 0.2s, color 0.3s ease; 
            cursor: text; text-align: center; font-family: 'Segoe UI', sans-serif;
        }

        .actions-balloon {
            position: absolute; top: calc(-25px * var(--balloon-scale)); right: 0.5em;
            background: #1e293b; border-radius: 50px; padding: calc(4px * var(--balloon-scale)) calc(8px * var(--balloon-scale));
            display: none; align-items: center; gap: calc(6px * var(--balloon-scale));
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-size: 14px; z-index: 20; animation: popIn 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .box.hover-focused > .box-title-bar .actions-balloon { display: flex; }
        
        .actions-balloon .icon-btn { color: white; width: calc(24px * var(--balloon-scale)); height: calc(24px * var(--balloon-scale)); font-size: calc(12px * var(--balloon-scale)); display: flex; align-items: center; justify-content: center; border-radius: 50%; }
        .actions-balloon .icon-btn:hover { background: rgba(255,255,255,0.2); }
        .actions-balloon .btn-delete:hover { background: #ef4444; color: white; }
        .actions-balloon .btn-font { font-family: serif; font-weight: bold; } /* Bot√µes de fonte */
        
        .status-dot-btn { width: calc(14px * var(--balloon-scale)); height: calc(14px * var(--balloon-scale)); border-radius: 50%; cursor: pointer; border: 1px solid rgba(255,255,255,0.3); transition: transform 0.1s; }
        .status-dot-btn:hover { transform: scale(1.2); border-color: white; }
        .dot-green { background: #4ade80; } .dot-red { background: #f87171; }
        .separator { width: 1px; height: calc(16px * var(--balloon-scale)); background: rgba(255,255,255,0.3); }

        .box-body { padding: 0 15px 15px 15px; display: flex; flex-direction: column; gap: 10px; flex-grow: 1; position: relative; }
        .children-area { flex-grow: 1; position: relative; margin-top: 5px; background: rgba(240,240,240,0.4); border-radius: 12px; border: 1px dashed #cbd5e1; width: 100%; height: 100%; min-height: 60px; padding: 20px; box-sizing: border-box; transition: opacity 0.2s, transform 0.2s, background-color 0.2s, border-color 0.2s; opacity: 1; transform: scale(1); }
        .children-area.collapsed { display: none; }
        .children-area.drop-active { background-color: rgba(59, 130, 246, 0.1); border-color: #3b82f6; box-shadow: inset 0 0 0 2px rgba(59, 130, 246, 0.3); }
        
        .box.red-state { border-color: #ef4444; background-color: #fff1f2; }
        .box.alert-state { box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.2); border-color: #ef4444; }
        
        .box.collapsed-mode .box-body { display: none; }
        .box.collapsed-mode .box-title-bar { height: 100%; padding: 0; align-items: center; justify-content: center; }
        .box.collapsed-mode input.title { color: #1e293b; }

        .connector { position: absolute; width: 12px; height: 12px; background: white; border: 2px solid #3b82f6; border-radius: 50%; z-index: 600; opacity: 0; transition: opacity 0.2s, transform 0.2s; cursor: crosshair; pointer-events: auto; }
        .box:hover > .connector { opacity: 1; } .connector:hover { transform: scale(1.4); background: #3b82f6; } .c-top { top: -7px; left: 50%; transform: translateX(-50%); } .c-bottom { bottom: -7px; left: 50%; transform: translateX(-50%); } .c-left { left: -7px; top: 50%; transform: translateY(-50%); } .c-right { right: -7px; top: 50%; transform: translateY(-50%); }
        .resizer { width: 35px; height: 35px; position: absolute; right: 0; bottom: 0; cursor: nwse-resize; z-index: 102; opacity: 0; pointer-events: auto; }
        .box:hover > .resizer { opacity: 1; } .resizer::after { content: ''; position: absolute; right: 6px; bottom: 6px; border-left: 10px solid transparent; border-bottom: 10px solid #94a3b8; }
        
        body.read-only .actions-balloon .btn-add, body.read-only .actions-balloon .btn-delete, 
        body.read-only .actions-balloon .btn-clone, body.read-only .actions-balloon .btn-font, /* Hide font btns in read only */
        body.read-only .actions-balloon .status-dot-btn, body.read-only .actions-balloon .separator { display: none !important; }
        
        body.read-only .connector { display: none !important; }
        body.read-only .resizer { display: none !important; }
        body.read-only input { pointer-events: none; }
        body.read-only .box { cursor: default; }
        body.read-only .box-title-bar { cursor: default; }
        
        #file-input { display: none; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="toolbar">
        <button class="btn-primary" onclick="addRootBox()">+ Nova Caixa</button>
        <div style="width: 1px; height: 30px; background: #ddd; margin: 0 5px;"></div>
        <button id="btn-mode" class="btn-outline" onclick="toggleEditMode()" title="Alternar Edi√ß√£o/Leitura">üîì Edi√ß√£o</button>
        <div style="width: 1px; height: 30px; background: #ddd; margin: 0 5px;"></div>
        <button class="btn-dark" onclick="openDashboard()">üìÇ Projetos</button>
        <button class="btn-primary" onclick="saveCurrentDrawing()">üíæ Salvar</button>
        <div id="autosave-status"></div>
        <div style="width: 1px; height: 30px; background: #ddd; margin: 0 5px;"></div>
        <button class="btn-outline" onclick="exportJSON()" title="Baixar .json">‚¨á JSON</button>
        <button class="btn-outline" onclick="document.getElementById('file-input').click()" title="Carregar .json">‚¨Ü Abrir</button>
        <input type="file" id="file-input" accept=".json" onchange="importJSON(this)">
        <button class="btn-outline" onclick="downloadPNG()" title="Baixar Blueprint PNG">üì∑ PNG</button>
        <div style="width: 1px; height: 30px; background: #ddd; margin: 0 5px;"></div>
        <span style="font-size: 12px; color: #555;">Zoom: </span>
        <span id="zoom-indicator">100%</span>
        <button class="icon-btn" onclick="resetView()">‚ü≤</button>
        <button class="icon-btn" onclick="fitToScreen()" title="Centralizar Tudo">üéØ</button>
    </div>
</div>

<div id="toast-container"></div>

<div id="dashboard-overlay">
    <div id="dashboard-panel">
        <div class="dash-header"><span class="dash-title">Gerenciador de Desenhos</span><span class="dash-close" onclick="closeDashboard()">√ó</span></div>
        <div class="dash-content" id="projects-list"></div>
        <div style="padding: 15px; border-top: 1px solid #e2e8f0; text-align: right;"><button class="btn-primary" onclick="newDrawing()">+ Novo Desenho em Branco</button></div>
    </div>
</div>

<div id="viewport">
    <div id="world">
        <div class="grid-background"></div>
        <svg id="connections-layer">
            <defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#64748b" /></marker></defs>
            <path id="temp-line" class="drag-line" d="" fill="none" style="display: none;"></path>
        </svg>
    </div>
</div>

<script>
    // --- 1. GLOBAL STATE ---
    let state = { scale: 1, panning: false, panStart: { x: 0, y: 0 }, offset: { x: 0, y: 0 }, isEditMode: true };
    let connections = [];
    let dragItem = null, resizeItem = null, isConnecting = false, startInt = {};
    let currentDropTarget = null;
    let spacePressed = false;
    let currentDrawingName = null;
    let undoStack = null;

    const viewport = document.getElementById('viewport');
    const world = document.getElementById('world');
    const zoomInd = document.getElementById('zoom-indicator');
    const svgLayer = document.getElementById('connections-layer');
    const tempLine = document.getElementById('temp-line');
    const ns = "http://www.w3.org/2000/svg";

    // AUTO SAVE
    setInterval(performAutoSave, 10000);
    function performAutoSave() {
        if (!currentDrawingName) return; 
        const data = serializeCanvas();
        const db = getDB();
        const existingIdx = db.findIndex(p => p.name === currentDrawingName);
        const proj = { 
            id: existingIdx !== -1 ? db[existingIdx].id : 'proj_' + Date.now(), 
            name: currentDrawingName, updatedAt: Date.now(), data: data 
        };
        if (existingIdx !== -1) db[existingIdx] = proj; else db.push(proj);
        setDB(db);
        const now = new Date();
        document.getElementById('autosave-status').innerText = `Salvo: ${now.getHours()}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}`;
    }

    // --- 2. HELPER FUNCTIONS ---
    function toggleEditMode() {
        state.isEditMode = !state.isEditMode;
        const btn = document.getElementById('btn-mode');
        if (state.isEditMode) {
            document.body.classList.remove('read-only'); btn.innerText = "üîì Edi√ß√£o"; btn.classList.remove('locked'); showToast("Modo de Edi√ß√£o Ativado");
        } else {
            document.body.classList.add('read-only'); btn.innerText = "üîí Leitura"; btn.classList.add('locked'); showToast("Modo de Leitura (Bloqueado)");
            document.querySelectorAll('.hover-focused').forEach(el => el.classList.remove('hover-focused'));
        }
    }
    function closeToast(toast) { toast.style.animation = 'fadeOut 0.2s forwards'; setTimeout(() => toast.remove(), 200); }
    function showToast(message, actionLabel = null, actionCallback = null) {
        const container = document.getElementById('toast-container');
        while(container.children.length > 2) container.removeChild(container.firstChild);
        const toast = document.createElement('div'); toast.className = 'toast';
        let html = `<span>${message}</span>`;
        if (actionLabel) { html += `<button class="toast-action-btn">${actionLabel}</button>`; }
        toast.innerHTML = html;
        if (actionLabel && actionCallback) { toast.querySelector('button').onclick = () => { actionCallback(); closeToast(toast); }; }
        container.appendChild(toast); setTimeout(() => { if (toast.parentElement) closeToast(toast); }, 5000);
    }
    function showConfirmToast(message, onConfirm) {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div'); toast.className = 'toast';
        toast.innerHTML = `<span>${message}</span><div style="display:flex; gap:8px;"><button class="toast-action-btn toast-btn-yes">SIM</button><button class="toast-action-btn toast-btn-no">N√ÉO</button></div>`;
        container.appendChild(toast);
        toast.querySelector('.toast-btn-yes').onclick = () => { closeToast(toast); onConfirm(); };
        toast.querySelector('.toast-btn-no').onclick = () => { closeToast(toast); };
    }
    function restoreUndo() { if(undoStack) { deserializeCanvas(undoStack); undoStack = null; showToast("A√ß√£o desfeita."); } }

    // --- 3. IO & PNG ---
    function exportJSON() {
        const data = serializeCanvas(); data.name = currentDrawingName || "desenho";
        const jsonStr = JSON.stringify(data, null, 2); const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `${data.name}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showToast("Exportado!");
    }
    function importJSON(input) {
        const file = input.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try { const data = JSON.parse(e.target.result); if (data.boxes) { showConfirmToast("Substituir desenho?", () => { currentDrawingName = data.name || "Importado"; deserializeCanvas(data); showToast("Carregado."); }); } } catch (err) { showToast("Erro no arquivo."); }
        }; reader.readAsText(file); input.value = '';
    }
    function downloadPNG() {
        const boxes = document.querySelectorAll('.box'); if (boxes.length === 0) { showToast("Canvas vazio."); return; }
        showToast("Gerando PNG...");
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        boxes.forEach(box => { /* bounds calc */ });
        const prevScale = state.scale; const prevOffset = { ...state.offset };
        state.scale = 1; state.offset = { x: 0, y: 0 }; updateTransform();
        const worldRect = world.getBoundingClientRect();
        boxes.forEach(box => {
            const rect = box.getBoundingClientRect();
            const relX = rect.left - worldRect.left; const relY = rect.top - worldRect.top;
            if (relX < minX) minX = relX; if (relY < minY) minY = relY;
            if (relX + rect.width > maxX) maxX = relX + rect.width;
            if (relY + rect.height > maxY) maxY = relY + rect.height;
        });
        const padding = 60;
        html2canvas(world, { backgroundColor: "#f0f2f5", x: minX - padding, y: minY - padding, width: (maxX - minX) + (padding * 2), height: (maxY - minY) + (padding * 2), logging: false, scale: 2 }).then(canvas => {
            const link = document.createElement('a'); link.download = `${currentDrawingName || 'blueprint'}.png`; link.href = canvas.toDataURL(); link.click();
            state.scale = prevScale; state.offset = prevOffset; updateTransform(); showToast("Download iniciado!");
        });
    }

    // --- 4. STORAGE & DASHBOARD ---
    function getDB() { return JSON.parse(localStorage.getItem('canvas_projects')) || []; }
    function setDB(db) { localStorage.setItem('canvas_projects', JSON.stringify(db)); }
    function openDashboard() {
        const list = document.getElementById('projects-list'); list.innerHTML = '';
        const db = getDB();
        if (db.length === 0) list.innerHTML = '<div style="text-align:center; color:#94a3b8; padding:20px;">Vazio</div>';
        else {
            db.sort((a, b) => b.updatedAt - a.updatedAt).forEach(proj => {
                const dateStr = new Date(proj.updatedAt).toLocaleDateString();
                const item = document.createElement('div'); item.className = 'project-card';
                item.innerHTML = `<div class="p-info"><div class="p-name">${proj.name}</div><div class="p-date">${dateStr}</div></div><div class="p-actions"><button class="btn-load" onclick="loadProject('${proj.id}')">Abrir</button><button class="btn-trash" onclick="deleteProject('${proj.id}')">Excluir</button></div>`;
                list.appendChild(item);
            });
        }
        document.getElementById('dashboard-overlay').style.display = 'flex';
    }
    function closeDashboard() { document.getElementById('dashboard-overlay').style.display = 'none'; }
    function newDrawing() { showConfirmToast("Criar novo desenho?", () => { document.querySelectorAll('.box').forEach(b => b.remove()); updateAllLines(true); connections = []; state = { ...state, scale: 1, panning: false, offset: {x:0, y:0} }; updateTransform(); currentDrawingName = null; addRootBox(); closeDashboard(); showToast("Novo desenho criado."); }); }
    function deleteProject(id) { showConfirmToast("Excluir projeto?", () => { let db = getDB(); db = db.filter(p => p.id !== id); setDB(db); openDashboard(); showToast("Exclu√≠do."); }); }
    function saveCurrentDrawing() {
        let name = currentDrawingName; if (!name) { name = prompt("Nome do projeto:", "Projeto"); if (!name) return; currentDrawingName = name; }
        performAutoSave(); showToast("Projeto salvo!");
    }
    function loadProject(id) { const proj = getDB().find(p => p.id === id); if (!proj) return; document.querySelectorAll('.box').forEach(b => b.remove()); updateAllLines(true); connections = []; currentDrawingName = proj.name; deserializeCanvas(proj.data); closeDashboard(); showToast(`Carregado: ${proj.name}`); }

    // --- 5. SERIALIZATION ---
    function serializeCanvas() {
        const boxes = [];
        document.querySelectorAll('.box').forEach(box => {
            const parent = box.parentElement.closest('.box');
            boxes.push({
                id: box.id, x: box.style.left, y: box.style.top, w: box.style.width, h: box.style.height,
                mw: box.dataset.mw, mh: box.dataset.mh, title: box.querySelector('input.title').value,
                status: box.classList.contains('red-state') ? 'red' : 'green',
                collapsed: box.classList.contains('collapsed-mode'), 
                fontScale: box.dataset.fontScale || 1, // SAVE FONT PREF
                parentId: parent ? parent.id : null
            });
        });
        return { boxes, connections, viewport: state };
    }
    function deserializeCanvas(data) {
        state = { ...data.viewport, isEditMode: true }; 
        document.body.classList.remove('read-only'); document.getElementById('btn-mode').innerText = "üîì Edi√ß√£o"; document.getElementById('btn-mode').classList.remove('locked');
        updateTransform();
        const boxMap = {};
        data.boxes.forEach(d => {
            const el = createBoxElement(d.id, d.title);
            el.style.left = d.x; el.style.top = d.y; el.style.width = d.w; el.style.height = d.h;
            if(d.mw) el.dataset.mw = d.mw; if(d.mh) el.dataset.mh = d.mh;
            if(d.status === 'red') el.classList.add('red-state');
            // RESTORE FONT SCALE
            if(d.fontScale) el.dataset.fontScale = d.fontScale; else el.dataset.fontScale = 1;
            
            if(d.collapsed) {
                el.classList.add('collapsed-mode');
                el.querySelector('.actions-balloon .btn-toggle').innerText = '‚ñ∂';
            }
            boxMap[d.id] = { el, parentId: d.parentId }; 
        });
        Object.values(boxMap).forEach(item => { 
            if (item.parentId && boxMap[item.parentId]) boxMap[item.parentId].el.querySelector('.children-area').appendChild(item.el); 
            else world.appendChild(item.el); 
            calcDynamicFont(item.el);
        });
        data.connections.forEach(c => { 
            if(document.getElementById(c.sid) && document.getElementById(c.tid)) addConnection(c.sid, c.spos, c.tid, c.tpos, c.id); 
        });
        setTimeout(() => { document.querySelectorAll('.children-area').forEach(area => updateElasticParent(area)); updateAllLines(); }, 50);
    }

    // --- 6. ZOOM & PAN ---
    function screenToWorld(sx, sy) { const rect = world.getBoundingClientRect(); return { x: (sx - rect.left) / state.scale, y: (sy - rect.top) / state.scale }; }
    function updateTransform() { world.style.transform = `translate(${state.offset.x}px, ${state.offset.y}px) scale(${state.scale})`; zoomInd.innerText = Math.round(state.scale * 100) + '%'; }
    
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const dir = e.deltaY > 0 ? -1 : 1;
        let newScale = state.scale + (dir * 0.1 * state.scale);
        newScale = Math.min(Math.max(0.1, newScale), 5);
        const rect = viewport.getBoundingClientRect();
        const mx = e.clientX - rect.left; const my = e.clientY - rect.top; 
        const worldXBefore = (mx - state.offset.x) / state.scale;
        const worldYBefore = (my - state.offset.y) / state.scale;
        state.scale = newScale;
        state.offset.x = mx - (worldXBefore * state.scale);
        state.offset.y = my - (worldYBefore * state.scale);
        updateTransform();
    }, { passive: false });

    viewport.addEventListener('mousedown', (e) => {
        const t = e.target;
        const isBoxMover = t.closest('.box-title-bar'); 
        const isControl = t.closest('button') || t.tagName === 'INPUT' || t.closest('.resizer') || t.closest('.connector') || t.closest('.connection-line') || t.closest('#dashboard-overlay') || t.closest('#toolbar') || t.classList.contains('conn-hitbox');
        const canDragBox = state.isEditMode && isBoxMover;
        if (!canDragBox && !isControl && (e.button === 0 || e.button === 1)) {
            e.preventDefault(); state.panning = true; state.panStart = { x: e.clientX - state.offset.x, y: e.clientY - state.offset.y }; viewport.style.cursor = 'grabbing';
        }
    });
    window.addEventListener('mousemove', (e) => { if (state.panning) { e.preventDefault(); state.offset.x = e.clientX - state.panStart.x; state.offset.y = e.clientY - state.panStart.y; updateTransform(); } });
    window.addEventListener('mouseup', () => { state.panning = false; viewport.style.cursor = 'grab'; });
    function resetView() { state.scale = 1; state.offset = { x: 0, y: 0 }; updateTransform(); }
    
    function fitToScreen() {
        const boxes = document.querySelectorAll('.box');
        if (boxes.length === 0) { state.scale = 1; state.offset = {x:0,y:0}; updateTransform(); return; }
        let minWx = Infinity, minWy = Infinity, maxWx = -Infinity, maxWy = -Infinity;
        boxes.forEach(box => {
            const rect = box.getBoundingClientRect();
            const wx = (rect.left - state.offset.x) / state.scale;
            const wy = (rect.top - state.offset.y) / state.scale;
            const ww = rect.width / state.scale;
            const wh = rect.height / state.scale;
            if (wx < minWx) minWx = wx; if (wy < minWy) minWy = wy;
            if (wx + ww > maxWx) maxWx = wx + ww; if (wy + wh > maxWy) maxWy = wy + wh;
        });
        const padding = 100;
        const totalW = maxWx - minWx + (padding * 2);
        const totalH = maxWy - minWy + (padding * 2);
        const scaleX = window.innerWidth / totalW;
        const scaleY = window.innerHeight / totalH;
        let newScale = Math.min(scaleX, scaleY);
        newScale = Math.min(Math.max(newScale, 0.1), 2);
        const worldCenterX = (minWx + maxWx) / 2;
        const worldCenterY = (minWy + maxWy) / 2;
        const newOffsetX = (window.innerWidth / 2) - (worldCenterX * newScale);
        const newOffsetY = (window.innerHeight / 2) - (worldCenterY * newScale);
        state.scale = newScale; state.offset.x = newOffsetX; state.offset.y = newOffsetY;
        updateTransform();
    }

    // --- 7. CORE LOGIC ---
    function addRootBox() { 
        if(!state.isEditMode) return;
        const pos = screenToWorld(window.innerWidth/2, window.innerHeight/2); createBox(world, pos.x - 130, pos.y - 110); 
    }
    
    // [NOVIDADE] ADJUST FONT SIZE
    function adjustFontSize(id, delta) {
        if(!state.isEditMode) return;
        const box = document.getElementById(id);
        let currentScale = parseFloat(box.dataset.fontScale) || 1;
        currentScale += delta;
        currentScale = Math.max(0.5, Math.min(3, currentScale)); // Limites
        box.dataset.fontScale = currentScale;
        calcDynamicFont(box);
    }

    function duplicateBox(id) {
        if(!state.isEditMode) return;
        const original = document.getElementById(id);
        const originalParent = original.parentElement; 
        
        function recursiveClone(sourceEl, targetParent, isRoot = false) {
            const title = sourceEl.querySelector('input.title').value;
            const w = parseFloat(sourceEl.style.width);
            const h = parseFloat(sourceEl.style.height);
            const mw = sourceEl.dataset.mw;
            const mh = sourceEl.dataset.mh;
            const fScale = sourceEl.dataset.fontScale;
            const status = sourceEl.classList.contains('red-state') ? 'red' : 'green';
            const collapsed = sourceEl.classList.contains('collapsed-mode');
            const newId = 'box-' + Date.now() + Math.random().toString(36).substr(2, 4);
            const newEl = createBoxElement(newId, title);
            
            if (isRoot) {
                const oldLeft = parseFloat(sourceEl.style.left);
                const oldTop = parseFloat(sourceEl.style.top);
                newEl.style.left = (oldLeft + 30) + 'px';
                newEl.style.top = (oldTop + 30) + 'px';
            } else {
                newEl.style.left = sourceEl.style.left;
                newEl.style.top = sourceEl.style.top;
            }
            
            newEl.style.width = w + 'px'; newEl.style.height = h + 'px';
            if(mw) newEl.dataset.mw = mw; if(mh) newEl.dataset.mh = mh;
            if(fScale) newEl.dataset.fontScale = fScale;
            
            if(status === 'red') newEl.classList.add('red-state');
            if(collapsed) {
                newEl.classList.add('collapsed-mode');
                newEl.querySelector('.actions-balloon .btn-toggle').innerText = '‚ñ∂';
            }
            
            targetParent.appendChild(newEl);
            calcDynamicFont(newEl);
            
            const sourceArea = sourceEl.querySelector('.children-area');
            const targetArea = newEl.querySelector('.children-area');
            
            Array.from(sourceArea.children).forEach(child => {
                if(child.classList.contains('box')) {
                    recursiveClone(child, targetArea, false);
                }
            });
            if(targetParent.classList.contains('children-area')) updateElasticParent(targetParent);
        }
        recursiveClone(original, originalParent, true);
        showToast("Caixa duplicada com sucesso!");
    }

    function createBoxElement(id, titleVal = "Novo Item") {
        const el = document.createElement('div'); el.className = 'box'; el.id = id;
        el.dataset.fontScale = "1"; // Default Font Scale
        el.innerHTML = `
            <div class="box-title-bar" onmousedown="initDrag(event, '${id}')">
                <input class="title" value="${titleVal}" placeholder="Nome..." oninput="calcDynamicFont(this.closest('.box'))">
                <div class="actions-balloon">
                    <div class="status-dot-btn dot-green" onclick="setStatus('${id}', 'green')" title="Normal"></div>
                    <div class="status-dot-btn dot-red" onclick="setStatus('${id}', 'red')" title="Cr√≠tico"></div>
                    <div class="separator"></div>
                    
                    <button class="icon-btn btn-font" onclick="adjustFontSize('${id}', -0.1)" title="Diminuir Texto">A-</button>
                    <button class="icon-btn btn-font" onclick="adjustFontSize('${id}', 0.1)" title="Aumentar Texto">A+</button>
                    <div class="separator"></div>

                    <button class="icon-btn btn-add" onclick="addChild('${id}')" title="Adicionar Filho">Ôºã</button>
                    <button class="icon-btn btn-clone" onclick="duplicateBox('${id}')" title="Duplicar">‚ùê</button>
                    <button class="icon-btn btn-toggle" onclick="handleSmartToggle('${id}', this)" title="Colapsar">‚ñº</button>
                    <button class="icon-btn btn-delete" onclick="deleteBox('${id}')" title="Excluir">√ó</button>
                </div>
            </div>
            <div class="box-body">
                <div class="children-area" id="area-${id}"></div>
            </div>
            <div class="resizer" onmousedown="initResize(event, '${id}')"></div><div class="connector c-top" onmousedown="initConn(event, '${id}', 'top')"></div><div class="connector c-bottom" onmousedown="initConn(event, '${id}', 'bottom')"></div><div class="connector c-left" onmousedown="initConn(event, '${id}', 'left')"></div><div class="connector c-right" onmousedown="initConn(event, '${id}', 'right')"></div>
        `;
        el.addEventListener('mouseover', (e) => {
            e.stopPropagation(); 
            document.querySelectorAll('.hover-focused').forEach(b => b.classList.remove('hover-focused'));
            el.classList.add('hover-focused');
        });
        return el;
    }

    function createBox(parent, x, y) {
        const id = 'box-' + Date.now() + Math.random().toString(36).substr(2, 4);
        const el = createBoxElement(id);
        el.style.left = x + 'px'; el.style.top = y + 'px';
        let w = '200px'; let h = '180px'; if(parent !== world) { w = '200px'; h = '160px'; }
        el.style.width = w; el.style.height = h; el.dataset.mw = parseFloat(w); el.dataset.mh = parseFloat(h);
        el.dataset.status = 'green'; parent.appendChild(el); calcDynamicFont(el);
        if (parent !== world) setTimeout(() => updateElasticParent(parent), 0);
    }

    function deleteBox(id) {
        if(!state.isEditMode) return;
        showConfirmToast("Excluir esta caixa?", () => {
            undoStack = serializeCanvas();
            const box = document.getElementById(id); if (!box) return;
            const parentArea = box.parentElement;
            const boxesToDelete = [box, ...box.querySelectorAll('.box')];
            const idsToDelete = new Set(boxesToDelete.map(b => b.id));
            
            const connsToRemove = connections.filter(c => idsToDelete.has(c.sid) || idsToDelete.has(c.tid));
            connsToRemove.forEach(c => {
                const grp = document.getElementById(c.id);
                if(grp) grp.remove();
            });
            connections = connections.filter(c => !idsToDelete.has(c.sid) && !idsToDelete.has(c.tid));
            
            box.remove(); updateAllLines(true); 
            if (parentArea && parentArea.classList.contains('children-area')) updateElasticParent(parentArea);
            checkCascading(); showToast("Item exclu√≠do.", "Desfazer", restoreUndo);
        });
    }

    function deleteConnection(connId) {
        if(!state.isEditMode) return;
        showConfirmToast("Remover conex√£o?", () => {
            undoStack = serializeCanvas();
            const idx = connections.findIndex(c => c.id === connId);
            if (idx !== -1) { 
                connections.splice(idx, 1); 
                const path = document.getElementById(connId); 
                if (path) path.remove(); 
                checkCascading(); showToast("Conex√£o removida.", "Desfazer", restoreUndo); 
            }
        });
    }

    function addChild(id) {
        if(!state.isEditMode) return;
        const area = document.getElementById('area-' + id);
        const parentBox = document.getElementById(id);
        area.classList.remove('collapsed'); parentBox.classList.remove('collapsed-mode');
        const btn = parentBox.querySelector('.actions-balloon .btn-toggle'); if(btn) btn.innerText = '‚ñº';
        createBox(area, 20, 20); 
    }
    
    function calcDynamicFont(box) {
        const input = box.querySelector('input.title');
        const textLen = Math.max(1, input.value.length); 
        const w = box.offsetWidth; const h = box.offsetHeight;
        
        // Manual Scale
        const manualScale = parseFloat(box.dataset.fontScale) || 1;

        const area = w * h;
        let balloonScale = Math.sqrt(area) / 220; 
        balloonScale = Math.min(Math.max(balloonScale, 0.75), 1.8);
        box.style.setProperty('--balloon-scale', balloonScale);

        // Auto Calc * Manual Scale
        let sizeBasedOnGeom = Math.sqrt(area) * 0.12;
        const maxSizeForWidth = (w * 0.9) / (textLen * 0.6);
        let finalSize = Math.min(sizeBasedOnGeom, maxSizeForWidth);
        finalSize = Math.max(14, finalSize);
        
        // Apply manual multiplier
        finalSize = finalSize * manualScale;
        
        box.style.setProperty('--dynamic-font-size', finalSize + 'px');
        
        const headerH = Math.max(30, h * 0.15);
        box.style.setProperty('--header-height', headerH + 'px');
    }

    function handleSmartToggle(id, btn) {
        const area = document.getElementById('area-' + id);
        const isClosing = !area.classList.contains('collapsed');
        if (isClosing) runCascadeClose(id, btn); else performToggle(id, btn);
    }
    async function runCascadeClose(boxId) {
        const box = document.getElementById(boxId);
        const area = box.querySelector('.children-area');
        const openChildren = Array.from(area.children).filter(child => child.classList.contains('box') && !child.classList.contains('collapsed-mode'));
        if (openChildren.length > 0) { const promises = openChildren.map(child => runCascadeClose(child.id)); await Promise.all(promises); await new Promise(r => setTimeout(r, 800)); }
        const myBtn = box.querySelector('.actions-balloon .btn-toggle');
        if (!box.classList.contains('collapsed-mode')) { performToggle(boxId, myBtn); const parentArea = box.parentElement; if (parentArea && parentArea.classList.contains('children-area')) updateElasticParent(parentArea); }
    }
    function performToggle(id, btn) {
        const area = document.getElementById('area-' + id);
        const box = document.getElementById(id);
        area.classList.toggle('collapsed'); box.classList.toggle('collapsed-mode');
        if(btn) btn.innerText = area.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
        calcDynamicFont(box); updateElasticParent(area); updateAllLines();
    }
    function updateElasticParent(childrenContainer) {
        if (!childrenContainer || !childrenContainer.classList.contains('children-area')) return;
        const parentBox = childrenContainer.closest('.box'); if (!parentBox) return;
        if (childrenContainer.classList.contains('collapsed')) {
            const manualW = parseFloat(parentBox.dataset.mw) || 200;
            parentBox.style.width = Math.max(200, manualW) + 'px';
            parentBox.style.height = Math.max(80, parseFloat(parentBox.dataset.mh) || 80) + 'px';
            calcDynamicFont(parentBox);
            const gp = parentBox.parentElement; if (gp && gp.classList.contains('children-area')) updateElasticParent(gp); return;
        }
        const children = Array.from(childrenContainer.children).filter(c => c.classList.contains('box'));
        let maxX = 0; let maxY = 0;
        children.forEach(child => {
            const right = child.offsetLeft + child.offsetWidth; const bottom = child.offsetTop + child.offsetHeight;
            if (right > maxX) maxX = right; if (bottom > maxY) maxY = bottom;
        });
        const neededW = maxX + 40; const neededH = maxY + 120 + 40;
        const manualW = parseFloat(parentBox.dataset.mw) || 240; const manualH = parseFloat(parentBox.dataset.mh) || 220;
        parentBox.style.width = Math.max(neededW, manualW) + 'px'; parentBox.style.height = Math.max(neededH, manualH) + 'px';
        calcDynamicFont(parentBox);
        const gp = parentBox.parentElement; if (gp && gp.classList.contains('children-area')) updateElasticParent(gp);
        updateAllLines();
    }

    // --- INTERACTIONS ---
    function initDrag(e, id) {
        if(spacePressed) return; 
        if(!state.isEditMode) return;
        if (e.target.closest('button') || e.target.classList.contains('status-dot-btn')) return; 
        e.stopPropagation(); 
        dragItem = document.getElementById(id); dragItem.style.zIndex = 999; 
        const wp = screenToWorld(e.clientX, e.clientY);
        startInt = { mx: wp.x, my: wp.y, el: dragItem.offsetLeft, et: dragItem.offsetTop };
    }
    function initResize(e, id) {
        if(!state.isEditMode) return;
        e.stopPropagation(); resizeItem = document.getElementById(id); resizeItem.classList.add('no-transition');
        const wp = screenToWorld(e.clientX, e.clientY);
        startInt = { mx: wp.x, my: wp.y, w: resizeItem.offsetWidth, h: resizeItem.offsetHeight };
    }
    function initConn(e, id, pos) {
        if(!state.isEditMode) return;
        e.stopPropagation(); e.preventDefault(); isConnecting = true;
        const rect = e.target.getBoundingClientRect();
        const wp = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
        startInt = { sid: id, spos: pos, sx: wp.x, sy: wp.y };
        tempLine.style.display = 'block';
    }
    window.addEventListener('mousemove', (e) => {
        const wp = screenToWorld(e.clientX, e.clientY);
        if (dragItem) {
            e.preventDefault(); dragItem.style.left = (startInt.el + wp.x - startInt.mx) + 'px'; dragItem.style.top = (startInt.et + wp.y - startInt.my) + 'px';
            dragItem.style.pointerEvents = 'none'; 
            const elementsBelow = document.elementsFromPoint(e.clientX, e.clientY);
            dragItem.style.pointerEvents = 'auto';
            if(currentDropTarget) { currentDropTarget.classList.remove('drop-active'); currentDropTarget = null; }
            const target = elementsBelow.find(el => el.classList.contains('children-area'));
            if (target && !dragItem.contains(target)) { currentDropTarget = target; currentDropTarget.classList.add('drop-active'); }
            updateElasticParent(dragItem.parentElement); updateAllLines();
        }
        if (resizeItem) {
            e.preventDefault();
            const newW = Math.max(200, startInt.w + wp.x - startInt.mx); const newH = Math.max(80, startInt.h + wp.y - startInt.my);
            resizeItem.style.width = newW + 'px'; resizeItem.style.height = newH + 'px';
            resizeItem.dataset.mw = newW; resizeItem.dataset.mh = newH;
            calcDynamicFont(resizeItem); updateElasticParent(resizeItem.querySelector('.children-area')); updateElasticParent(resizeItem.parentElement); updateAllLines();
        }
        if (isConnecting) { const off = -50000; tempLine.setAttribute('d', `M ${startInt.sx-off} ${startInt.sy-off} L ${wp.x-off} ${wp.y-off}`); }
    });
    window.addEventListener('mouseup', (e) => {
        if (resizeItem) resizeItem.classList.remove('no-transition');
        document.querySelectorAll('.drop-active').forEach(el => el.classList.remove('drop-active'));
        if (dragItem) {
            if (currentDropTarget && currentDropTarget !== dragItem.parentElement) reparentBox(dragItem, currentDropTarget);
            else if (!currentDropTarget && dragItem.parentElement !== world) reparentBox(dragItem, world);
            dragItem.style.zIndex = '';
        }
        dragItem = null; resizeItem = null; currentDropTarget = null;
        if (isConnecting) {
            isConnecting = false; tempLine.style.display = 'none';
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (el && el.classList.contains('connector')) {
                const box = el.closest('.box'); const pos = el.className.match(/c-([a-z]+)/)[1];
                if (box && box.id !== startInt.sid) addConnection(startInt.sid, startInt.spos, box.id, pos);
            }
        }
    });
    
    viewport.addEventListener('click', (e) => {
        if(e.target === viewport || e.target === world || e.target.classList.contains('grid-background')) {
            document.querySelectorAll('.hover-focused').forEach(b => b.classList.remove('hover-focused'));
        }
    });

    function reparentBox(box, newParent) {
        const oldParent = box.parentElement;
        const boxRect = box.getBoundingClientRect();
        const newParentRect = newParent === world ? world.getBoundingClientRect() : newParent.getBoundingClientRect();
        const newLeft = (boxRect.left - newParentRect.left) / state.scale;
        const newTop = (boxRect.top - newParentRect.top) / state.scale;
        newParent.appendChild(box); box.style.left = newLeft + 'px'; box.style.top = newTop + 'px';
        if(oldParent && oldParent.classList.contains('children-area')) updateElasticParent(oldParent);
        if(newParent && newParent.classList.contains('children-area')) updateElasticParent(newParent);
        updateAllLines();
    }
    
    // --- CONN UTILS ---
    function findVisibleNode(id) {
        let currentEl = document.getElementById(id); if (!currentEl) return null;
        while (currentEl) {
            const parentArea = currentEl.parentElement;
            if (parentArea && parentArea.classList.contains('children-area')) { if (parentArea.classList.contains('collapsed')) { currentEl = parentArea.closest('.box'); continue; } }
            return currentEl;
        }
        return null;
    }
    function addConnection(sid, spos, tid, tpos, existingId = null) {
        const id = existingId || 'c-' + Date.now();
        const g = document.createElementNS(ns, "g");
        g.id = id; g.classList.add('conn-group');
        
        const hit = document.createElementNS(ns, "path");
        hit.setAttribute("class", "conn-hitbox");
        hit.addEventListener('dblclick', function() { handleConnectionDblClick(id, sid, tid); });
        
        const vis = document.createElementNS(ns, "path");
        vis.setAttribute("class", "conn-visual");
        vis.setAttribute("marker-end", "url(#arrowhead)");

        g.appendChild(hit); g.appendChild(vis); svgLayer.appendChild(g);
        
        if (!connections.find(c => c.id === id)) connections.push({ id, sid, spos, tid, tpos });
        updateLine(connections[connections.length-1]); checkCascading();
    }

    function updateAllLines(forceClear = false) {
        if(forceClear) { 
            const groups = Array.from(svgLayer.querySelectorAll('g.conn-group'));
            const dataIds = new Set(connections.map(c => c.id));
            groups.forEach(g => { if(!dataIds.has(g.id)) g.remove(); });
        }
        connections.forEach(updateLine);
    }

    function updateLine(c) {
        const vSource = findVisibleNode(c.sid); const vTarget = findVisibleNode(c.tid);
        const group = document.getElementById(c.id); if (!group) return;
        
        if (!vSource || !vTarget || vSource === vTarget) { group.style.display = 'none'; return; }
        group.style.display = 'block';
        
        const visualLine = group.querySelector('.conn-visual');
        if (vSource.id !== c.sid || vTarget.id !== c.tid) visualLine.classList.add('proxy-line'); else visualLine.classList.remove('proxy-line');
        
        const ps = getConnPos(vSource, c.spos); const pt = getConnPos(vTarget, c.tpos);
        const off = -50000;
        const x1=ps.x-off, y1=ps.y-off, x2=pt.x-off, y2=pt.y-off;
        
        // [UPDATE] HEAVY ARROWS BASED ON TARGET
        if (vTarget) {
            const minDim = Math.min(vTarget.offsetWidth, vTarget.offsetHeight);
            // 1/12th of min dimension as thickness.
            const thickness = Math.max(3, Math.min(30, minDim / 15)); 
            visualLine.setAttribute("stroke-width", thickness);
        }

        const dVal = Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2)); const cp = Math.max(dVal*0.5, 50);
        let cx1=x1, cy1=y1, cx2=x2, cy2=y2;
        if(c.spos==='top') cy1-=cp; if(c.spos==='bottom') cy1+=cp; if(c.spos==='left') cx1-=cp; if(c.spos==='right') cx1+=cp;
        if(c.tpos==='top') cy2-=cp; if(c.tpos==='bottom') cy2+=cp; if(c.tpos==='left') cx2-=cp; if(c.tpos==='right') cx2+=cp;
        
        const pathD = `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
        group.querySelector('.conn-hitbox').setAttribute("d", pathD);
        visualLine.setAttribute("d", pathD);
    }
    
    function getConnPos(el, pos) {
        const r = el.getBoundingClientRect(); let x=r.left+r.width/2, y=r.top+r.height/2;
        if(pos==='top') y=r.top; if(pos==='bottom') y=r.bottom; if(pos==='left') x=r.left; if(pos==='right') x=r.right;
        return screenToWorld(x,y);
    }
    function setStatus(id, s) {
        if(!state.isEditMode) return;
        const b = document.getElementById(id);
        if(s==='red') b.classList.add('red-state'); else b.classList.remove('red-state');
        checkCascading();
    }
    function checkCascading() {
        document.querySelectorAll('.box').forEach(b => b.classList.remove('alert-state'));
        connections.forEach(c => {
            const t = document.getElementById(c.tid), s = document.getElementById(c.sid);
            if(s && t && (t.classList.contains('red-state')||t.classList.contains('alert-state'))) s.classList.add('alert-state');
        });
        document.querySelectorAll('.box').forEach(p => {
            const children = Array.from(p.querySelectorAll('.box'));
            if(children.some(c => c.classList.contains('red-state')) && !p.classList.contains('red-state')) p.classList.add('alert-state');
        });
    }

    // TRACE LOGIC
    async function revealHierarchy(boxId) {
        let el = document.getElementById(boxId);
        let ancestors = [];
        while (el) {
            const parent = el.parentElement.closest('.box');
            if (parent) { ancestors.push(parent); el = parent; } else break;
        }
        ancestors.reverse();
        for (let box of ancestors) {
            if (box.classList.contains('collapsed-mode')) {
                const btn = box.querySelector('.actions-balloon .btn-toggle');
                performToggle(box.id, btn);
                await new Promise(r => setTimeout(r, 800));
            }
        }
    }
    function handleConnectionDblClick(connId, sid, tid) {
        Promise.all([revealHierarchy(sid), revealHierarchy(tid)]);
        if(state.isEditMode) deleteConnection(connId);
    }

    addRootBox();
</script>
</body>
</html>
