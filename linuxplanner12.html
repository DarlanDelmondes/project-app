<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CLI Projects ‚Äî LocalStorage (v9 CMDB)</title>
  <style>
    :root{
      --bg:#0b0f19; --panel:#0f1627; --panel2:#111a2e; --text:#e8eefc; --muted:#9db0d1;
      --line:#243252; --accent:#7aa2ff; --ok:#55e6a5; --warn:#ffd36b; --danger:#ff6b6b; --blue:#65a8ff;
      --shadow: 0 14px 40px rgba(0,0,0,.45); --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    [data-theme="light"]{
      --bg:#f6f7fb; --panel:#ffffff; --panel2:#f3f5fb; --text:#0b1220; --muted:#4b5b78;
      --line:#d7deee; --accent:#2f6bff; --ok:#1a9b66; --warn:#b27b00; --danger:#d83a3a; --blue:#1e64ff;
      --shadow: 0 14px 40px rgba(9,20,45,.12);
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);}
    .wrap{max-width:2250px;margin:18px auto;padding:0 14px;display:grid;gap:12px}
    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
    }
    .brand{display:flex;flex-direction:column;gap:2px}
    .brand .t{font-weight:900;letter-spacing:.2px}
    .brand .s{color:var(--muted);font-size:12px}
    .actions{display:flex;gap:8px;flex-wrap:wrap}
    button{
      border:1px solid var(--line);background:var(--panel2);color:var(--text);
      padding:8px 10px;border-radius:12px;cursor:pointer;font-weight:750
    }
    button:hover{border-color:rgba(122,162,255,.6)}
    .danger{border-color:rgba(255,107,107,.55); color:var(--danger)}
    .ghost{background:transparent}
    .mini{padding:6px 8px;border-radius:10px;font-size:12px}

    .grid{display:grid;grid-template-columns: 0.52fr 1.48fr; gap:12px}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }

    .card{
      border:1px solid var(--line);border-radius:var(--radius);background:var(--panel);
      box-shadow:var(--shadow);overflow:hidden;
    }
    .card .hd{
      padding:12px 14px;border-bottom:1px solid var(--line);
      display:flex;align-items:center;justify-content:space-between;gap:10px
    }
    .card .hd .left{display:flex;flex-direction:column;gap:2px}
    .card .hd .left .k{font-weight:900}
    .card .hd .left .v{color:var(--muted);font-size:12px}
    .card .bd{padding:12px 14px}

    .pill{
      font-family:var(--mono); font-size:12px; padding:2px 8px; border-radius:999px;
      border:1px solid var(--line); color:var(--muted); background:rgba(255,255,255,.03)
    }

    .terminal{
      font-family:var(--mono); font-size:13px; line-height:1.5;
      height: 830px; overflow:auto; padding:12px; border-radius:12px;
      background: radial-gradient(900px 420px at 10% 0%, rgba(122,162,255,.10), transparent 60%),
                  radial-gradient(900px 420px at 90% 0%, rgba(85,230,165,.08), transparent 55%),
                  rgba(0,0,0,.08);
      border:1px solid var(--line);
    }
    .line{white-space:pre-wrap; word-break:break-word; margin:0 0 6px 0}
    .cmd{color:var(--text)}
    .out{color:var(--text)}
    .muted{color:var(--muted)}
    .err{color:var(--danger)}
    .ok{color:var(--ok)}
    .warn{color:var(--warn)}

    .c-red{color:var(--danger)}
    .c-yellow{color:var(--warn)}
    .c-blue{color:var(--blue)}
    .c-green{color:var(--ok)}

    .seqBadge{
      background:#ffffff;
      color:#000000 !important;
      font-weight:900;
      padding:1px 6px;
      border-radius:8px;
    }

    .clickable{cursor:pointer; text-decoration:underline; text-decoration-color:rgba(122,162,255,.45)}
    .clickable:hover{text-decoration-color:rgba(122,162,255,.9)}

    .inputrow{position:relative; display:flex; gap:10px; align-items:center; margin-top:10px}
    .cli{
      width:100%; padding:12px 12px; border-radius:12px; border:1px solid var(--line);
      background:var(--panel2); color:var(--text); font-family:var(--mono); font-size:13px;
      outline:none;
    }
    .cli:focus{border-color:rgba(122,162,255,.7); box-shadow:0 0 0 4px rgba(122,162,255,.12)}

    .ac{
      position:absolute; left:0; right:0; bottom:46px; z-index:20;
      background:var(--panel); border:1px solid var(--line); border-radius:12px;
      box-shadow:var(--shadow); overflow:hidden; display:none; max-height:280px; overflow:auto;
    }
    .ac .item{
      padding:10px 10px; display:flex; justify-content:space-between; gap:10px; cursor:pointer;
      border-bottom:1px solid rgba(255,255,255,.06)
    }
    [data-theme="light"] .ac .item{border-bottom:1px solid rgba(10,10,10,.06)}
    .ac .item:last-child{border-bottom:none}
    .ac .item:hover{background:rgba(122,162,255,.08)}
    .ac .a{font-family:var(--mono)}
    .ac .b{color:var(--muted); font-size:12px}

    .treeWrap{
      font-family:var(--mono); font-size:12.5px; line-height:1.45;
      height: 830px; overflow:auto; padding-right:6px;
    }
    .node{display:flex; gap:8px; align-items:center; padding:6px 8px; border-radius:10px; cursor:pointer; position:relative}
    .node:hover{background:rgba(122,162,255,.08)}
    .node .name{flex:1}
    .indent{padding-left:16px}
    .node.dragging{opacity:.55}

    .node.dropTarget{
      outline:2px dashed rgba(122,162,255,.7);
      background:rgba(122,162,255,.10);
      padding-bottom:18px;
    }
    .node.dropTarget::after{
      content:"Solte aqui para mover";
      position:absolute;
      left:44px;
      bottom:4px;
      font-size:11px;
      color:var(--muted);
      font-family:var(--mono);
    }

    .drawerOverlay{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:flex-end; justify-content:center; padding:16px; z-index:60}
    .drawer{
      width:min(980px, 100%); background:var(--panel); border:1px solid var(--line);
      border-radius:18px; box-shadow:var(--shadow); overflow:hidden;
      max-height: 90vh;
      overflow-y: auto;
      padding-right: 8px; /* espa√ßo pro scrollbar */
    }
    .drawer .dh{padding:12px 14px; border-bottom:1px solid var(--line); display:flex; justify-content:space-between; align-items:center; gap:10px}
    .drawer .db{padding:12px 14px}
    .kv{display:grid; gap:10px}
    .row2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    label{display:grid; gap:6px; font-size:12px; color:var(--muted)}
    input, select, textarea{
      width:100%; padding:10px 10px; border-radius:12px; border:1px solid var(--line);
      background:var(--panel2); color:var(--text); outline:none; font-family:var(--sans);
    }
    textarea{min-height:92px; resize:vertical}
    .sep{height:1px;background:var(--line);margin:12px 0}
    .aliasItem{display:grid; grid-template-columns:1fr 1fr auto; gap:8px; align-items:center}

    .modalOverlay{position:fixed; inset:0; z-index:99999; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; padding:18px; z-index:80}
    .modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      z-index: 99999;
      display: none;
    }
    .modal{ z-index: 100000; width:min(980px, 100%); background:var(--panel); border:1px solid var(--line); border-radius:18px; box-shadow:var(--shadow); overflow:hidden}
    .modal {
      z-index: 100000;
      position: relative;
    }
    .modal .mh{padding:12px 14px; border-bottom:1px solid var(--line); display:flex; justify-content:space-between; align-items:center; gap:10px}
    .modal .mh .title{font-weight:950}
    .modal .mb{padding:12px 14px}
    .modal .mf{padding:12px 14px; border-top:1px solid var(--line); display:flex; justify-content:flex-end; gap:8px; flex-wrap:wrap}
    .row3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}
    .badge{font-family:var(--mono);font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.03)}
    .hint{font-size:12px;color:var(--muted);margin-top:6px}
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="t">CLI Projects ‚Äî LocalStorage</div>
      <div class="s">Terminal + √Årvore ‚Ä¢ <span class="pill" id="cwdPill">/</span></div>
    </div>
    <div class="actions">
      <button id="btnCopy">Copiar sa√≠da</button>
      <button id="btnExport">Exportar</button>
      <button id="btnImport">Importar</button>
      <button id="btnConfig">Config</button>
      <button id="btnTheme">Tema</button>
      <button class="danger" id="btnReset">Reset</button>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <div class="hd">
        <div class="left">
          <div class="k">√Årvore</div>
          <div class="v">Rol√°vel ‚Ä¢ Clique pasta = cd ‚Ä¢ ‚ñ∂/‚ñº expande ‚Ä¢ Arraste e solte na pasta</div>
        </div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
          <button class="mini" id="btnCollapseAll">Colapsar tudo</button>
          <button class="mini" id="btnExpandAll">Expandir tudo</button>
        </div>
      </div>
      <div class="bd">
        <div class="treeWrap" id="sidebarTree"></div>
      </div>
    </div>

    <div class="card">
      <div class="hd">
        <div class="left">
          <div class="k">Terminal</div>
          <div class="v">
            <span class="pill">help</span>
            <span class="pill">mkcmdb</span>
            <span class="pill">app</span>
            <span class="pill">conn</span>
            <span class="pill">cmdb rel</span>
            <span class="pill">focus</span>
            <span class="pill">resumo</span>
          </div>
        </div>
        <div class="left" style="text-align:right">
          <div class="k">Atalhos</div>
          <div class="v">‚Üë/‚Üì hist√≥rico ‚Ä¢ Tab completa ‚Ä¢ Esc fecha</div>
        </div>
      </div>
      <div class="bd">
        <div class="terminal" id="term"></div>
        <div class="inputrow">
          <input class="cli" id="cli" autocomplete="off" spellcheck="false" placeholder="Digite um comando (ex: help)" />
          <div class="ac" id="ac"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Drawer config -->
  <div class="drawerOverlay" id="drawerOverlay">
    <div class="drawer">
      <div class="dh">
        <div style="display:flex;flex-direction:column;gap:2px">
          <div style="font-weight:950">Configura√ß√µes</div>
          <div style="font-size:12px;color:var(--muted)">Aliases e defaults</div>
          <!-- ===== Configura√ß√£o de Fonte por N√≠vel (Tree) ===== -->
<div class="cfgBlock">
  <div class="cfgTitle">Fonte da √Årvore (n√≠veis)</div>

  <div id="fontLevelsBox" class="cfgGroup">
    <!-- gerado via JS -->
  </div>
</div>
        </div>
        <button class="ghost" id="btnCloseConfig">Fechar</button>
      </div>
      <div class="db">
        <div class="kv">
          <div class="row2">
            <label>Prioridade padr√£o (1 alta, 5 baixa)
              <select id="defPriority">
                <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
              </select>
            </label>
            <label>Status padr√£o
              <select id="defStatus">
                <option value="todo">todo</option>
                <option value="doing">doing</option>
                <option value="blocked">blocked</option>
                <option value="sequenciado">sequenciado</option>
                <option value="done">done</option>
              </select>
            </label>
          </div>

          <div class="sep"></div>

          <div style="font-size:12px;color:var(--muted)"><b>Aliases</b> (comando ‚Üí execu√ß√£o)</div>
          <div id="aliases"></div>
          <button id="btnAddAlias">Adicionar alias</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal editor -->
  <div class="modalOverlay" id="modalOverlay">
    <div class="modal">
      <div class="mh">
        <div class="title" id="mTitle">Editar</div>
        <div style="display:flex;gap:8px;align-items:center">
          <span class="badge" id="mPath"></span>
          <button class="ghost" id="mClose">Fechar</button>
        </div>
      </div>
      <div class="mb">
        <!-- Common -->
        <div class="row2">
          <label>Nome
            <input id="mName" />
          </label>
          <label>Pasta (caminho)
            <input id="mFolder" placeholder="/projetos/x" />
          </label>
        </div>

        <!-- TASK fields -->
        <div id="taskFields">
          <div class="row3" style="margin-top:10px">
            <label>Respons√°vel
              <input id="mResp" />
            </label>
            <label>Data (due)
              <input id="mDue" type="date" />
            </label>
            <label>Tipo
              <input id="mType" />
            </label>
          </div>

          <div class="row3" style="margin-top:10px">
            <label>Status
              <select id="mStatus">
                <option value="todo">todo</option>
                <option value="doing">doing</option>
                <option value="blocked">blocked</option>
                <option value="sequenciado">sequenciado</option>
                <option value="done">done</option>
              </select>
            </label>
            <label>Prioridade (1..5)
              <select id="mPrio">
                <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
              </select>
            </label>
            <label>Atualizado em
              <input id="mUpdated" disabled />
            </label>
          </div>

          <label style="margin-top:10px">Anota√ß√µes
            <textarea id="mNotes"></textarea>
          </label>
        </div>

        <!-- URL fields -->
        <div id="urlFields" style="display:none;margin-top:10px">
          <label>URL
            <input id="mUrl" placeholder="https://..." />
          </label>
          <div class="hint">Duplo clique no item abre em nova aba.</div>
        </div>

        <!-- CMDB fields -->
        <div id="cmdbFields" style="display:none;margin-top:10px">
          <div class="row2">
            <label>Hostname
              <input id="mHost" />
            </label>
            <label>IP
              <input id="mIp" placeholder="10.0.0.10" />
            </label>
          </div>
        
          <div class="row2" style="margin-top:10px">
            <label>Datacenter
              <input id="mDc" placeholder="DC1" />
            </label>
            <label>Ambiente
              <input id="mEnv" placeholder="prod|hml|dev" />
            </label>
          </div>
        
          <div class="row2" style="margin-top:10px">
            <label>Namespace
              <input id="mNs" placeholder="payments|core|shared" />
            </label>
            <div></div>
          </div>
        
          <div class="hint">Esta pasta √© do tipo <b>cmdb</b> e representa um host/servidor.</div>
        </div>

        <!-- APP fields -->
        <div id="appFields" style="display:none;margin-top:10px">
          <div class="row2">
            <label>Porta
              <input id="mAppPort" type="number" min="1" max="65535" />
            </label>
            <label>Ligado ao CMDB (somente leitura)
              <input id="mAppCmdb" disabled />
            </label>
          </div>
        </div>

        <!-- CONN fields -->
        <div id="connFields" style="display:none;margin-top:10px">
          <div class="row3">
            <label>Origem (application)
              <select id="mFrom"></select>
            </label>
            <label>Destino (application)
              <select id="mTo"></select>
            </label>
            <label>Porta
              <input id="mConnPort" type="number" min="1" max="65535" />
            </label>
          </div>
          <div class="row2" style="margin-top:10px">
            <label>Status conectividade
              <select id="mConnStatus">
                <option value="nao-testada">nao-testada</option>
                <option value="testada">testada</option>
                <option value="bloqueada">bloqueada</option>
              </select>
            </label>
            <label>Atualizado em
              <input id="mConnUpdated" disabled />
            </label>
          </div>
          <div class="hint">A origem/destino s√£o applications existentes (podem estar em qualquer CMDB).</div>
        </div>
      </div>

      <div class="mf">
        <button class="danger" id="mDelete">Excluir</button>
        <button id="mSave">Salvar</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const LS_KEY = "cli_projects_v9_state";
  const SET_KEY = "cli_projects_v9_settings";
  const $ = (id) => document.getElementById(id);

  const term = $("term");
  const cli = $("cli");
  const ac = $("ac");
  const cwdPill = $("cwdPill");
  const sidebarTree = $("sidebarTree");

  const drawerOverlay = $("drawerOverlay");
  const defPriority = $("defPriority");
  const defStatus = $("defStatus");
  const aliasesBox = $("aliases");

  const modalOverlay = $("modalOverlay");
  const mTitle = $("mTitle");
  const mPath = $("mPath");
  const mClose = $("mClose");
  const mName = $("mName");
  const mFolder = $("mFolder");

  // Task fields
  const taskFields = $("taskFields");
  const mResp = $("mResp");
  const mDue = $("mDue");
  const mType = $("mType");
  const mStatus = $("mStatus");
  const mPrio = $("mPrio");
  const mNotes = $("mNotes");
  const mUpdated = $("mUpdated");

  // URL fields
  const urlFields = $("urlFields");
  const mUrl = $("mUrl");

  // CMDB fields
  const cmdbFields = $("cmdbFields");
  const mHost = $("mHost");
  const mIp = $("mIp");
  const mNs = $("mNs");
  const mDc = $("mDc");
  const mEnv = $("mEnv");

  // APP fields
  const appFields = $("appFields");
  const mAppPort = $("mAppPort");
  const mAppCmdb = $("mAppCmdb");

  // CONN fields
  const connFields = $("connFields");
  const mFrom = $("mFrom");
  const mTo = $("mTo");
  const mConnPort = $("mConnPort");
  const mConnStatus = $("mConnStatus");
  const mConnUpdated = $("mConnUpdated");

  const mDelete = $("mDelete");
  const mSave = $("mSave");

  const btnCollapseAll = $("btnCollapseAll");
  const btnExpandAll = $("btnExpandAll");

  let editingId = null;
  let lastOutputText = "";
  let inputHistory = [];
  let histIdx = -1;

  // Tags gerais (tarefas)
  const TAGS = ["@resp","@due","@status","@type","@prio","@note"];

  // Tags CMDB
  const CMDB_TAGS = ["@hostname","@ip","@dc","@env"];

  // Tags app/conn
  const APP_TAGS = ["@port"];
  const CONN_TAGS = ["@from","@to","@port","@status"];

  function nowISO(){ return new Date().toISOString(); }
  function rid(){ return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2); }
  function pad(n){ return String(n).padStart(2,"0"); }
  function todayISODate(){
    const d = new Date();
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }
  function parseDateTS(dateStr){
    if(!dateStr) return null;
    const t = Date.parse(dateStr + "T00:00:00");
    return isNaN(t) ? null : t;
  }
  function isoToDateOnly(iso){ return (iso||"").slice(0,10); }
  function daysBetween(tsA, tsB){
    return Math.floor((tsA - tsB) / (24*3600*1000));
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function defaultState(){
    return {
      nodes: [
        { id:"root", type:"dir", name:"/", parentId:null, createdAt: nowISO(), updatedAt: nowISO() },
        { id: rid(), type:"dir", name:"projetos", parentId:"root", createdAt: nowISO(), updatedAt: nowISO() },
        { id: rid(), type:"dir", name:"infra", parentId:"root", createdAt: nowISO(), updatedAt: nowISO() },
        { id: rid(), type:"negocio", name:"negocio", parentId:"root", createdAt: nowISO(), updatedAt: nowISO() }
      ],
      cwdId:"root"
    };
  }

  function defaultSettings(){
    return {
      theme:"dark",
      defPriority: 3,
      defStatus: "todo",
      sidebarExpanded: { "root": true },
      aliases: {
        "hoje": "q hoje",
        "atrasadas": "q atrasadas",
        "por-pessoa": "q por-pessoa",
        "sem-data": "q sem-data",
        "sem-resp": "q sem-resp",
        "sem-att": "q sem-att",
        "por-projeto": "q por-projeto",
        "sem-tipo": "q sem-tipo",
        "por-tipo": "q por-tipo",
        "agora": "focus",
        "r": "resumo",
        "cm": "cmdb",
        "rel": "cmdb rel"
      },
      sidebarFontLevels: {
        1: { size: 14, bold: true,  italic: false, color: "" },
        2: { size: 13, bold: true,  italic: false, color: "" },
        3: { size: 12, bold: false, italic: false, color: "" },
        4: { size: 12, bold: false, italic: true,  color: "" },
        5: { size: 11, bold: false, italic: false, color: "" }
      }
    };
  }

  function loadJSON(key, fallback){
    const raw = localStorage.getItem(key);
    if(!raw) return fallback;
    try{ return JSON.parse(raw); } catch { return fallback; }
  }
  function saveState(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
  function saveSettings(){ localStorage.setItem(SET_KEY, JSON.stringify(settings)); }

  let state = loadJSON(LS_KEY, defaultState());
  let settings = loadJSON(SET_KEY, defaultSettings());
  settings.aliases = { ...defaultSettings().aliases, ...(settings.aliases||{}) };
  settings.sidebarExpanded = settings.sidebarExpanded || { "root": true };

  function setTheme(){
    document.documentElement.setAttribute("data-theme", settings.theme === "light" ? "light" : "dark");
  }

  function printLine(text, cls="out"){
    const div = document.createElement("div");
    div.className = "line " + cls;
    div.textContent = text;
    term.appendChild(div);
    term.scrollTop = term.scrollHeight;
    lastOutputText += text + "\n";
  }
  function printHTMLLine(html, cls="out"){
    const div = document.createElement("div");
    div.className = "line " + cls;
    div.innerHTML = html;
    term.appendChild(div);
    term.scrollTop = term.scrollHeight;
    const tmp = document.createElement("div");
    tmp.innerHTML = html;
    lastOutputText += (tmp.textContent || "") + "\n";
  }
  function clearOutBuf(){ lastOutputText = ""; }

  function nodeById(id){ return state.nodes.find(n=>n.id===id) || null; }
  function childrenOf(pid){ return state.nodes.filter(n=>n.parentId===pid); }

  function isDir(n){ return n && n.type==="dir"; }
  function isCMDBDir(n){ return n && n.type==="cmdbdir"; }
  function isTask(n){ return n && n.type==="file"; }
  function isUrl(n){ return n && n.type==="url"; }
  function isApp(n){ return n && n.type==="app"; }
  function isConnRef(n){ return n && n.type==="connref"; }
  function isConn(n){ return n && n.type==="conn"; }

  const isBizDir   = n => n && n.type === "biz";
  const isFlow     = n => n && n.type === "flow";
  const isOperacao = n => n && n.type === "operacao";

  function isAnyItem(n){ return isTask(n) || isUrl(n) || isApp(n) || isConn(n) || isConnRef(n); }

  function cwdPath(){
    let cur = nodeById(state.cwdId) || nodeById("root");
    if(!cur){ state = defaultState(); saveState(); cur = nodeById("root"); }
    if(cur.id==="root") return "/";
    const parts = [];
    while(cur && cur.id!=="root"){
      parts.push(cur.name);
      cur = nodeById(cur.parentId);
    }
    return "/" + parts.reverse().join("/");
  }
  function updateCwd(){ cwdPill.textContent = cwdPath(); }

  function fullPathOf(id){
    const n = nodeById(id);
    if(!n) return "";
    if(n.id==="root") return "/";
    const parts = [];
    let cur = n;
    while(cur && cur.id!=="root"){
      parts.push(cur.name);
      cur = nodeById(cur.parentId);
    }
    return "/" + parts.reverse().join("/");
  }

  function resolvePath(pathStr){
    if(!pathStr || pathStr === ".") return state.cwdId;
    let curId = pathStr.startsWith("/") ? "root" : state.cwdId;
    const parts = (pathStr.startsWith("/") ? pathStr.slice(1) : pathStr).split("/").filter(Boolean);

    for(const part of parts){
      if(part === ".") continue;
      if(part === ".."){
        const cur = nodeById(curId);
        if(cur && cur.parentId) curId = cur.parentId;
        continue;
      }
      const next = childrenOf(curId).find(n=>n.name===part);
      if(!next) return null;
      curId = next.id;
    }
    return curId;
  }

  function splitParentAndName(pathStr){
    const abs = pathStr.startsWith("/");
    const cleaned = pathStr.replace(/\/+$/,"");
    const parts = cleaned.split("/").filter(Boolean);
    const name = parts.pop() || "";
    const parentPath = (abs?"/":"") + parts.join("/");
    return { parentPath: parentPath || (abs?"/":"."), name };
  }

  function touch(id){
    const n = nodeById(id);
    if(n) n.updatedAt = nowISO();
  }

  function createDir(name, parentId){
    if(!name || name.includes("/")) return {ok:false, err:"Nome inv√°lido."};
    if(childrenOf(parentId).some(n=>n.name===name)) return {ok:false, err:"J√° existe."};
    const n = { id: rid(), type:"dir", name, parentId, createdAt: nowISO(), updatedAt: nowISO() };
    state.nodes.push(n);
    touch(parentId);
    saveState();
    return {ok:true, node:n};
  }

  function createCMDBDir(name, parentId, meta){
    if(!name || name.includes("/")) return {ok:false, err:"Nome inv√°lido."};
    if(childrenOf(parentId).some(n=>n.name===name)) return {ok:false, err:"J√° existe."};
    const n = {
      id: rid(), type:"cmdbdir", name, parentId,
      createdAt: nowISO(), updatedAt: nowISO(),
      hostname: meta.hostname || "",
      ip: meta.ip || "",
      datacenter: meta.dc || "",
      ambiente: meta.env || ""
    };
    state.nodes.push(n);
    touch(parentId);
    saveState();
    return {ok:true, node:n};
  }

  function createTaskFile(name, parentId, meta){
    if(!name || name.includes("/")) return {ok:false, err:"Nome inv√°lido."};
    if(childrenOf(parentId).some(n=>n.name===name)) return {ok:false, err:"J√° existe."};
    const f = {
      id: rid(), type:"file", name, parentId,
      createdAt: nowISO(), updatedAt: nowISO(),
      resp: meta.resp || "",
      due: meta.due || "",
      status: meta.status || settings.defStatus,
      taskType: meta.type || "",
      prio: Number(meta.prio || settings.defPriority),
      notes: meta.note || ""
    };
    state.nodes.push(f);
    touch(parentId);
    saveState();
    return {ok:true, node:f};
  }

  function createUrl(name, link, parentId, meta){
    if(!name || name.includes("/")) return {ok:false, err:"Nome inv√°lido."};
    if(!link || !/^https?:\/\//i.test(link)) return {ok:false, err:"URL inv√°lida (use http/https)."};
    if(childrenOf(parentId).some(n=>n.name===name)) return {ok:false, err:"J√° existe."};

    const u = {
      id: rid(), type:"url", name, parentId,
      createdAt: nowISO(), updatedAt: nowISO(),
      url: link,
      resp: meta.resp || "",
      due: meta.due || "",
      status: meta.status || settings.defStatus,
      taskType: meta.type || "",
      prio: Number(meta.prio || settings.defPriority),
      notes: meta.note || ""
    };
    state.nodes.push(u);
    touch(parentId);
    saveState();
    return {ok:true, node:u};
  }

  function nearestCMDBDirId(fromDirId){
    let cur = nodeById(fromDirId);
    while(cur){
      if(isCMDBDir(cur)) return cur.id;
      if(!cur.parentId) break;
      cur = nodeById(cur.parentId);
    }
    return null;
  }

  function createApp(name, parentId, meta){
    if(!name || name.includes("/")) return {ok:false, err:"Nome inv√°lido."};
    if(childrenOf(parentId).some(n=>n.name===name)) return {ok:false, err:"J√° existe."};

    const cmdbId = nearestCMDBDirId(parentId);
    if(!cmdbId) return {ok:false, err:"Crie applications dentro de uma pasta cmdb (mkcmdb ... e entre nela)."};
    const port = Number(meta.port || "");
    if(!(port>=1 && port<=65535)) return {ok:false, err:"@port inv√°lida (1..65535)."};

    const a = {
      id: rid(), type:"app", name, parentId,
      createdAt: nowISO(), updatedAt: nowISO(),
      port,
      cmdbId
    };
    state.nodes.push(a);
    touch(parentId);
    saveState();
    return {ok:true, node:a};
  }

  function allApps(){
    return state.nodes.filter(isApp);
  }

  function findAppByName(name){
    const n = (name||"").trim().toLowerCase();
    if(!n) return null;
    // tenta match exato primeiro
    const exact = allApps().find(a => (a.name||"").trim().toLowerCase() === n);
    if(exact) return exact;
    // fallback: contains √∫nico
    const hits = allApps().filter(a => (a.name||"").trim().toLowerCase().includes(n));
    if(hits.length===1) return hits[0];
    return null;
  }

  function parseAppRefToken(raw){
    const s = (raw||"").toString().trim();
    if(!s) return { name:"", id:"" };
  
    // aceita "Nome#ID" (ID ap√≥s o √∫ltimo #)
    const idx = s.lastIndexOf("#");
    if(idx > 0 && idx < s.length-1){
      return {
        name: s.slice(0, idx).trim(),
        id: s.slice(idx+1).trim()
      };
    }
    return { name: s, id: "" };
  }
  
  function resolveAppFromRefToken(raw){
    const { name, id } = parseAppRefToken(raw);
  
    // 1) se vier ID e existir app com esse ID, usa
    if(id){
      const byId = nodeById(id);
      if(byId && isApp(byId)) return byId;
    }
  
    // 2) fallback: tenta pelo name
    const byName = findAppByName(name);
    if(byName) return byName;
  
    // 3) fallback final: se o token inteiro for um id puro
    const maybeId = nodeById(raw);
    if(maybeId && isApp(maybeId)) return maybeId;
  
    return null;
  }

  function createConn(parentId, meta){
    const cmdbId = nearestCMDBDirId(parentId);
    if(!cmdbId) return {ok:false, err:"Crie conectividades dentro de uma pasta cmdb."};

    const fromRaw = meta.from || "";
    const toRaw = meta.to || "";
    
    const fromApp = resolveAppFromRefToken(fromRaw);
    const toApp   = resolveAppFromRefToken(toRaw);

    if(!fromApp || !isApp(fromApp)) return {ok:false, err:"@from precisa ser um application existente (nome#id, nome ou id)."};
    if(!toApp || !isApp(toApp)) return {ok:false, err:"@to precisa ser um application existente (nome#id, nome ou id)."};
    const port = Number(meta.port || "");
    if(!(port>=1 && port<=65535)) return {ok:false, err:"@port inv√°lida (1..65535)."};

    const st = (meta.status||"nao-testada").toLowerCase();
    if(st !== "nao-testada" && st !== "testada" && st !== "bloqueada")
    return {ok:false, err:"@status deve ser nao-testada, testada ou bloqueada."};

    const name = `${fromApp.name} -> ${toApp.name}:${port}`;
    if(childrenOf(parentId).some(n=>n.name===name)) return {ok:false, err:"J√° existe conectividade com esse nome na pasta."};

    const c = {
      id: rid(), type:"conn", name, parentId,
      createdAt: nowISO(), updatedAt: nowISO(),
      fromAppId: fromApp.id,
      toAppId: toApp.id,
      port,
      connStatus: st,
      cmdbId
    };
    state.nodes.push(c);
    touch(parentId);
    saveState();
    createCrossRefForConn(c, cmdbId);
    return {ok:true, node:c};
  }

  function connRefName(conn, fromApp, toApp){
    // Nome est√°vel: n√£o inclui status para n√£o ‚Äúficar desatualizado‚Äù
    return `[ref] ${fromApp.name} -> ${toApp.name}:${conn.port}`;
  }
  
  function existingConnRef(targetDirId, connId){
    return childrenOf(targetDirId).find(n => isConnRef(n) && n.refConnId === connId) || null;
  }
  
  function createConnRef(targetDirId, conn){
    const fromApp = nodeById(conn.fromAppId);
    const toApp = nodeById(conn.toAppId);
    if(!fromApp || !toApp) return {ok:false, err:"apps n√£o encontrados"};
  
    if(existingConnRef(targetDirId, conn.id)) return {ok:true, noop:true};
  
    const name = connRefName(conn, fromApp, toApp);
    // evita colis√£o por nome
    if(childrenOf(targetDirId).some(n => n.name === name)){
      // se colidir, s√≥ cria com sufixo curto
      const name2 = name + " #" + conn.id.slice(0,4);
      if(childrenOf(targetDirId).some(n => n.name === name2)) return {ok:true, noop:true};
      return createConnRefNode(targetDirId, conn, name2);
    }
    return createConnRefNode(targetDirId, conn, name);
  }
  
  function createConnRefNode(targetDirId, conn, name){
    const ref = {
      id: rid(),
      type: "connref",
      name,
      parentId: targetDirId,
      createdAt: nowISO(),
      updatedAt: nowISO(),
      refConnId: conn.id
    };
    state.nodes.push(ref);
    touch(targetDirId);
    saveState();
    return {ok:true, node:ref};
  }
  
  /**
   * Regra que voc√™ pediu:
   * - Se a conectividade foi criada no cmdb da ORIGEM, cria ref no cmdb do DESTINO
   * - Se foi criada no cmdb do DESTINO, cria ref no cmdb da ORIGEM
   * - Se foi criada em outro cmdb (ou fora), cria refs em ambos (fallback seguro)
   */
  function createCrossRefForConn(conn, createdInCmdbId){
    const fromApp = nodeById(conn.fromAppId);
    const toApp = nodeById(conn.toAppId);
    if(!fromApp || !toApp) return;
  
    const fromCmdbId = fromApp.cmdbId;
    const toCmdbId = toApp.cmdbId;
  
    if(!fromCmdbId || !toCmdbId) return;
  
    if(createdInCmdbId === fromCmdbId && toCmdbId !== fromCmdbId){
      createConnRef(toCmdbId, conn);
      return;
    }
    if(createdInCmdbId === toCmdbId && fromCmdbId !== toCmdbId){
      createConnRef(fromCmdbId, conn);
      return;
    }
  
    // fallback: cria nos dois lados quando n√£o d√° pra inferir ‚Äúlado onde criou‚Äù
    if(fromCmdbId !== toCmdbId){
      createConnRef(fromCmdbId, conn);
      createConnRef(toCmdbId, conn);
    }
  }

  function removeNode(id){
    if(id === "root") return {ok:false, err:"N√£o pode."};

    const n = nodeById(id);
    if(!n) return {ok:false, err:"Ref n√£o encontrada (id inv√°lido ou j√° removida)."};
  
    if((isDir(n) || isCMDBDir(n)) && childrenOf(id).length)
      return {ok:false, err:"Pasta n√£o vazia (use rm -r)."};

    // se remover app, previne se tiver conn referenciando
    if(isApp(n)){
      const used = state.nodes.filter(isConn).some(c => c.fromAppId===n.id || c.toAppId===n.id);
      if(used) return {ok:false, err:"Esse application est√° referenciado em conectividades. Remova/ajuste as conectividades antes."};
    }

    const p = n.parentId;
    state.nodes = state.nodes.filter(x=>x.id!==id);
    touch(p);
    if(state.cwdId===id) state.cwdId = p || "root";
    saveState();
    return {ok:true};
  }

  function removeTree(id){
    const n = nodeById(id);
    if(!n || id==="root") return {ok:false, err:"N√£o pode."};

    // bloqueia remover √°rvore se ela cont√©m app referenciado fora? (simplifica√ß√£o: bloqueia se qualquer app dentro tem conn em qualquer lugar)
    const del = new Set();
    (function dfs(x){
      del.add(x);
      for(const c of childrenOf(x)) dfs(c.id);
    })(id);

    const appsToDel = state.nodes.filter(isApp).filter(a => del.has(a.id));
    for(const a of appsToDel){
      const used = state.nodes.filter(isConn).some(c => c.fromAppId===a.id || c.toAppId===a.id);
      if(used) return {ok:false, err:`√Årvore cont√©m application referenciado em conectividade (${a.name}). Remova/ajuste conectividades antes.`};
    }

    const p = n.parentId;
    state.nodes = state.nodes.filter(x=>!del.has(x.id));
    touch(p);
    if(del.has(state.cwdId)) state.cwdId = p || "root";
    saveState();
    return {ok:true, count: del.size};
  }

  function moveNode(srcId, dstParentId, newName=null){
    const src = nodeById(srcId);
    if(!src || srcId==="root") return {ok:false, err:"Origem inv√°lida."};
    const nm = newName || src.name;
    if(childrenOf(dstParentId).some(n=>n.name===nm && n.id!==srcId)) return {ok:false, err:"Destino j√° tem esse nome."};
    const oldP = src.parentId;
    src.parentId = dstParentId;
    src.name = nm;
    src.updatedAt = nowISO();
    touch(oldP); touch(dstParentId);
    saveState();
    return {ok:true, node:src};
  }

  function isDescendantDir(targetDirId, maybeAncestorDirId){
    if(targetDirId === maybeAncestorDirId) return true;
    let cur = nodeById(targetDirId);
    while(cur && cur.parentId){
      if(cur.parentId === maybeAncestorDirId) return true;
      cur = nodeById(cur.parentId);
    }
    return false;
  }
  function canMove(srcId, dstDirId){
    if(!srcId || !dstDirId) return { ok:false, err:"Move inv√°lido." };
    if(srcId === "root") return { ok:false, err:"N√£o pode mover root." };

    const src = nodeById(srcId);
    const dst = nodeById(dstDirId);
    if(!src) return { ok:false, err:"Origem n√£o existe." };
    if(!(isDir(dst) || isCMDBDir(dst))) return { ok:false, err:"Destino n√£o √© pasta." };

    if(src.parentId === dstDirId) return { ok:true, noop:true };

    if((isDir(src) || isCMDBDir(src)) && isDescendantDir(dstDirId, srcId)){
      return { ok:false, err:"N√£o pode mover uma pasta para dentro dela mesma." };
    }

    if(childrenOf(dstDirId).some(n => n.name === src.name && n.id !== src.id)){
      return { ok:false, err:"J√° existe um item com esse nome na pasta destino." };
    }

    return { ok:true, noop:false };
  }
  function moveNodeToDir(srcId, dstDirId){
    const chk = canMove(srcId, dstDirId);
    if(!chk.ok) return chk;
    if(chk.noop) return chk;

    const src = nodeById(srcId);
    const oldP = src.parentId;

    src.parentId = dstDirId;
    src.updatedAt = nowISO();

    // se app muda de cmdb, atualiza cmdbId
    if(isApp(src)){
      const newCmdb = nearestCMDBDirId(dstDirId);
      if(newCmdb) src.cmdbId = newCmdb;
    }
    // se conn muda de cmdb, atualiza cmdbId
    if(isConn(src)){
      const newCmdb = nearestCMDBDirId(dstDirId);
      if(newCmdb) src.cmdbId = newCmdb;
    }

    touch(oldP);
    touch(dstDirId);

    saveState();
    return { ok:true };
  }

  function tokenize(s){
    const out=[]; let cur=""; let inQ=false;
    for(let i=0;i<s.length;i++){
      const c=s[i];
      if(c === '"'){ inQ=!inQ; continue; }
      if(!inQ && /\s/.test(c)){ if(cur){ out.push(cur); cur=""; } }
      else cur+=c;
    }
    if(cur) out.push(cur);
    return out;
  }

  function promptPrefix(){ return `${cwdPath()} $`; }
  function echoCmd(cmd){ printLine(`${promptPrefix()} ${cmd}`, "cmd"); }

  function isDescendantOrSelf(nodeId, rootId){
    if(nodeId === rootId) return true;
    let cur = nodeById(nodeId);
    while(cur && cur.parentId){
      if(cur.parentId === rootId) return true;
      cur = nodeById(cur.parentId);
      if(cur && cur.id === rootId) return true;
    }
    return false;
  }
  function itemsInScope(scopeDirId){
    return state.nodes.filter(isAnyItem).filter(f => isDescendantOrSelf(f.parentId, scopeDirId));
  }

  function sortByImportance(a,b){
    const pa = Number(a.prio||3), pb = Number(b.prio||3);
    if(pa !== pb) return pa - pb;
    const ta = Date.parse(a.updatedAt||a.createdAt||nowISO());
    const tb = Date.parse(b.updatedAt||b.createdAt||nowISO());
    if(ta !== tb) return ta - tb;
    return a.name.localeCompare(b.name);
  }
  function groupBy(arr, keyFn){
    const m=new Map();
    for(const x of arr){
      const k=keyFn(x);
      if(!m.has(k)) m.set(k, []);
      m.get(k).push(x);
    }
    return m;
  }

  function taskColorClass(t){
    const today = todayISODate();
    if((t.status||"") === "sequenciado") return "seqBadge";
    if((t.status||"") === "done") return "c-blue";
    if(t.due){
      if(t.due < today) return "c-red";
      if(t.due === today) return "c-yellow";
    }
    return "c-green";
  }

  function connColorClass(c){
    if(c.connStatus === "bloqueada") return "c-red";
    return (c.connStatus === "testada") ? "c-blue" : "c-yellow";
  }

  function renderClickableName(node){
    if(isUrl(node)){
      return `<span class="clickable" data-url="${escapeHtml(node.url||"")}">${escapeHtml(node.name)}</span>`;
    }
    if(isTask(node)){
      const cls = taskColorClass(node);
      return `<span class="clickable ${cls}" data-open="${node.id}">${escapeHtml(node.name)}</span>`;
    }
    if(isCMDBDir(node) || isApp(node) || isConn(node)){
      return `<span class="clickable" data-open="${node.id}">${escapeHtml(node.name)}</span>`;
    }
    return escapeHtml(node.name);
  }

  function attachDblClickHandlers(){
    term.querySelectorAll("[data-open]").forEach(elm=>{
      elm.ondblclick = () => openModal(elm.getAttribute("data-open"));
    });
  
    term.querySelectorAll("[data-url]").forEach(elm=>{
      elm.ondblclick = () => {
        const u = elm.getAttribute("data-url");
        if(u) window.open(u, "_blank", "noopener,noreferrer");
      };
    });
  
    // ‚úÖ novo: duplo clique apaga connref quebrada
term.querySelectorAll("[data-delref]").forEach(elm=>{
  elm.ondblclick = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const id = elm.dataset.delref; // <- aqui
    if(!id) { printLine("ref: id vazio", "err"); return; }

    const r = removeNode(id);
    if(!r.ok) printLine("ref: " + r.err, "err");
    else printLine("Ref quebrada removida.", "ok");

    updateCwd();
    renderSidebar();
  };
});
  }

  function focusScore(t){
    if((t.status||"") === "done") return { score: -99999, reason:["done"] };

    const today = todayISODate();
    const todayTS = parseDateTS(today);
    const dueTS = t.due ? parseDateTS(t.due) : null;

    let score = 0;
    const reason = [];

    const pr = Number(t.prio || 3);
    score += (6 - pr) * 25;
    reason.push(`prio p${pr} ‚Üí +${(6-pr)*25}`);

    const st = t.status || "todo";
    if(st === "doing"){ score += 20; reason.push("doing ‚Üí +20"); }
    if(st === "blocked"){ score -= 30; reason.push("blocked ‚Üí -30"); }
    if(st === "sequenciado"){ score += 35; reason.push("sequenciado ‚Üí +35"); }

    if(dueTS !== null){
      const daysLate = Math.max(0, daysBetween(todayTS, dueTS));
      const daysAhead = Math.max(0, daysBetween(dueTS, todayTS));
      if(t.due < today){
        const add = 140 + Math.min(200, daysLate * 18);
        score += add;
        reason.push(`atrasado ${daysLate}d ‚Üí +${add}`);
      } else if(t.due === today){
        score += 90;
        reason.push("vence hoje ‚Üí +90");
      } else {
        const boost = Math.max(0, 60 - daysAhead * 12);
        score += boost;
        reason.push(`vence em ${daysAhead}d ‚Üí +${boost}`);
      }
    } else {
      score -= 15;
      reason.push("sem due ‚Üí -15");
    }

    const upd = Date.parse(t.updatedAt || t.createdAt || nowISO());
    const ageDays = Math.max(0, Math.floor((Date.now() - upd) / (24*3600*1000)));
    const staleBoost = Math.min(40, ageDays * 3);
    score += staleBoost;
    if(staleBoost) reason.push(`sem update ${ageDays}d ‚Üí +${staleBoost}`);

    if(!(t.resp||"").trim()){
      score -= 10;
      reason.push("sem resp ‚Üí -10");
    }

    return { score, reason };
  }

  function cmd_focus(){
    const tasks = itemsInScope(state.cwdId).filter(isTask).filter(t => (t.status||"") !== "done");
    if(!tasks.length){
      printLine("focus: nenhum item (task) pendente no escopo atual.", "muted");
      return;
    }
    let best = null;
    let bestS = -1e9;
    let bestR = [];
    for(const t of tasks){
      const {score, reason} = focusScore(t);
      if(score > bestS){
        bestS = score; best = t; bestR = reason;
      }
    }
    printLine("Seu foco agora (tarefas, escopo atual, recursivo):", "out");
    printHTMLLine("  " + fmtTaskLine(best) + ` <span class="muted">[score ${bestS}]</span>`, "out");
    printLine("Motivo:", "muted");
    bestR.slice(0,8).forEach(r=>printLine("  - " + r, "muted"));
    attachDblClickHandlers();
  }

  function cmd_help(){
    printLine("Comandos:", "out");
    printLine("  ls | ls -ltra", "muted");
    printLine("  mkdir <pasta>        (cria e entra)", "muted");
    printLine("  cd <pasta|/caminho|..>", "muted");
    printLine("  rm <caminho> | rm -r <pasta>", "muted");
    printLine("  mv <origem> <destino>", "muted");
    printLine("  tree [--depth N]", "muted");
    printLine("  add <nome> @resp <x> @due <YYYY-MM-DD> @status <todo|doing|blocked|sequenciado|done> @type <...> @prio <1-5> @note <...>", "muted");
    printLine('  url "Nome" https://site.com', "muted");
    printLine("  mkcmdb <nome> @hostname X @ip 10.0.0.1 @dc DC1 @env prod   (cria pasta cmdb e entra)", "muted");
    printLine('  app "NomeApp" @port 8080   (cria application dentro de cmdb)', "muted");
    printLine('  conn @from "AppA" @to "AppB" @port 443 @status nao-testada|testada', "muted");
    printLine("  cmdb | cmdb rel", "muted");
    printLine("  q hoje | atrasadas | por-pessoa | sem-data | sem-resp | sem-att | por-projeto | sem-tipo | por-tipo | tipo <X>", "muted");
    printLine("  resumo  (tarefas)", "muted");
    printLine("  @resp   (lista respons√°veis)", "muted");
    printLine("  focus", "muted");
    printLine("  aliases | pwd | clear", "muted");
    printLine("  conn pendentes | conn testadas | conn status <nao-testada|testada>", "muted");
    printLine("  cmdb graph [errors|nao-testada]  (grafo DC/ENV/CMDB; portas IN/OUT; no modo normal, hover na app destaca conex√µes)", "muted");
    printLine("  cmdb find <trecho>   (busca sem case-sensitive em CMDB, apps e conectividades)", "muted");
    printLine("  flow app1 > app2 > app3  ‚Äî anima o fluxo no grafo", "muted");

  }

  function cmd_pwd(){ printLine(cwdPath(), "out"); }
  function cmd_clear(){ term.innerHTML=""; }

  function cmd_ls(args){
    const flags = args.filter(a=>a.startsWith("-")).join("");
    const longFmt = flags.includes("l");
    const sortTime = flags.includes("t");
    const reverse = flags.includes("r");
    const showAll = flags.includes("a");
  
    let list = childrenOf(state.cwdId);
    if(!showAll) list = list.filter(n=>!n.name.startsWith("."));
  
    list.sort((a,b)=>{
      if(sortTime) return Date.parse(a.updatedAt||a.createdAt||nowISO()) - Date.parse(b.updatedAt||b.createdAt||nowISO());
      return a.name.localeCompare(b.name);
    });
    if(reverse) list.reverse();
  
    if(!list.length){ printLine("(vazio)", "muted"); return; }
  
    // curto
    if(!longFmt){
      printLine(list.map(n=>{
        if(isDir(n)) return `${n.name}/`;
        if(isCMDBDir(n)) return `${n.name}{cmdb}/`;
        if(isUrl(n)) return `${n.name}@`;
        if(isApp(n)) return `${n.name}{app}`;
        if(isConn(n)) return `${n.name}{conn}`;
        if(isConnRef(n)) return `${n.name}{ref}`;
        return n.name;
      }).join("  "), "out");
      return;
    }
  
    // longo
    for(const n of list){
      if(isDir(n)){
        printLine(`d   ${isoToDateOnly(n.updatedAt)}  ${n.name}/`, "out");
        continue;
      }
  
      if(isCMDBDir(n)){
        const meta = `host=${n.hostname||"-"} ip=${n.ip||"-"} dc=${n.datacenter||"-"} env=${n.ambiente||"-"}`;
        printHTMLLine(`C   ${escapeHtml(isoToDateOnly(n.updatedAt))}  ${renderClickableName(n)} <span class="muted">${escapeHtml("{cmdb} "+meta)}</span>`, "out");
        continue;
      }
  
      if(isUrl(n)){
        printHTMLLine(`@   ${escapeHtml(isoToDateOnly(n.updatedAt))}  üîó ${renderClickableName(n)} <span class="muted">${escapeHtml("("+(n.url||"")+")")}</span>`, "out");
        continue;
      }
  
      if(isApp(n)){
        const cm = nodeById(n.cmdbId);
        const cmName = cm ? cm.name : "-";
        printHTMLLine(`A   ${escapeHtml(isoToDateOnly(n.updatedAt))}  ${renderClickableName(n)} <span class="muted">${escapeHtml("{app} port="+(n.port||"-")+" cmdb="+cmName)}</span>`, "out");
        continue;
      }
  
      if(isConn(n)){
        const fa = nodeById(n.fromAppId);
        const ta = nodeById(n.toAppId);
        const stCls = connColorClass(n);
        const st = n.connStatus || "nao-testada";
        printHTMLLine(
          `N   ${escapeHtml(isoToDateOnly(n.updatedAt))}  <span class="${stCls}">${escapeHtml(st)}</span>  ${renderClickableName(n)} ` +
          `<span class="muted">${escapeHtml("{conn} "+(fa?fa.name:"-")+" -> "+(ta?ta.name:"-")+":"+(n.port||"-"))}</span>`,
          "out"
        );
        continue;
      }
  
      // ‚úÖ connref ‚Äúigualzinha‚Äù √† conn (status/cor/texto), puxando do alvo
      if(isConnRef(n)){
        const target = nodeById(n.refConnId);
        if(!target || !isConn(target)){
          printHTMLLine(
            `R   ${escapeHtml(isoToDateOnly(n.updatedAt))}  üîó ` +
            `<span class="clickable c-red" data-delref="${escapeHtml(n.id)}">ref quebrada (dblclick apaga)</span> ` +
            `<span class="muted">{connref}</span> <span class="muted">id=${escapeHtml(n.id)}</span>`,
            "out"
          );
        } else {
          printHTMLLine(
            `R   ${escapeHtml(isoToDateOnly(n.updatedAt))}  ` +
            fmtConnLine(target).replace("üîå","üîó") +
            ` <span class="muted">{connref}</span> <span class="muted">id=${escapeHtml(n.id)}</span>`,
            "out"
          );
        }
      
        continue;
      }
  
      // fallback
      printHTMLLine(`-   ${escapeHtml(isoToDateOnly(n.updatedAt))}  ${renderClickableName(n)}`, "out");
    }
  
    attachDblClickHandlers();
  }

  function cmd_tree(args){
    const maxDepth = (() => {
      const i = args.findIndex(a=>a==="--depth");
      if(i>=0 && args[i+1]) return Math.max(1, parseInt(args[i+1],10)||10);
      return 50;
    })();

    printLine(cwdPath(), "out");

    const lines = [];
    function walk(dirId, prefix, depth){
      if(depth > maxDepth) return;
      const kids = childrenOf(dirId).slice().sort((a,b)=>{
        const aDir = isDir(a)||isCMDBDir(a);
        const bDir = isDir(b)||isCMDBDir(b);
        if(aDir!==bDir) return aDir ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
      kids.forEach((n, idx)=>{
        const last = idx === kids.length-1;
        const branch = last ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ";
        const nextPrefix = prefix + (last ? "    " : "‚îÇ   ");
        if(isDir(n) || isCMDBDir(n)){
          const suffix = isCMDBDir(n) ? "{cmdb}/" : "/";
          lines.push(`${escapeHtml(prefix + branch)}${renderClickableName(n)} <span class="muted">${escapeHtml(suffix)}</span>`);
          walk(n.id, nextPrefix, depth+1);
        } else if(isUrl(n)) {
          lines.push(`${escapeHtml(prefix + branch)}üîó ${renderClickableName(n)} <span class="muted">${escapeHtml("("+(n.url||"")+")")}</span>`);
        } else if(isApp(n)) {
          lines.push(`${escapeHtml(prefix + branch)}üß© ${renderClickableName(n)} <span class="muted">${escapeHtml("{app}:"+ (n.port||"-"))}</span>`);
        } else if(isConn(n)) {
          const stCls = connColorClass(n);
          lines.push(`${escapeHtml(prefix + branch)}üîå <span class="${stCls}">${escapeHtml(n.connStatus||"nao-testada")}</span> ${renderClickableName(n)}`);
        } 
        else if(isConnRef(n)){
          const target = nodeById(n.refConnId);
          if(!target || !isConn(target)){
            lines.push(
              `${escapeHtml(prefix + branch)}üîó ` +
              `<span class="clickable c-red" data-delref="${escapeHtml(n.id)}">ref quebrada (dblclick apaga)</span> ` +
              `<span class="muted">{connref}</span>`
            );
          } else {
            const label = shortConnLabel(target);
            lines.push(
              `${escapeHtml(prefix + branch)}üîó ` +
              `<span class="clickable" data-openconn="${escapeHtml(target.id)}">${escapeHtml(label)}</span> ` +
              `<span class="muted">{connref}</span>`
            );          }
        }
        else {
          lines.push(`${escapeHtml(prefix + branch)}${renderClickableName(n)}`);
        }
      });
    }
    walk(state.cwdId, "", 1);
    if(!lines.length) printLine("(vazio)", "muted");
    else lines.forEach(l=>printHTMLLine(l,"out"));
    attachDblClickHandlers();
  }

  function shortConnLabel(conn){
    const raw =
      conn?.title ||
      conn?.name ||
      conn?.label ||
      conn?.ref ||
      conn?.path ||
      conn?.url ||
      conn?.id ||
      "conn";
  
    const s = String(raw).trim();
    const noQ = s.split("?")[0].split("#")[0];
  
    // se parecer caminho/URL, pega o √∫ltimo segmento
    const parts = noQ.split("/").filter(Boolean);
    const last = parts.length ? parts[parts.length - 1] : noQ;
  
    return last.length > 28 ? (last.slice(0, 14) + "‚Ä¶" + last.slice(-10)) : last;
  }

  function cmd_cd(args){
    const target = args[0] || "/";
    const id = resolvePath(target);
    if(!id){ printLine(`cd: n√£o encontrado: ${target}`, "err"); return; }
    const n = nodeById(id);
    if(!(isDir(n) || isCMDBDir(n))){ printLine(`cd: n√£o √© pasta: ${target}`, "err"); return; }
    state.cwdId = id;
    saveState();
    updateCwd();
    renderSidebar();
  }

  function cmd_mkdir(args){
    if(!args[0]){ printLine("mkdir: faltou nome", "err"); return; }
    const pathStr = args[0];
    const { parentPath, name } = splitParentAndName(pathStr);
    const parentId = resolvePath(parentPath);
    if(!parentId){ printLine(`mkdir: caminho inv√°lido: ${parentPath}`, "err"); return; }
    const p = nodeById(parentId);
    if(!(isDir(p) || isCMDBDir(p))){ printLine(`mkdir: n√£o √© pasta: ${parentPath}`, "err"); return; }

    const r = createDir(name, parentId);
    if(!r.ok){ printLine("mkdir: " + r.err, "err"); return; }

    state.cwdId = r.node.id; // entra automaticamente
    saveState();
    updateCwd();
    renderSidebar();
    printLine(`Agora em: ${cwdPath()}`, "muted");
  }

  function cmd_rm(args){
    if(!args.length){ printLine("rm: uso: rm [-r] <caminho>", "err"); return; }
    const recursive = args.includes("-r") || args.includes("-rf") || args.includes("-fr");
    const pathArg = args.find(a=>!a.startsWith("-"));
    if(!pathArg){ printLine("rm: faltou caminho", "err"); return; }

    const id = resolvePath(pathArg);
    if(!id){ printLine(`rm: n√£o encontrado: ${pathArg}`, "err"); return; }

    const n = nodeById(id);
    if((isDir(n) || isCMDBDir(n)) && recursive){
      const r = removeTree(id);
      if(!r.ok) printLine("rm: " + r.err, "err");
      else printLine(`Removido (recursivo): ${r.count} n√≥s`, "ok");
    } else {
      const r = removeNode(id);
      if(!r.ok) printLine("rm: " + r.err, "err");
      else printLine("Removido.", "ok");
    }

    updateCwd();
    renderSidebar();
  }

  function cmd_mv(args){
    if(args.length < 2){ printLine("mv: uso: mv <origem> <destino>", "err"); return; }
    const srcId = resolvePath(args[0]);
    if(!srcId){ printLine(`mv: origem n√£o encontrada: ${args[0]}`, "err"); return; }

    const dstId = resolvePath(args[1]);
    if(dstId){
      const dst = nodeById(dstId);
      if(!(isDir(dst) || isCMDBDir(dst))){ printLine("mv: destino existe e n√£o √© pasta", "err"); return; }
      const src = nodeById(srcId);
      if((isDir(src) || isCMDBDir(src)) && isDescendantDir(dstId, srcId)){
        printLine("mv: n√£o pode mover pasta para dentro dela mesma.", "err");
        return;
      }
      const r = moveNode(srcId, dstId, null);
      if(!r.ok) printLine("mv: " + r.err, "err");
      updateCwd(); renderSidebar();
      return;
    }

    const { parentPath, name } = splitParentAndName(args[1]);
    const parentId = resolvePath(parentPath);
    if(!parentId){ printLine(`mv: destino inv√°lido: ${parentPath}`, "err"); return; }
    const p = nodeById(parentId);
    if(!(isDir(p) || isCMDBDir(p))){ printLine(`mv: destino n√£o √© pasta: ${parentPath}`, "err"); return; }

    const r = moveNode(srcId, parentId, name);
    if(!r.ok) printLine("mv: " + r.err, "err");
    updateCwd(); renderSidebar();
  }

  function parseMetaFromTokens(tokens, startIndex, mapping){
    // mapping: { "@tag": "fieldName" }
    const meta = {};
    let i = startIndex;
    while(i < tokens.length){
      const tk = tokens[i];
      if(tk && tk.startsWith("@")){
        const tag=tk;
        const val = (tokens[i+1] && !tokens[i+1].startsWith("@")) ? tokens[i+1] : "";
        if(mapping[tag]) meta[mapping[tag]] = val;
        i += val ? 2 : 1;
      } else {
        i++;
      }
    }
    return meta;
  }

  function parseAdd(raw){
    const tokens = tokenize(raw);
    let i=1;
    const nameParts=[];
    const meta={};
    while(i < tokens.length){
      const tk=tokens[i];
      if(tk.startsWith("@")){
        const tag=tk;
        const val = (tokens[i+1] && !tokens[i+1].startsWith("@")) ? tokens[i+1] : "";
        if(tag==="@resp") meta.resp=val;
        else if(tag==="@due") meta.due=val;
        else if(tag==="@status") meta.status=val;
        else if(tag==="@type") meta.type=val;
        else if(tag==="@prio") meta.prio=val;
        else if(tag==="@note") meta.note=val;
        i += val ? 2 : 1;
      } else {
        nameParts.push(tk);
        i++;
      }
    }
    return { name: nameParts.join(" ").trim(), meta };
  }

  function cmd_add(raw){
    const { name, meta } = parseAdd(raw);
    if(!name){
      printLine("add: uso: add <nome> @resp <pessoa> @due <YYYY-MM-DD> @status <...> @type <...> @prio <1-5> @note <...>", "muted");
      return;
    }
    if(meta.due && !/^\d{4}-\d{2}-\d{2}$/.test(meta.due)){
      printLine("add: @due deve ser YYYY-MM-DD", "err"); return;
    }
    if(meta.prio && !(Number(meta.prio)>=1 && Number(meta.prio)<=5)){
      printLine("add: @prio deve ser 1..5", "err"); return;
    }
    const r = createTaskFile(name, state.cwdId, meta);
    if(!r.ok) printLine("add: " + r.err, "err");
    else printLine(`Criado: ${name}`, "ok");
    renderSidebar();
  }

  function cmd_url(raw){
    const tokens = tokenize(raw);
    const name = tokens[1] || "";
    const link = tokens[2] || "";
    if(!name || !link){
      printLine('url: uso: url "Nome" https://site.com', "muted");
      return;
    }
    const meta = parseMetaFromTokens(tokens, 3, {
      "@resp":"resp","@due":"due","@status":"status","@type":"type","@prio":"prio","@note":"note"
    });
    if(meta.due && !/^\d{4}-\d{2}-\d{2}$/.test(meta.due)){
      printLine("url: @due deve ser YYYY-MM-DD", "err"); return;
    }
    if(meta.prio && !(Number(meta.prio)>=1 && Number(meta.prio)<=5)){
      printLine("url: @prio deve ser 1..5", "err"); return;
    }
    const r = createUrl(name, link, state.cwdId, meta);
    if(!r.ok) printLine("url: " + r.err, "err");
    else printLine(`Criado favorito: ${name}`, "ok");
    renderSidebar();
  }

  function cmd_mkcmdb(raw){
    const tokens = tokenize(raw);
    const name = tokens[1] || "";
    if(!name){
      printLine("mkcmdb: uso: mkcmdb <nome> @hostname X @ip 10.0.0.1 @dc DC1 @env prod", "muted");
      return;
    }
    const meta = parseMetaFromTokens(tokens, 2, {
      "@hostname":"hostname","@ip":"ip","@dc":"dc","@env":"env"
    });
    const r = createCMDBDir(name, state.cwdId, meta);
    if(!r.ok){ printLine("mkcmdb: " + r.err, "err"); return; }

    // entra automaticamente
    state.cwdId = r.node.id;
    saveState();
    updateCwd();
    renderSidebar();
    printLine(`CMDB criado e entrou: ${cwdPath()}`, "ok");
  }

  function cmd_app(raw){
    const tokens = tokenize(raw);
    const name = tokens[1] || "";
    if(!name){
      printLine('app: uso: app "NomeApp" @port 8080', "muted");
      return;
    }
    const meta = parseMetaFromTokens(tokens, 2, { "@port":"port" });
    const r = createApp(name, state.cwdId, meta);
    if(!r.ok) printLine("app: " + r.err, "err");
    else printLine(`Application criado: ${name}`, "ok");
    renderSidebar();
  }

  function cmd_conn(raw){
    const tokens = tokenize(raw);
    const meta = parseMetaFromTokens(tokens, 1, { "@from":"from","@to":"to","@port":"port","@status":"status" });
    const r = createConn(state.cwdId, meta);
    if(!r.ok) printLine("conn: " + r.err, "err");
    else printLine(`Conectividade criada: ${r.node.name}`, "ok");
    renderSidebar();
  }

  function cmd_at_resp(){
    const items = itemsInScope(state.cwdId).filter(n => isTask(n) || isUrl(n));
    const resps = Array.from(new Set(items.map(t => (t.resp||"").trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    printLine("Respons√°veis (tarefas/urls, escopo atual, recursivo):", "out");
    if(!resps.length){ printLine("(nenhum)", "muted"); return; }
    resps.forEach(r=>printLine("  - " + r, "out"));
  }

  function fmtTaskLine(t){
    const due = t.due || "-";
    const resp = t.resp || "-";
    const st = t.status || "todo";
    const pr = t.prio || 3;
    const type = (t.taskType||"-");
    const base = `[p${pr}] [${st}] [${due}] [${resp}] [type:${type}] `;
    return `${escapeHtml(base)}${renderClickableName(t)} <span class="muted">${escapeHtml("(" + fullPathOf(t.id) + ")")}</span>`;
  }

  function cmd_q(args){
    const mode = args[0] || "";
    const items = itemsInScope(state.cwdId);
    const today = todayISODate();

    const tasks = items.filter(isTask);

    if(mode==="hoje"){
      const t = tasks.filter(x=>x.due===today && x.status!=="done").sort(sortByImportance);
      printLine("Atividades de hoje (recursivo):", "out");
      if(!t.length){ printLine("(nenhuma)", "muted"); return; }
      t.forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      attachDblClickHandlers();
      return;
    }

    if(mode==="atrasadas"){
      const t = tasks.filter(x=>x.due && x.due < today && x.status!=="done").sort(sortByImportance);
      const g = groupBy(t, x=> fullPathOf(x.parentId));
      const keys = Array.from(g.keys()).sort((a,b)=>a.localeCompare(b));
      printLine("Atrasadas por projeto (recursivo):", "out");
      if(!keys.length){ printLine("(nenhuma)", "muted"); return; }
      for(const k of keys){
        printLine("‚Ä¢ " + k, "warn");
        g.get(k).slice().sort(sortByImportance).forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      }
      attachDblClickHandlers();
      return;
    }

    if(mode==="por-pessoa"){
      const t = tasks.filter(x=>(x.resp||"").trim()).sort(sortByImportance);
      const g = groupBy(t, x=>x.resp.trim());
      const people = Array.from(g.keys()).sort((a,b)=>a.localeCompare(b));
      printLine("Atividades por pessoa (recursivo):", "out");
      if(!people.length){ printLine("(nenhuma)", "muted"); return; }
      for(const p of people){
        printLine("‚Ä¢ " + p, "out");
        g.get(p).slice().sort(sortByImportance).forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      }
      attachDblClickHandlers();
      return;
    }

    if(mode==="sem-data"){
      const t = tasks.filter(x=>!x.due).sort(sortByImportance);
      printLine("Sem data (recursivo):", "out");
      if(!t.length){ printLine("(nenhuma)", "muted"); return; }
      t.forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      attachDblClickHandlers();
      return;
    }

    if(mode==="sem-resp"){
      const t = tasks.filter(x=>!(x.resp||"").trim()).sort(sortByImportance);
      printLine("Sem respons√°vel (recursivo):", "out");
      if(!t.length){ printLine("(nenhuma)", "muted"); return; }
      t.forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      attachDblClickHandlers();
      return;
    }

    if(mode==="sem-att"){
      const t = tasks.filter(x=>x.status!=="done").slice().sort((a,b)=>{
        const ta = Date.parse(a.updatedAt||a.createdAt||nowISO());
        const tb = Date.parse(b.updatedAt||b.createdAt||nowISO());
        return ta - tb;
      }).slice(0,30);
      printLine("Mais antigas sem atualiza√ß√£o (top 30, recursivo):", "out");
      if(!t.length){ printLine("(nenhuma)", "muted"); return; }
      t.forEach(x=>printHTMLLine("  " + fmtTaskLine(x) + ` <span class="muted">(upd ${escapeHtml(isoToDateOnly(x.updatedAt))})</span>`, "out"));
      attachDblClickHandlers();
      return;
    }

    if(mode==="por-projeto"){
      const t = tasks.slice().sort(sortByImportance);
      const g = groupBy(t, x=> fullPathOf(x.parentId));
      const keys = Array.from(g.keys()).sort((a,b)=>a.localeCompare(b));
      printLine("Atividades por projeto (recursivo):", "out");
      if(!keys.length){ printLine("(nenhuma)", "muted"); return; }
      for(const k of keys){
        printLine("‚Ä¢ " + k, "out");
        g.get(k).slice().sort(sortByImportance).forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      }
      attachDblClickHandlers();
      return;
    }

    if(mode==="sem-tipo"){
      const t = tasks.filter(x=>!(x.taskType||"").trim()).sort(sortByImportance);
      printLine("Sem tipo (recursivo):", "out");
      if(!t.length){ printLine("(nenhuma)", "muted"); return; }
      t.forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      attachDblClickHandlers();
      return;
    }

    if(mode==="por-tipo"){
      const t = tasks.slice().sort(sortByImportance);
      const g = groupBy(t, x=> (x.taskType||"").trim() || "(sem tipo)");
      const keys = Array.from(g.keys()).sort((a,b)=>a.localeCompare(b));
      printLine("Atividades por tipo (recursivo):", "out");
      if(!keys.length){ printLine("(nenhuma)", "muted"); return; }
      for(const k of keys){
        printLine("‚Ä¢ " + k, "out");
        g.get(k).slice().sort(sortByImportance).forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      }
      attachDblClickHandlers();
      return;
    }

    if(mode==="tipo"){
      const wanted = (args.slice(1).join(" ")||"").trim().toLowerCase();
      if(!wanted){
        printLine("q tipo: uso: q tipo <nome-do-tipo>", "muted");
        return;
      }
      const t = tasks.filter(x => ((x.taskType||"").trim().toLowerCase() === wanted)).sort(sortByImportance);
      printLine(`Atividades do tipo "${wanted}" (recursivo):`, "out");
      if(!t.length){ printLine("(nenhuma)", "muted"); return; }
      t.forEach(x=>printHTMLLine("  " + fmtTaskLine(x), "out"));
      attachDblClickHandlers();
      return;
    }

    printLine("q: modos: hoje | atrasadas | por-pessoa | sem-data | sem-resp | sem-att | por-projeto | sem-tipo | por-tipo | tipo <X>", "muted");
  }

  function cmd_resumo(){
    printLine("Resumo (tarefas, escopo atual, recursivo):", "out");
    const sections = [
      { title: "Hoje", run: () => cmd_q(["hoje"]) },
      { title: "Atrasadas (por projeto)", run: () => cmd_q(["atrasadas"]) },
      { title: "Por pessoa", run: () => cmd_q(["por-pessoa"]) },
      { title: "Sem data", run: () => cmd_q(["sem-data"]) },
      { title: "Sem respons√°vel", run: () => cmd_q(["sem-resp"]) },
      { title: "Mais antigas sem atualiza√ß√£o", run: () => cmd_q(["sem-att"]) },
      { title: "Por projeto", run: () => cmd_q(["por-projeto"]) },
      { title: "Sem tipo", run: () => cmd_q(["sem-tipo"]) },
      { title: "Por tipo", run: () => cmd_q(["por-tipo"]) },
    ];
    for(const s of sections){
      printLine("", "out");
      printLine("==== " + s.title + " ====", "muted");
      s.run();
    }
  }

  function cmd_aliases(){
    printLine("Aliases:", "out");
    Object.entries(settings.aliases).sort((a,b)=>a[0].localeCompare(b[0]))
      .forEach(([k,v])=>printLine(`  ${k} ‚Üí ${v}`, "muted"));
  }

  // --------- CMDB Views ----------
function cmdbSummary(){
  const cmdbs = state.nodes.filter(isCMDBDir).slice().sort((a,b)=>a.name.localeCompare(b.name));
  const apps = state.nodes.filter(isApp);
  const conns = state.nodes.filter(isConn);

  printLine("CMDB ‚Äî Vis√£o hier√°rquica:", "out");
  printLine(`  CMDBs: ${cmdbs.length} | Apps: ${apps.length} | Conectividades: ${conns.length}`, "muted");

  if(!cmdbs.length){
    printLine("  (nenhum cmdb ainda ‚Äî use: mkcmdb srv01 @hostname ...)", "muted");
    return;
  }

  // Deriva Namespace pela √°rvore (pastas acima da inst√¢ncia), se o node n√£o tiver c.namespace.
  function deriveNamespace(cmdbNode){
    if(cmdbNode && cmdbNode.namespace) return String(cmdbNode.namespace);

    // tenta montar algo a partir da hierarquia de pastas (parentId ‚Üí parentId‚Ä¶)
    const names = [];
    let cur = cmdbNode;
    let guard = 0;

    while(cur && cur.parentId && guard++ < 50){
      const p = nodeById(cur.parentId);
      if(!p) break;

      // Evita poluir com itens que n√£o sejam pasta/diret√≥rio
      // (se seu modelo usa type "dir", ok; se n√£o, ainda funciona)
      if(p.name && p.name !== "/" && p.name.toLowerCase() !== "root"){
        names.push(p.name);
      }
      cur = p;
    }

    names.reverse();

    // Heur√≠stica: muitas vezes o ‚Äúnamespace‚Äù √© a pasta imediatamente acima da inst√¢ncia.
    // Se houver v√°rias pastas acima, junta com "/".
    if(!names.length) return "default";
    return names.join(" / ");
  }

  // Agrupa: dc -> env -> ns -> [cmdb...]
  const bucket = new Map();

  function getOrCreate(map, key){
    if(!map.has(key)) map.set(key, new Map());
    return map.get(key);
  }

  for(const c of cmdbs){
    const dc  = (c.datacenter || c.dc || "-").toString().trim() || "-";
    const env = (c.ambiente  || c.env || "-").toString().trim() || "-";
    const ns  = deriveNamespace(c);

    const envMap = getOrCreate(bucket, dc);
    const nsMap  = getOrCreate(envMap, env);
    if(!nsMap.has(ns)) nsMap.set(ns, []);
    nsMap.get(ns).push(c);
  }

  // Ordena√ß√£o ‚Äúbonita‚Äù
  const sortKeys = (m) => Array.from(m.keys()).sort((a,b)=>String(a).localeCompare(String(b)));

  for(const dc of sortKeys(bucket)){
    printHTMLLine(`üè¢ <b>${escapeHtml(dc)}</b>`, "out");
    const envMap = bucket.get(dc);

    for(const env of sortKeys(envMap)){
      printHTMLLine(`&nbsp;&nbsp;üåø <b>${escapeHtml(env)}</b>`, "out");
      const nsMap = envMap.get(env);

      for(const ns of sortKeys(nsMap)){
        printHTMLLine(`&nbsp;&nbsp;&nbsp;&nbsp;üß≠ <b>${escapeHtml(ns)}</b>`, "out");

        const instances = nsMap.get(ns).slice().sort((a,b)=>a.name.localeCompare(b.name));

        for(const c of instances){
          const meta = `host=${c.hostname||"-"} ip=${c.ip||"-"}`;
          printHTMLLine(
            `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üß± <b>${renderClickableName(c)}</b> <span class="muted">${escapeHtml(meta)}</span>`,
            "out"
          );

          // Apps dentro da inst√¢ncia
          const appsIn = apps.filter(a => a.cmdbId === c.id).slice().sort((a,b)=>a.name.localeCompare(b.name));
          if(appsIn.length){
            appsIn.forEach(a=>{
              printHTMLLine(
                `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üß© ${renderClickableName(a)} <span class="muted">${escapeHtml("port="+a.port)}</span>`,
                "out"
              );
            });
          } else {
            printHTMLLine(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="muted">- (sem apps)</span>`, "out");
          }

          // Conectividades relacionadas (origem/destino ou cmdbId direto)
          const connsRelated = conns.filter(n => {
            const fa = nodeById(n.fromAppId);
            const ta = nodeById(n.toAppId);
            return (fa && fa.cmdbId===c.id) || (ta && ta.cmdbId===c.id) || (n.cmdbId===c.id);
          });

          if(connsRelated.length){
            connsRelated
              .slice()
              .sort((x,y)=>x.name.localeCompare(y.name))
              .forEach(n=>{
                const fa = nodeById(n.fromAppId);
                const ta = nodeById(n.toAppId);
                const stCls = connColorClass(n);

                // Porta exibida: a do DESTINO (como voc√™ definiu)
                const port = (n.port ?? (ta && ta.port) ?? "-");

                printHTMLLine(
                  `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üîå <span class="${stCls}">${escapeHtml(n.connStatus||"nao-testada")}</span> <span class="muted">${escapeHtml((fa?fa.name:"-")+" ‚Üí "+(ta?ta.name:"-")+":"+port)}</span>`,
                  "out"
                );
              });
          } else {
            printHTMLLine(`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="muted">- (sem conectividades)</span>`, "out");
          }
        }
      }
    }
  }

  attachDblClickHandlers();
}

  function cmdbRelations(){
    const cmdbs = state.nodes.filter(isCMDBDir).slice().sort((a,b)=>a.name.localeCompare(b.name));
    const conns = state.nodes.filter(isConn);

    printLine("CMDB ‚Äî Rela√ß√µes (grafo):", "out");
    if(!cmdbs.length){
      printLine("(nenhum cmdb)", "muted");
      return;
    }
    if(!conns.length){
      printLine("(nenhuma conectividade)", "muted");
      return;
    }

    // agrupa por cmdb (pelo cmdbId do conn)
    const g = groupBy(conns, c => c.cmdbId || "(sem-cmdb)");
    const keys = Array.from(g.keys()).sort((a,b)=>String(a).localeCompare(String(b)));

    for(const k of keys){
      const cm = nodeById(k);
      printLine("‚Ä¢ " + (cm ? cm.name : k), "out");
      g.get(k).forEach(c=>{
        const fa = nodeById(c.fromAppId);
        const ta = nodeById(c.toAppId);
        const stCls = connColorClass(c);
        const fromCm = fa ? nodeById(fa.cmdbId) : null;
        const toCm = ta ? nodeById(ta.cmdbId) : null;
        const fromLabel = `${fromCm?fromCm.name:"-"}:${fa?fa.name:"-"}`;
        const toLabel   = `${toCm?toCm.name:"-"}:${ta?ta.name:"-"}`;

        printHTMLLine(`   - üîå <span class="${stCls}">${escapeHtml(c.connStatus||"nao-testada")}</span> <span class="muted">${escapeHtml(fromLabel)} ‚Üí ${escapeHtml(toLabel)}:${escapeHtml(String(c.port||"-"))}</span>`, "out");
      });
    }
    attachDblClickHandlers();
  }

  function cmd_cmdb(args){
    const sub = (args[0]||"").toLowerCase();
  
    if(sub === "rel") return cmdbRelations();
  
    if(sub === "graph"){
      const mode = (args[1]||"").toLowerCase();
      if(mode === "bloqueada") return openGraph("bloqueada");
      if(mode === "testada") return openGraph("testada");
      if(mode === "nao-testada") return openGraph("nao-testada");
      return openGraph("hover");
    }
  
    if(sub === "find"){
      const q = (args.slice(1).join(" ")||"").trim();
      return cmdbFind(q);
    }
  
    return cmdbSummary();
  }

  function openGraph(mode="hover"){
    const overlay = document.getElementById("graphOverlay");
    const svg = document.getElementById("graphSvg");
    const close = document.getElementById("graphClose");
  
    overlay.style.display = "flex";
  
    close.onclick = () => overlay.style.display = "none";
    overlay.onclick = (e) => { if(e.target === overlay) overlay.style.display = "none"; };
  
    renderGraph(svg, mode);
  }
  
  function svgEl(tag, attrs={}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for(const [k,v] of Object.entries(attrs)) el.setAttribute(k, v);
    return el;
  }

  /* =========================================================
   FLOW VIEW ‚Äî SVG INFINITO + ANIMA√á√ÉO SEQUENCIAL (HIER√ÅRQUICO)
   Datacenter ‚Üí Ambiente ‚Üí Inst√¢ncia ‚Üí App
   ========================================================= */

/* ---------- Modal SVG ---------- */
  /* ================= FLOW MODAL (SVG) + PAN (ARRASTAR) + ZOOM (WHEEL) ================= */
  (function(){
    if(document.getElementById("flowOverlay")) return;
  
    const overlay = document.createElement("div");
    overlay.id = "flowOverlay";
    overlay.style.cssText = `
      position:fixed; inset:0; z-index:99999;
      background:rgba(0,0,0,.65);
      display:none;
    `;
  
    overlay.innerHTML = `
      <div style="
        position:absolute; inset:20px;
        background:#0b0f19;
        border-radius:16px;
        display:flex; flex-direction:column;
        overflow:hidden;
      ">
        <div style="
          padding:12px 16px;
          border-bottom:1px solid rgba(255,255,255,.1);
          display:flex; justify-content:space-between; align-items:center;
        ">
          <strong>Flow ‚Äî Anima√ß√£o de Opera√ß√£o</strong>
          <button id="flowClose" class="ghost">Fechar</button>
        </div>
  
        <!-- viewport: SEM scrollbars; navega√ß√£o via arrasto + zoom -->
        <div id="flowViewport" style="
          flex:1;
          overflow:hidden;
          position:relative;
          cursor:grab;
          overscroll-behavior:contain;
          touch-action:none;
        ">
          <svg id="flowSvg" width="8000" height="1400" style="display:block;"></svg>
        </div>
      </div>
    `;
  
    document.body.appendChild(overlay);
  
    const svg = document.getElementById("flowSvg");
    const viewport = document.getElementById("flowViewport");
  
    // ---------- Pan/Zoom state (via viewBox) ----------
    const st = {
      vbX: 0, vbY: 0,
      vbW: Number(svg.getAttribute("width"))  || 8000,
      vbH: Number(svg.getAttribute("height")) || 1400,
      minZoom: 0.20,  // 20%
      maxZoom: 4.00,  // 400%
      dragging: false,
      dragStart: null, // {x,y,vbX,vbY}
    };
  
    function applyViewBox(){
      svg.setAttribute("viewBox", `${st.vbX} ${st.vbY} ${st.vbW} ${st.vbH}`);
    }
  
    // converte coordenada de mouse para espa√ßo do viewBox atual
    function clientToVb(clientX, clientY){
      const r = svg.getBoundingClientRect();
      const sx = (clientX - r.left) / (r.width  || 1);
      const sy = (clientY - r.top ) / (r.height || 1);
      return { x: st.vbX + sx * st.vbW, y: st.vbY + sy * st.vbH };
    }
  
    // init viewBox
    applyViewBox();
  
    // ---------- PAN (arrastar) ----------
    viewport.addEventListener("pointerdown", (e)=>{
      // arrasta com bot√£o esquerdo / toque
      if(e.button !== undefined && e.button !== 0) return;
  
      st.dragging = true;
      viewport.style.cursor = "grabbing";
  
      const p = clientToVb(e.clientX, e.clientY);
      st.dragStart = { x: p.x, y: p.y, vbX: st.vbX, vbY: st.vbY };
  
      viewport.setPointerCapture?.(e.pointerId);
      e.preventDefault();
    });
  
    viewport.addEventListener("pointermove", (e)=>{
      if(!st.dragging || !st.dragStart) return;
  
      const p = clientToVb(e.clientX, e.clientY);
      const dx = p.x - st.dragStart.x;
      const dy = p.y - st.dragStart.y;
  
      st.vbX = st.dragStart.vbX - dx;
      st.vbY = st.dragStart.vbY - dy;
  
      applyViewBox();
      e.preventDefault();
    });
  
    function endDrag(){
      st.dragging = false;
      st.dragStart = null;
      viewport.style.cursor = "grab";
    }
    viewport.addEventListener("pointerup", endDrag);
    viewport.addEventListener("pointercancel", endDrag);
    viewport.addEventListener("pointerleave", endDrag);
  
    // ---------- ZOOM (wheel) ----------
    viewport.addEventListener("wheel", (e)=>{
      e.preventDefault();
  
      // zoom com wheel: para cima aproxima, para baixo afasta
      const zoomFactor = (e.deltaY < 0) ? 0.90 : 1.10;
  
      // zoom atual baseado em vbW vs base width
      const baseW = Number(svg.getAttribute("width")) || 8000;
      const currentZoom = baseW / st.vbW;
      let nextZoom = currentZoom / zoomFactor;
  
      // clamp zoom
      nextZoom = Math.max(st.minZoom, Math.min(st.maxZoom, nextZoom));
  
      // calcula novo vbW/vbH
      const newVbW = baseW / nextZoom;
      const baseH = Number(svg.getAttribute("height")) || 1400;
      const newVbH = baseH / nextZoom;
  
      // mant√©m o ponto do mouse ‚Äúfixo‚Äù durante o zoom
      const before = clientToVb(e.clientX, e.clientY);
  
      // atualiza tamanho
      st.vbW = newVbW;
      st.vbH = newVbH;
  
      // reposiciona viewBox para manter o mesmo ponto
      const after = clientToVb(e.clientX, e.clientY);
      st.vbX += (before.x - after.x);
      st.vbY += (before.y - after.y);
  
      applyViewBox();
    }, { passive:false });
  
    // ---------- Close ----------
    document.getElementById("flowClose").onclick = ()=>{
      overlay.style.display = "none";
      svg.innerHTML = "";
      // reset viewBox ao fechar (opcional)
      st.vbX = 0; st.vbY = 0;
      st.vbW = Number(svg.getAttribute("width"))  || 8000;
      st.vbH = Number(svg.getAttribute("height")) || 1400;
      applyViewBox();
    };
  
    // exp√µe um helper opcional para voc√™ chamar ap√≥s render
    window.__flowPanZoomReset = function(){
      st.vbX = 0; st.vbY = 0;
      st.vbW = Number(svg.getAttribute("width"))  || 8000;
      st.vbH = Number(svg.getAttribute("height")) || 1400;
      applyViewBox();
    };
  })();

/* ---------- helpers ---------- */

function ensureNegocioDir(){
  let dir = state.nodes.find(n =>
    isDir(n) &&
    n.name === "negocio" &&
    n.parentId === "root"
  );

  if(!dir){
    dir = {
      id: rid(),
      type: "dir",
      name: "negocio",
      parentId: "root",
      createdAt: nowISO(),
      updatedAt: nowISO()
    };
    state.nodes.push(dir);
  }

  return dir;
}

function getNegocioDir(){
  return state.nodes.find(n => n.type==="negocio" && n.parentId==="root");
}

function flowConnStyle(fromApp, toApp){
  const conn = state.nodes.find(n =>
    isConn(n) &&
    n.fromAppId === fromApp.id &&
    n.toAppId === toApp.id
  );

  if(!conn){
    return { color:"#ffffff", dash:"6 6", width:2 };
  }

  const st = conn.connStatus || "nao-testada";
  if(st === "bloqueada") return { color:"#ff6b6b", dash:"6 6", width:3 };
  if(st === "testada")   return { color:"#65a8ff", dash:"", width:3 };
  return { color:"#ffd36b", dash:"", width:2.5 };
}

/* ================= FLOW RENDER (MERGE DC/ENV/INST) ================= */
function openFlowModal(apps){
  const overlay = document.getElementById("flowOverlay");
  const svg = document.getElementById("flowSvg");
  overlay.style.display = "flex";
  svg.innerHTML = "";

  // ---------- layout ----------
  const startX = 120;
  const gap    = 300;

  // n√≠veis (Y)
  const yDC   = 120;
  const hDC   = 180;

  const yENV  = yDC + 26;
  const hENV  = 140;

  const yINST = yENV + 26;
  const hINST = 92;

  const yAPP  = yINST + 26;
  const wAPP  = 164;
  const hAPP  = 28;

  // largura de coluna (precisa caber o wAPP + paddings)
  const colW  = 220;

  // ---------- helpers SVG ----------
  const NS = "http://www.w3.org/2000/svg";
  const el = (tag)=> document.createElementNS(NS, tag);

  const drawBox = (x,y,w,h,rx,fill,stroke, sw="1.2")=>{
    const r = el("rect");
    r.setAttribute("x",x); r.setAttribute("y",y);
    r.setAttribute("width",w); r.setAttribute("height",h);
    r.setAttribute("rx",rx);
    r.setAttribute("fill",fill);
    r.setAttribute("stroke",stroke);
    r.setAttribute("stroke-width", sw);
    return r;
  };

  const drawText = (x,y,txt,size=12,muted=false, weight="400")=>{
    const t = el("text");
    t.setAttribute("x",x);
    t.setAttribute("y",y);
    t.setAttribute("fill", muted ? "#9db0d1" : "#fff");
    t.setAttribute("font-size", String(size));
    t.setAttribute("font-weight", weight);
    t.textContent = txt;
    return t;
  };

  const animateLine = (x1,y1,x2,y2, style, delayMs)=>{
    // desenha horizontal e anima com dash
    const line = el("line");
    line.setAttribute("x1", x1);
    line.setAttribute("y1", y1);
    line.setAttribute("x2", x2);
    line.setAttribute("y2", y2);
    line.setAttribute("stroke", style.color);
    line.setAttribute("stroke-width", style.width || 3);
    line.setAttribute("stroke-linecap", "round");
    if(style.dash) line.setAttribute("stroke-dasharray", style.dash);

    // anima√ß√£o "esticando"
    const len = Math.max(1, Math.abs(x2 - x1));
    line.style.strokeDasharray  = String(len);
    line.style.strokeDashoffset = String(len);

    svg.appendChild(line);

    setTimeout(()=>{
      line.getBoundingClientRect(); // for√ßa layout
      line.style.transition = "stroke-dashoffset 520ms ease-out";
      line.style.strokeDashoffset = "0";
    }, delayMs);

    return line;
  };

  // ---------- 1) preparar steps ----------
  const steps = apps.map((app, idx)=>{
    const cmdb = nodeById(app.cmdbId) || {};
    const dc   = (cmdb.datacenter || "dc?").trim();
    const env  = (cmdb.ambiente   || "env?").trim();
    const inst = (cmdb.name       || "inst?").trim();

    const x = startX + idx * gap;
    const appX = x + 28;           // app box dentro da coluna
    const appY = yAPP;
    const appCenterY = appY + (hAPP/2);
    const appInX  = appX;          // ‚Äúentrada‚Äù da app
    const appOutX = appX + wAPP;   // ‚Äúsa√≠da‚Äù da app

    return { app, cmdb, dc, env, inst, x, colLeft:x, colRight:x+colW, appX, appY, appInX, appOutX, appCenterY };
  });

  // dimensiona o canvas pra caber tudo
  const totalW = startX + (Math.max(1, steps.length-1) * gap) + colW + 200;
  const totalH = yDC + hDC + 220;
  svg.setAttribute("width",  String(Math.max(2200, totalW)));
  svg.setAttribute("height", String(Math.max(900,  totalH)));

  // ---------- 2) agrupar com merge hier√°rquico ----------
  // DC: agrupa por dc (cont√≠guo)
  const dcGroups = [];
  for(let i=0;i<steps.length;i++){
    const s = steps[i];
    const last = dcGroups[dcGroups.length-1];
    if(!last || last.dc !== s.dc){
      dcGroups.push({ dc:s.dc, i0:i, i1:i });
    } else {
      last.i1 = i;
    }
  }

  // ENV: dentro de cada DC
  const envGroups = [];
  for(const dg of dcGroups){
    let cur = null;
    for(let i=dg.i0;i<=dg.i1;i++){
      const s = steps[i];
      if(!cur || cur.env !== s.env){
        cur = { dc:dg.dc, env:s.env, i0:i, i1:i };
        envGroups.push(cur);
      } else {
        cur.i1 = i;
      }
    }
  }

  // INST: dentro de cada ENV
  const instGroups = [];
  for(const eg of envGroups){
    let cur = null;
    for(let i=eg.i0;i<=eg.i1;i++){
      const s = steps[i];
      if(!cur || cur.inst !== s.inst){
        cur = { dc:eg.dc, env:eg.env, inst:s.inst, i0:i, i1:i };
        instGroups.push(cur);
      } else {
        cur.i1 = i;
      }
    }
  }

  // helpers span
  const spanX = (i0, i1)=>{
    const left  = steps[i0].colLeft;
    const right = steps[i1].colRight;
    return { x:left, w:(right-left) };
  };

  // ---------- 3) desenhar caixas MERGEADAS (DC / ENV / INST) ----------
  // DC
  dcGroups.forEach(g=>{
    const {x,w} = spanX(g.i0, g.i1);

    svg.appendChild(drawBox(
      x, yDC, w, hDC, 16,
      "rgba(255,255,255,.04)",
      "rgba(122,162,255,.25)",
      "1.2"
    ));
    svg.appendChild(drawText(x+12, yDC+20, "DC: " + g.dc, 12, true, "600"));
  });

  // ENV
  envGroups.forEach(g=>{
    const {x,w} = spanX(g.i0, g.i1);

    svg.appendChild(drawBox(
      x+12, yENV, w-24, hENV, 14,
      "rgba(255,255,255,.05)",
      "rgba(255,255,255,.12)",
      "1.1"
    ));
    svg.appendChild(drawText(x+20, yENV+18, "ENV: " + g.env, 12, true, "600"));
  });

  // INST
  instGroups.forEach(g=>{
    const {x,w} = spanX(g.i0, g.i1);

    svg.appendChild(drawBox(
      x+20, yINST, w-40, hINST, 12,
      "rgba(255,255,255,.06)",
      "rgba(255,255,255,.18)",
      "1.1"
    ));
    svg.appendChild(drawText(x+28, yINST+18, "INST: " + g.inst, 12, true, "600"));
  });

  // ---------- 4) desenhar APPS (sequencial) + linhas com status ----------
  let prev = null;

  steps.forEach((s, idx)=>{
    const delay = idx * 650;

    setTimeout(()=>{
      // linha do passo anterior -> atual
      if(prev){
        const style = flowConnStyle(prev.app, s.app); // << usa sua fun√ß√£o existente

        // linha reta horizontal no centro do APP
        const x1 = prev.appOutX + 10;
        const x2 = s.appInX  - 10;
        const y  = s.appCenterY;

        // se n√£o houver conectividade, seu flowConnStyle deve devolver branco pontilhado
        animateLine(x1, y, x2, y, style, 0);
      }

      // APP box
      const g = el("g");

      const r = drawBox(
        s.appX, s.appY, wAPP, hAPP, 10,
        "rgba(255,255,255,.12)",
        "rgba(122,162,255,.9)",
        "1.3"
      );

      const t = drawText(s.appX + (wAPP/2), s.appY + 19, s.app.name, 13, false, "600");
      t.setAttribute("text-anchor","middle");

      g.appendChild(r);
      g.appendChild(t);
      svg.appendChild(g);

      prev = s;
    }, delay);
  });
}

/* ================= VALIDATE (flows) ================= */

// helpers locais (n√£o conflitam com os seus)
function childrenOf(parentId){
  return state.nodes.filter(n => n.parentId === parentId);
}

function collectFlowsRecursive(startDirId){
  const out = [];
  const stack = [startDirId];

  while(stack.length){
    const cur = stack.pop();
    const kids = childrenOf(cur);

    for(const k of kids){
      if(isDir(k) || isCMDBDir(k)){
        stack.push(k.id);
      } else if(isFlow(k)){
        out.push(k);
      }
    }
  }
  return out;
}

// acha conex√µes entre duas apps (se existir mais de uma, usamos o "pior" status)
function connStatusBetween(fromAppId, toAppId){
  const list = state.nodes.filter(n =>
    isConn(n) &&
    n.fromAppId === fromAppId &&
    n.toAppId === toAppId
  );

  if(!list.length) return "missing";

  // pior caso: bloqueada > nao-testada > testada
  let hasBlocked = false;
  let hasNaoTestada = false;

  for(const c of list){
    const st = (c.connStatus || "nao-testada");
    if(st === "bloqueada") hasBlocked = true;
    else if(st === "nao-testada") hasNaoTestada = true;
  }

  if(hasBlocked) return "bloqueada";
  if(hasNaoTestada) return "nao-testada";
  return "testada";
}

function flowOverallStatus(hopStatuses){
  // vermelho se qualquer bloqueada
  if(hopStatuses.includes("bloqueada")) return "blocked";
  // amarelo se qualquer nao-testada OU missing
  if(hopStatuses.includes("nao-testada") || hopStatuses.includes("missing")) return "warning";
  // verde se tudo testada
  return "ok";
}

function flowStatusBadge(status){
  // usa suas vars CSS (se existirem) com fallback
  const ok = "var(--ok, #55e6a5)";
  const warn = "var(--warn, #ffd36b)";
  const bad = "var(--danger, #ff6b6b)";
  const muted = "var(--muted, #9db0d1)";

  if(status === "ok")      return `<span style="color:${ok};font-weight:800">‚óè OK</span>`;
  if(status === "warning") return `<span style="color:${warn};font-weight:800">‚óè ATEN√á√ÉO</span>`;
  if(status === "blocked") return `<span style="color:${bad};font-weight:800">‚óè BLOQUEADO</span>`;
  return `<span style="color:${muted};font-weight:800">‚óè ?</span>`;
}

function cmd_validate(args){
  // come√ßa na pasta atual
  const startId = state.cwdId || "root";

  const flows = collectFlowsRecursive(startId)
    .slice()
    .sort((a,b)=> (a.name||"").localeCompare(b.name||""));

  if(!flows.length){
    printLine("validate: nenhum arquivo flow abaixo da pasta atual.", "muted");
    return;
  }

  printLine("VALIDATE ‚Äî Flows abaixo da pasta atual:", "out");
  printLine(`  Encontrados: ${flows.length}`, "muted");

  let okCount=0, warnCount=0, blockedCount=0;

  for(const f of flows){
    const ids = Array.isArray(f.apps) ? f.apps.slice() : [];
    const hops = [];
    const hopDetails = [];

    // flow com 0/1 app n√£o tem conectividade para validar
    if(ids.length < 2){
      f.status = "warning";
      f.updatedAt = nowISO();
      warnCount++;

      const p = fullPathOf(f.id);
      printHTMLLine(`${flowStatusBadge("warning")} <b>${escapeHtml(p)}</b> <span class="muted">‚Äî flow com poucas apps</span>`, "out");
      continue;
    }

    // avalia cada salto (A -> B)
    for(let i=0;i<ids.length-1;i++){
      const aId = ids[i];
      const bId = ids[i+1];
      const a = nodeById(aId);
      const b = nodeById(bId);

      const st = connStatusBetween(aId, bId);
      hops.push(st);

      const aName = a?.name || ("app?:"+aId.slice(0,6));
      const bName = b?.name || ("app?:"+bId.slice(0,6));
      hopDetails.push(`${aName} ‚Üí ${bName}: ${st}`);
    }

    const overall = flowOverallStatus(hops); // ok | warning | blocked

    // persiste no arquivo flow
    f.status = overall;
    f.updatedAt = nowISO();

    if(overall==="ok") okCount++;
    else if(overall==="warning") warnCount++;
    else blockedCount++;

    const p = fullPathOf(f.id);

    // imprime resumo por flow (e mostra os hops em linha compacta)
    const hint = escapeHtml(hopDetails.join(" | "));
    printHTMLLine(
      `${flowStatusBadge(overall)} <b>${escapeHtml(p)}</b><div class="muted" style="margin-left:12px;margin-top:3px">${hint}</div>`,
      "out"
    );
  }

  saveState();

  printLine("", "out");
  printLine(`Resumo: OK=${okCount} | ATEN√á√ÉO=${warnCount} | BLOQUEADO=${blockedCount}`, "muted");
}

/* ================= CLI COMMAND ================= */
function cmd_flow(raw){
  const args = raw.replace(/^flow\s*/,"").trim();

  // ----------------------------
  // MODO VISUALIZAR
  // ----------------------------
  if(args.startsWith("ver ")){
    const name = args.replace(/^ver\s+/,"").trim();
    if(!name){
      printLine("Use: flow ver <nome>", "muted");
      return;
    }

    const flow = state.nodes.find(n =>
      n.type === "flow" && n.name === name
    );

    if(!flow){
      printLine(`Flow n√£o encontrado: ${name}`, "err");
      return;
    }

    openFlowModal(flow.apps.map(id => nodeById(id)));
    return;
  }

  // ----------------------------
  // CRIA√á√ÉO DO FLOW
  // ----------------------------
  if(!args){
    printLine("Use: flow App1 > App2 > App3", "muted");
    return;
  }

  const tokens = args.split(">").map(s=>s.trim()).filter(Boolean);
  if(!tokens.length){
    printLine("Fluxo vazio.", "err");
    return;
  }

  const apps = [];

  for(const token of tokens){
    let app = null;

    if(token.includes("#")){
      const [, id] = token.split("#");
      app = state.nodes.find(n => isApp(n) && n.id === id);
    } else {
      app = state.nodes.find(n => isApp(n) && n.name === token);
    }

    if(!app){
      printLine(`App inv√°lida: ${token}`, "err");
      return;
    }

    apps.push(app);
  }

  // cria n√≥ flow NO DIRET√ìRIO ATUAL
  const flowNode = {
    id: rid(),
    type: "flow",
    name: `flow-${Date.now()}`,
    parentId: state.cwdId,
    apps: apps.map(a => a.id),
    createdAt: nowISO(),
    updatedAt: nowISO()
  };

  state.nodes.push(flowNode);
  saveState?.();

  printLine(`Flow criado: ${flowNode.name}`, "ok");

  // j√° abre o visual
  openFlowModal(apps);
}

  function renderGraph(svg, mode="hover"){
    svg.innerHTML = "";
  
    // =========================
    // Drag infra (self-contained)
    // =========================
    state.ui = state.ui || {};
    state.ui.graphOffsets = state.ui.graphOffsets || {}; // key -> {dx,dy}
  
    const getOffset = (key)=>{
      if(!state.ui.graphOffsets[key]) state.ui.graphOffsets[key] = { dx:0, dy:0 };
      return state.ui.graphOffsets[key];
    };
  
    const clientToSvg = (clientX, clientY)=>{
      const r = svg.getBoundingClientRect();
      const w = Number(svg.getAttribute("width")  || r.width  || 1);
      const h = Number(svg.getAttribute("height") || r.height || 1);
      return {
        x: (clientX - r.left) * (w / (r.width  || 1)),
        y: (clientY - r.top ) * (h / (r.height || 1))
      };
    };
  
    const clamp = (v, lo, hi)=> Math.max(lo, Math.min(hi, v));
  
    // init drag handlers once per svg
    if(!svg.__cmdbDragInit){
      svg.__cmdbDragInit = true;
      svg.__cmdbDragState = null;
  
      svg.addEventListener("dblclick", (ev)=>{
        const hit = ev.target && ev.target.closest && ev.target.closest("[data-nodeid],[data-appid]");
        if(!hit) return;
      
        ev.preventDefault();
        ev.stopPropagation();
      
        const nodeId = hit.getAttribute("data-nodeid") || hit.getAttribute("data-appid");
        if(!nodeId) return;
      
        // abre o modal de edi√ß√£o do seu HTML
        openModal(nodeId);
      });

      svg.addEventListener("pointerdown", (ev)=>{
        const target = ev.target;
        if(!target) return;
  
        const g = target.closest && target.closest("[data-dragkey]");
        if(!g) return;
  
        const key = g.getAttribute("data-dragkey");
        if(!key) return;
  
        ev.preventDefault();
  
        const pt = clientToSvg(ev.clientX, ev.clientY);
        const off = getOffset(key);
  
        svg.__cmdbDragState = {
          key,
          startPt: pt,
          startOff: { dx: off.dx, dy: off.dy },
          modeAtStart: mode
        };
  
        if(target.setPointerCapture) target.setPointerCapture(ev.pointerId);
      });
  
      svg.addEventListener("pointermove", (ev)=>{
        const ds = svg.__cmdbDragState;
        if(!ds) return;
  
        const pt = clientToSvg(ev.clientX, ev.clientY);
        const off = getOffset(ds.key);
  
        off.dx = ds.startOff.dx + (pt.x - ds.startPt.x);
        off.dy = ds.startOff.dy + (pt.y - ds.startPt.y);
  
        renderGraph(svg, ds.modeAtStart || mode);
      });
  
      const end = ()=>{ svg.__cmdbDragState = null; };
      svg.addEventListener("pointerup", end);
      svg.addEventListener("pointercancel", end);
      svg.addEventListener("pointerleave", end);
    }
  
    // =========================
    // Data
    // =========================
    const cmdbs = state.nodes.filter(isCMDBDir).slice().sort((a,b)=>a.name.localeCompare(b.name));
    const apps  = state.nodes.filter(isApp);
    const conns = state.nodes.filter(isConn);
  
// --------- SUPRIMENTO (entrada/sa√≠da) por app ----------
const hasIn  = new Map();
const hasOut = new Map();
apps.forEach(a => { hasIn.set(a.id,false); hasOut.set(a.id,false); });

for(const c of conns){
  if(c.toAppId && hasIn.has(c.toAppId))       hasIn.set(c.toAppId, true);
  if(c.fromAppId && hasOut.has(c.fromAppId))  hasOut.set(c.fromAppId, true);
}
const isSuppliedApp = (appId)=> !!hasIn.get(appId) && !!hasOut.get(appId);

// --------- HEALTH por app (ok/warning/blocked/default) ----------
function getAppHealth(appId){
  let hasBlocked = false;
  let hasWarning = false;

  for(const c of conns){
    const rel = (c.fromAppId===appId || c.toAppId===appId);
    if(!rel) continue;

    const st = (c.connStatus || "nao-testada");
    if(st === "bloqueada") { hasBlocked = true; break; }
    if(st === "nao-testada") hasWarning = true;
  }

  if(hasBlocked) return "blocked";
  if(hasWarning) return "warning";
  if(isSuppliedApp(appId)) return "ok";
  return "default";
}

function colorsForHealth(appHealth, isolated=false){
  // se for isolada e voc√™ quiser manter a est√©tica "branca", preserva:
  if(isolated) return { fill:"rgba(255,255,255,0.95)", stroke:"rgba(0,0,0,0.25)" };

  if (appHealth === "ok") {
    return {
      fill:   "rgba(120, 255, 160, 0.55)",   // VERDE mais evidente
      stroke: "rgba(70, 255, 150, 0.98)"
    };
  } else if (appHealth === "warning") {
    return {
      fill:   "rgba(255, 210, 120, 0.40)",
      stroke: "rgba(255, 190, 80, 0.95)"
    };
  } else if (appHealth === "blocked") {
    return {
      fill:   "rgba(255, 120, 120, 0.42)",
      stroke: "rgba(255, 80, 80, 0.95)"
    };
  } else {
    return {
      fill:   "rgba(255,255,255,0.06)",
      stroke: "rgba(85,230,165,0.28)"
    };
  }
}

    // ---------- helpers ----------
    const esc = (s)=> String(s ?? "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    const getDc  = (c)=> (c.datacenter || c.dc || "").trim() || "(sem dc)";
    const getEnv = (c)=> (c.ambiente || c.env || "").trim() || "(sem env)";
    const getNs  = (c)=> (c.namespace || c.ns || c.nspace || c.nameSpace || "").trim() || "(sem namespace)";
  
    // filtro de modo
    function allowConnByMode(c){
      const st = (c.connStatus || "nao-testada");
      if(mode === "bloqueada") return st === "bloqueada";
      if(mode === "nao-testada") return st === "nao-testada";
      if (mode === "testada") return c.connStatus === "testada";
      return true; // hover
    }
  
    function strokeForConn(c){
      const st = (c.connStatus || "nao-testada");
      if(st === "bloqueada") return { color:"rgba(255,107,107,0.95)", w:2.6, dash:"7 6" }; // vermelha pontilhada
      if(st === "testada")   return { color:"rgba(101,168,255,0.9)",  w:2.4, dash:"" };
      return { color:"rgba(255,211,107,0.95)", w:2.0, dash:"" };
    }
  
    // graus (isolados)
    const appDegree = new Map();
    const cmdbDegree = new Map();
    const inc = (m,k)=>m.set(k,(m.get(k)||0)+1);
  
    apps.forEach(a=>appDegree.set(a.id,0));
    cmdbs.forEach(c=>cmdbDegree.set(c.id,0));
  
    for(const c of conns){
      inc(appDegree, c.fromAppId);
      inc(appDegree, c.toAppId);
      const fa = nodeById(c.fromAppId);
      const ta = nodeById(c.toAppId);
      if(fa?.cmdbId) inc(cmdbDegree, fa.cmdbId);
      if(ta?.cmdbId) inc(cmdbDegree, ta.cmdbId);
    }
    const isIsolatedApp  = (id)=> (appDegree.get(id)||0)===0;
    const isIsolatedCmdb = (id)=> (cmdbDegree.get(id)||0)===0;
  
    // apps por cmdb
    const appsByCmdb = new Map();
    for(const c of cmdbs) appsByCmdb.set(c.id, []);
    for(const a of apps){
      if(!appsByCmdb.has(a.cmdbId)) appsByCmdb.set(a.cmdbId, []);
      appsByCmdb.get(a.cmdbId).push(a);
    }
    for(const [k,v] of appsByCmdb.entries()) v.sort((x,y)=>x.name.localeCompare(y.name));
  
    // ---------- layout params ----------
    const pad = 18;
    const dcPad = 18;
    const envPad = 16;
  
    const nsPad = 14;
    const nsTitleH = 26;
    const nsGap = 14;
  
    const cmdbW = 330;
    const cmdbColGap = 22;
    const cmdbRowGap = 22;
  
    const headerH = 34;
    const appH = 24;
  
    const envTitleH = 30;
    const dcTitleH  = 30;
  
    const perRow = 3; // cmdb por linha dentro do namespace
  
    // ---------- 1) agrupar: DC -> ENV -> NAMESPACE -> CMDB ----------
    const dcMap = new Map(); // dc -> envMap(nsMap(list))
    for(const c of cmdbs){
      const dc  = getDc(c);
      const env = getEnv(c);
      const ns  = getNs(c);
  
      if(!dcMap.has(dc)) dcMap.set(dc, new Map());
      const envMap = dcMap.get(dc);
      if(!envMap.has(env)) envMap.set(env, new Map());
      const nsMap = envMap.get(env);
      if(!nsMap.has(ns)) nsMap.set(ns, []);
      nsMap.get(ns).push(c);
    }
  
    // sort em cada n√≠vel
    const dcs = Array.from(dcMap.keys()).sort((a,b)=>a.localeCompare(b));
    for(const dc of dcs){
      const envMap = dcMap.get(dc);
      const envs = Array.from(envMap.keys()).sort((a,b)=>a.localeCompare(b));
      const newEnvMap = new Map();
  
      for(const env of envs){
        const nsMap = envMap.get(env);
        const nss = Array.from(nsMap.keys()).sort((a,b)=>a.localeCompare(b));
        const newNsMap = new Map();
  
        for(const ns of nss){
          const list = nsMap.get(ns).slice().sort((a,b)=>a.name.localeCompare(b.name));
          newNsMap.set(ns, list);
        }
        newEnvMap.set(env, newNsMap);
      }
      dcMap.set(dc, newEnvMap);
    }
  
    // ---------- 2) calcular tamanhos/posi√ß√µes: CMDB dentro de NAMESPACE dentro de ENV ----------
    const cmdbPos = new Map(); // cmdbId -> {x,y,w,h, appPos:Map(appId->{in,out,mid})}
    const nsPos  = new Map();  // key "dc||env||ns" -> {x,y,w,h}
    const envPos = new Map();  // key "dc||env" -> {x,y,w,h}
    const dcPos  = new Map();  // dc -> {x,y,w,h}
  
    function computeNsBox(dc, env, ns, cmdbList, startX, startY){
      // startX/startY is top-left of the namespace box
      let x = startX + nsPad;
      let y = startY + nsTitleH + nsPad;
  
      let colMaxH = 0;
      let maxX = x, maxY = y;
  
      cmdbList.forEach((c, idx)=>{
        const appsIn = appsByCmdb.get(c.id) || [];
        const cmdbH = headerH + Math.max(1, appsIn.length)*appH + 22;
  
        if(idx>0 && idx % perRow === 0){
          x = startX + nsPad;
          y = y + colMaxH + cmdbRowGap;
          colMaxH = 0;
        }
  
        // base CMDB position
        let cx = x;
        let cy = y;
  
        // apply CMDB offset
        const offC = getOffset("cmdb:" + c.id);
        cx += offC.dx; cy += offC.dy;
  
        cmdbPos.set(c.id, { x: cx, y: cy, w: cmdbW, h: cmdbH, appPos:new Map() });
  
        colMaxH = Math.max(colMaxH, cmdbH);
        maxX = Math.max(maxX, cx + cmdbW);
        maxY = Math.max(maxY, cy + cmdbH);
  
        x = x + cmdbW + cmdbColGap;
      });
  
      const nsW = (maxX - startX) + nsPad;
      const nsH = (maxY - startY) + nsPad;
  
      return { w: Math.max(nsW, cmdbW + nsPad*2), h: Math.max(nsH, nsTitleH + 80) };
    }
  
    function computeEnvBox(dc, env, nsMap, startX, startY){
      // stack namespaces vertically inside env
      let innerY = startY + envTitleH + envPad;
      const envX = startX;
  
      let maxX = envX + envPad;
      let maxY = innerY;
  
      for(const ns of Array.from(nsMap.keys())){
        const cmdbList = nsMap.get(ns) || [];
  
        // base NS position
        let nx = envX + envPad;
        let ny = innerY;
  
        // apply NS offset
        const offNs = getOffset("ns:" + dc + "||" + env + "||" + ns);
        nx += offNs.dx; ny += offNs.dy;
  
        const { w: nsW, h: nsH } = computeNsBox(dc, env, ns, cmdbList, nx, ny);
  
        nsPos.set(dc + "||" + env + "||" + ns, { x:nx, y:ny, w:nsW, h:nsH });
  
        innerY = ny + nsH + nsGap;
        maxX = Math.max(maxX, nx + nsW);
        maxY = Math.max(maxY, ny + nsH);
      }
  
      const envW = (maxX - startX) + envPad;
      const envH = (maxY - startY) + envPad;
  
      return { w: Math.max(envW, cmdbW + envPad*2), h: Math.max(envH, envTitleH + 120) };
    }
  
    // ---------- 3) posicionar DCs empilhados verticalmente ----------
    let cursorY = pad;
    const canvasWMin = 1400;
    let canvasW = canvasWMin;
  
    for(const dc of dcs){
      const envMap = dcMap.get(dc);
      const envs = Array.from(envMap.keys());
  
      // base dc position
      let dcX = pad;
      let dcY = cursorY;
  
      // apply DC offset
      const offDc = getOffset("dc:" + dc);
      dcX += offDc.dx;
      dcY += offDc.dy;
  
      let innerY = dcY + dcTitleH + dcPad;
  
      let dcMaxW = 0;
      let dcMaxY = innerY;
  
      for(const env of envs){
        const nsMap = envMap.get(env);
  
        // base env position
        let envX = dcX + dcPad;
        let envY = innerY;
  
        // apply ENV offset
        const offEnv = getOffset("env:" + dc + "||" + env);
        envX += offEnv.dx;
        envY += offEnv.dy;
  
        const { w: envW, h: envH } = computeEnvBox(dc, env, nsMap, envX, envY);
  
        envPos.set(dc + "||" + env, { x: envX, y: envY, w: envW, h: envH });
  
        innerY = envY + envH + 16;
        dcMaxW = Math.max(dcMaxW, envX + envW - dcX);
        dcMaxY = Math.max(dcMaxY, envY + envH);
      }
  
      const dcW = dcMaxW + dcPad;
      const dcH = (dcMaxY - dcY) + dcPad;
  
      dcPos.set(dc, { x: dcX, y: dcY, w: dcW, h: dcH });
  
      cursorY = dcY + dcH + 18;
      canvasW = Math.max(canvasW, dcX + dcW + pad);
    }
  
    const canvasH = Math.max(900, cursorY + pad);
    svg.setAttribute("width", String(canvasW));
    svg.setAttribute("height", String(canvasH));
  
    // ---------- camadas ----------
    const dcLayer   = svgEl("g");
    const envLayer  = svgEl("g");
    const nsLayer   = svgEl("g");
    const cmdbLayer = svgEl("g");
    const edgeLayer = svgEl("g");
    const labelLayer= svgEl("g");
    const appLayer  = svgEl("g");
  
    svg.appendChild(dcLayer);
    svg.appendChild(envLayer);
    svg.appendChild(nsLayer);
    svg.appendChild(cmdbLayer);
    svg.appendChild(edgeLayer);
    svg.appendChild(labelLayer);
    svg.appendChild(appLayer);
  
    // ---------- defs: clipPath para t√≠tulo do CMDB ----------
    const defs = svgEl("defs");
    svg.appendChild(defs);
  
    function addClip(id, x,y,w,h){
      const cp = svgEl("clipPath", { id });
      cp.appendChild(svgEl("rect", { x, y, width:w, height:h, rx:"10", ry:"10" }));
      defs.appendChild(cp);
      return id;
    }
  
    // ---------- 4) desenha DC e ENV ----------
    for(const dc of dcs){
      const p = dcPos.get(dc);
      if(!p) continue;
  
      const dcKey = "dc:" + dc;
      const dcG = svgEl("g", { "data-dragkey": dcKey, style:"cursor:move" });
      dcLayer.appendChild(dcG);
  
      dcG.appendChild(svgEl("rect", {
        x:p.x, y:p.y, width:p.w, height:p.h, rx:"20", ry:"20",
        fill:"rgba(255,255,255,0.02)",
        stroke:"rgba(122,162,255,0.22)",
        "stroke-width":"1.2"
      }));
  
      const t = svgEl("text", {
        x:p.x+14, y:p.y+21,
        fill:"var(--text)",
        "font-family":"var(--mono)",
        "font-size":"12.8",
        "opacity":"0.9",
        "pointer-events":"none"
      });
      t.textContent = `DATACENTER: ${dc}`;
      dcG.appendChild(t);
  
      const envMap = dcMap.get(dc);
      for(const [env, nsMap] of envMap.entries()){
        const epos = envPos.get(dc + "||" + env);
        if(!epos) continue;
  
        const envKey = "env:" + dc + "||" + env;
        const envG = svgEl("g", { "data-dragkey": envKey, style:"cursor:move" });
        envLayer.appendChild(envG);
  
        envG.appendChild(svgEl("rect", {
          x:epos.x, y:epos.y, width:epos.w, height:epos.h, rx:"18", ry:"18",
          fill:"rgba(255,255,255,0.03)",
          stroke:"rgba(255,255,255,0.08)",
          "stroke-width":"1.0"
        }));
  
        const et = svgEl("text", {
          x:epos.x+14, y:epos.y+20,
          fill:"var(--muted)",
          "font-family":"var(--mono)",
          "font-size":"12.2",
          "pointer-events":"none"
        });
        et.textContent = `AMBIENTE: ${env}`;
        envG.appendChild(et);
  
        // ---------- 4.1) desenha NAMESPACE dentro do ENV ----------
        for(const ns of Array.from(nsMap.keys())){
          const npos = nsPos.get(dc + "||" + env + "||" + ns);
          if(!npos) continue;
  
          const nsKey = "ns:" + dc + "||" + env + "||" + ns;
          const nsG = svgEl("g", { "data-dragkey": nsKey, style:"cursor:move" });
          nsLayer.appendChild(nsG);
  
          nsG.appendChild(svgEl("rect", {
            x:npos.x, y:npos.y, width:npos.w, height:npos.h, rx:"16", ry:"16",
            fill:"rgba(255,255,255,0.028)",
            stroke:"rgba(255,255,255,0.085)",
            "stroke-width":"1.0"
          }));
  
          const nt = svgEl("text", {
            x:npos.x+14, y:npos.y+18,
            fill:"rgba(255,255,255,0.62)",
            "font-family":"var(--mono)",
            "font-size":"12.0",
            "pointer-events":"none"
          });
          nt.textContent = `NAMESPACE: ${ns}`;
          nsG.appendChild(nt);
        }
      }
    }
  
    // ---------- 5) desenha CMDBs + apps ----------
    const appElsById = new Map(); // appId -> [elements]
    const remember = (appId, el)=>{
      if(!appElsById.has(appId)) appElsById.set(appId, []);
      appElsById.get(appId).push(el);
    };
  
    for(const c of cmdbs){
      const p = cmdbPos.get(c.id);
      if(!p) continue;
  
      const cmdbIsolated = isIsolatedCmdb(c.id);
      const fill   = cmdbIsolated ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.04)";
      const stroke = cmdbIsolated ? "rgba(0,0,0,0.25)" : "rgba(122,162,255,0.35)";
  
      const cmdbKey = "cmdb:" + c.id;
      const cmdbG = svgEl("g", { "data-dragkey": cmdbKey, "data-nodeid": c.id, style:"cursor:move" });
      cmdbLayer.appendChild(cmdbG);
  
      cmdbG.appendChild(svgEl("rect", {
        x:p.x, y:p.y, width:p.w, height:p.h, rx:"16", ry:"16",
        fill, stroke, "stroke-width":"1.2"
      }));
  
      const clipId = addClip("cmdbTitleClip_" + c.id, p.x+10, p.y+10, p.w-20, 20);
      const titleG = svgEl("g", { "clip-path": `url(#${clipId})` });
  
      const titleText = `${c.name} ‚Ä¢ ${c.hostname||"-"} ‚Ä¢ ${c.ip||"-"}`;
      const tt = svgEl("text", {
        x:p.x+14, y:p.y+22,
        fill: cmdbIsolated ? "rgba(0,0,0,0.78)" : "var(--text)",
        "font-family":"var(--mono)",
        "font-size":"12",
        "opacity": cmdbIsolated ? "1" : "0.80",
        "pointer-events":"none"
      });
      tt.textContent = titleText;
  
      titleG.appendChild(tt);
      cmdbG.appendChild(titleG);
  
      // apps
      const list = (appsByCmdb.get(c.id)||[]);
      const baseY = p.y + headerH;
  
      if(!list.length){
        const cx = p.x + p.w/2;
        const cy = baseY + 18;
        p.appPos.set("__none__", { mid:{x:cx,y:cy}, in:{x:cx-10,y:cy}, out:{x:cx+10,y:cy} });
        cmdbG.appendChild(svgEl("circle", {
          cx, cy, r:"4.5",
          fill: cmdbIsolated ? "rgba(0,0,0,0.25)" : "rgba(255,255,255,0.35)"
        }));
        continue;
      }
  
      list.forEach((a, i)=>{
        // base (no offset)
        const ay0 = baseY + 18 + i*appH;
        const ax0 = p.x + 18;
  
        const boxW = Math.min(286, p.w - 36);
        const boxH = 18;
  
        // bounds so the app never leaves the CMDB box
        // (we clamp the OFFSET itself)
        const minX = p.x + 18;
        const maxX = p.x + p.w - 18 - boxW;
  
        // top/bottom based on app boxY = ay-10 and boxH=18
        const topBoxY    = p.y + headerH + 6;
        const bottomBoxY = p.y + p.h - 12 - boxH;
  
        const minAy = topBoxY + 10;                 // since boxY = ay-10
        const maxAy = bottomBoxY + 10;              // keep box fully inside
  
        const minDx = minX - ax0;
        const maxDx = maxX - ax0;
        const minDy = minAy - ay0;
        const maxDy = maxAy - ay0;
  
        const offA = getOffset("app:" + a.id);
        // clamp and persist so dragging can't "escape"
  
        const ax = ax0 + offA.dx;
        const ay = ay0 + offA.dy;
  
        const boxX = ax;
        const boxY = ay - 10;
  
        const appIsolated = isIsolatedApp(a.id);
        const appHealth = getAppHealth(a.id);
        const hc = colorsForHealth(appHealth, appIsolated);
        const appSupplied = isSuppliedApp(a.id);

        const appKey = "app:" + a.id;
        const g = svgEl("g", { "data-appid": a.id, "data-dragkey": appKey, style:"cursor:move" });
  
        const box = svgEl("rect", {
          x: boxX, y: boxY, width: boxW, height: boxH, rx:"8", ry:"8",
          fill: hc.fill,
          stroke: hc.stroke,
        });
        g.appendChild(box); remember(a.id, box);
  
        const inX  = boxX + 6;
        const outX = boxX + boxW - 6;
        const cy   = ay;
  
        const inDot = svgEl("circle", {
          cx: inX, cy, r:"3.2",
          fill: appIsolated ? "rgba(0,0,0,0.35)" : "rgba(122,162,255,0.55)",
          stroke:"rgba(0,0,0,0.18)", "stroke-width":"0.6",
          "pointer-events":"all"
        });
        const outDot = svgEl("circle", {
          cx: outX, cy, r:"3.2",
          fill: appIsolated ? "rgba(0,0,0,0.35)" : "rgba(85,230,165,0.55)",
          stroke:"rgba(0,0,0,0.18)", "stroke-width":"0.6",
          "pointer-events":"all"
        });
        g.appendChild(inDot); g.appendChild(outDot);
        remember(a.id, inDot); remember(a.id, outDot);
  
        const label = svgEl("text", {
          x: boxX + 14, y: ay + 4,
          fill: appIsolated ? "rgba(0,0,0,0.82)" : "var(--text)",
          "font-family":"var(--mono)",
          "font-size":"12",
          "pointer-events":"all"
        });
        label.textContent = `${a.name}:${a.port}`;
        g.appendChild(label); remember(a.id, label);
  
        p.appPos.set(a.id, {
          mid:{ x: boxX + boxW/2, y: ay },
          in: { x: inX,  y: cy },
          out:{ x: outX, y: cy }
        });

        // ===== EXPORTA ANCHORS PARA ANIMA√á√ÉO (fora do renderGraph) =====
state.ui = state.ui || {};
state.ui.graphAnchors = state.ui.graphAnchors || {}; // appId -> {x,y, cmdbId, cmdbName, dc, env, ns}
state.ui.graphAnchors[a.id] = {
  x: (p.appPos.get(a.id)?.mid?.x ?? (boxX + boxW/2)),
  y: (p.appPos.get(a.id)?.mid?.y ?? ay),
  cmdbId: a.cmdbId,
  cmdbName: (nodeById(a.cmdbId)?.name || ""),
  dc: (nodeById(a.cmdbId)?.datacenter || nodeById(a.cmdbId)?.dc || ""),
  env: (nodeById(a.cmdbId)?.ambiente || nodeById(a.cmdbId)?.env || ""),
  ns:  (nodeById(a.cmdbId)?.namespace || nodeById(a.cmdbId)?.ns || "")
};
  
        appLayer.appendChild(g);
      });
    }
  
    // ---------- 6) desenha edges (com hover: escondidas) ----------
    const edgeEls = []; // {el,labelEl,fromAppId,toAppId}
  
    function setEdgeVisible(edge, on){
      edge.el.style.opacity = on ? "1" : "0";
      if(edge.labelEl) edge.labelEl.style.opacity = on ? "1" : "0";
    }
  
    function setEdgeEmphasis(edge, strong){
      const baseW = Number(edge.el.getAttribute("data-basew") || "2.0");
      edge.el.setAttribute("stroke-width", String(strong ? (baseW + 1.2) : baseW));
      edge.el.style.filter = strong ? "drop-shadow(0 0 1px rgba(255,255,255,0.35))" : "none";
    }
  
    for(const c of conns){
      if(!allowConnByMode(c)) continue;
  
      const fa = nodeById(c.fromAppId);
      const ta = nodeById(c.toAppId);
      if(!fa || !ta) continue;
  
      const fp = cmdbPos.get(fa.cmdbId);
      const tp = cmdbPos.get(ta.cmdbId);
      if(!fp || !tp) continue;
  
      const fpt = fp.appPos.get(fa.id) || fp.appPos.get("__none__");
      const tpt = tp.appPos.get(ta.id) || tp.appPos.get("__none__");
      if(!fpt || !tpt) continue;
  
      const x1 = (fpt.out?.x ?? fpt.mid.x), y1 = (fpt.out?.y ?? fpt.mid.y);
      const x2 = (tpt.in?.x  ?? tpt.mid.x), y2 = (tpt.in?.y  ?? tpt.mid.y);
  
      const distX = Math.abs(x2 - x1);
      const dist  = Math.hypot(distX, Math.abs(y2-y1));
  
      const dx = (dist < 140) ? Math.max(10, distX * 0.08)
               : (dist < 320) ? Math.max(22, distX * 0.18)
               :               Math.max(70, distX * 0.38);
  
      const { color, w, dash } = strokeForConn(c);
  
      const path = svgEl("path", {
        d:`M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`,
        fill:"none",
        stroke: color,
        "stroke-width": String(w),
        "stroke-linecap":"round",
        "data-from": fa.id,
        "data-to": ta.id,
        "data-basew": String(w),
        "pointer-events":"none"
      });
      if(dash) path.setAttribute("stroke-dasharray", dash);
  
      if(mode === "hover") path.style.opacity = "0";
      else path.style.opacity = "1";
  
      edgeLayer.appendChild(path);
  
      const mx = (x1+x2)/2, my = (y1+y2)/2;
      const label = svgEl("text", {
        x: mx + 6, y: my - 6,
        fill:"var(--muted)",
        "font-family":"var(--mono)",
        "font-size":"11.5",
        "pointer-events":"none"
      });
      label.textContent = `${c.port} ‚Ä¢ ${c.connStatus}`;
      if(mode === "hover") label.style.opacity = "0";
      else label.style.opacity = "1";
      labelLayer.appendChild(label);
  
      edgeEls.push({ el:path, labelEl:label, fromAppId:fa.id, toAppId:ta.id });
    }
  
    // ---------- 7) hover REAL: s√≥ aparece quando passar no bloquinho OU texto ----------
    if(mode === "hover"){
      function showForApp(appId){
        for(const e of edgeEls){
          const rel = (e.fromAppId === appId || e.toAppId === appId);
          setEdgeVisible(e, rel);
          setEdgeEmphasis(e, rel);
        }
      }
      function clearAll(){
        for(const e of edgeEls){
          setEdgeVisible(e, false);
          setEdgeEmphasis(e, false);
        }
      }
  
      let hoverTimer = null;
  
      function enter(appId){
        if(hoverTimer){ clearTimeout(hoverTimer); hoverTimer = null; }
        showForApp(appId);
      }
      function leave(){
        if(hoverTimer) clearTimeout(hoverTimer);
        hoverTimer = setTimeout(()=> clearAll(), 60);
      }
  
      for(const [appId, els] of appElsById.entries()){
        for(const el of els){
          el.addEventListener("mouseenter", ()=> enter(appId));
          el.addEventListener("mouseleave", leave);
        }
      }
  
      clearAll();
    }
  }

  

  

  function attachSvgZoomPan(svg){
    if(svg.__zoomPanAttached) return;
    svg.__zoomPanAttached = true;
  
    // garante viewBox inicial
    const initFromSize = ()=>{
      const w = Number(svg.getAttribute("width")  || svg.clientWidth  || 1200);
      const h = Number(svg.getAttribute("height") || svg.clientHeight || 800);
      if(!svg.getAttribute("viewBox")){
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      }
    };
    initFromSize();
  
    const getVB = ()=>{
      const [x,y,w,h] = (svg.getAttribute("viewBox")||"0 0 1200 800").split(/\s+/).map(Number);
      return {x,y,w,h};
    };
    const setVB = (vb)=>{
      svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    };
  
    const clamp = (v, a, b)=> Math.max(a, Math.min(b, v));
  
    // limites de zoom (ajuste)
    const MIN_W = 300;     // m√°ximo zoom-in (menor viewBox)
    const MAX_W = 20000;   // m√°ximo zoom-out (maior viewBox)
  
    // converte mouse -> coords do SVG (no espa√ßo do viewBox)
    function svgPointFromEvent(evt){
      const rect = svg.getBoundingClientRect();
      const vb = getVB();
      const mx = (evt.clientX - rect.left) / rect.width;   // 0..1
      const my = (evt.clientY - rect.top)  / rect.height;  // 0..1
      return {
        x: vb.x + mx * vb.w,
        y: vb.y + my * vb.h
      };
    }
  
    function zoomAt(factor, evt){ // factor <1 zoom in, >1 zoom out
      const vb = getVB();
      const p = evt ? svgPointFromEvent(evt) : { x: vb.x + vb.w/2, y: vb.y + vb.h/2 };
  
      let newW = vb.w * factor;
      newW = clamp(newW, MIN_W, MAX_W);
      const scale = newW / vb.w;
      const newH = vb.h * scale;
  
      // mant√©m o ponto p ‚Äúparado‚Äù na tela
      const nx = p.x - (p.x - vb.x) * scale;
      const ny = p.y - (p.y - vb.y) * scale;
  
      setVB({ x:nx, y:ny, w:newW, h:newH });
    }
  
    // wheel: zoom (Ctrl opcional; se quiser sempre zoom, remova o if)
    svg.addEventListener("wheel", (e)=>{
      // Se quiser zoom s√≥ com Ctrl (estilo navegador), deixe assim:
      // if(!e.ctrlKey) return;
      e.preventDefault();
  
      const delta = e.deltaY;
      const factor = delta > 0 ? 1.12 : 0.89;
      zoomAt(factor, e);
    }, { passive:false });
  
    // pan: arrastar com bot√£o do meio ou com espa√ßo+mouse (configur√°vel)
    let panning = false;
    let start = null;
  
    function startPan(e){
      // escolha a regra:
      // - bot√£o do meio (1)
      // - ou bot√£o esquerdo + tecla Space
      const ok = (e.button === 1) || (e.button === 0 && e.code === "Space");
      if(!ok) return;
  
      panning = true;
      svg.style.cursor = "grabbing";
      start = { ...svgPointFromEvent(e), vb:getVB() };
      e.preventDefault();
    }
  
    function movePan(e){
      if(!panning || !start) return;
      const p = svgPointFromEvent(e);
      const dx = p.x - start.x;
      const dy = p.y - start.y;
      setVB({
        x: start.vb.x - dx,
        y: start.vb.y - dy,
        w: start.vb.w,
        h: start.vb.h
      });
    }
  
    function endPan(){
      if(!panning) return;
      panning = false;
      start = null;
      svg.style.cursor = "";
    }
  
    svg.addEventListener("mousedown", startPan);
    window.addEventListener("mousemove", movePan);
    window.addEventListener("mouseup", endPan);
  
    // atalhos: + / - / 0 (reset)
    window.addEventListener("keydown", (e)=>{
      if(e.target && (e.target.tagName==="INPUT" || e.target.tagName==="TEXTAREA")) return;
  
      if(e.key === "+" || (e.key==="=" && e.ctrlKey)){
        zoomAt(0.89, null);
      } else if(e.key === "-" || (e.key==="-" && e.ctrlKey)){
        zoomAt(1.12, null);
      } else if(e.key === "0" && (e.ctrlKey || e.metaKey)){
        // reset: volta ao tamanho atual do svg (width/height)
        const w = Number(svg.getAttribute("width")  || svg.clientWidth  || 1200);
        const h = Number(svg.getAttribute("height") || svg.clientHeight || 800);
        setVB({x:0,y:0,w,h});
      }
    });
  }

  // ---------------- Modal (multi-type) ----------------
  function fillAppDropdowns(selectedId){
    const apps = allApps().slice().sort((a,b)=>a.name.localeCompare(b.name));
    const opt = (a) => `<option value="${a.id}">${escapeHtml(a.name)} (port ${escapeHtml(String(a.port||"-"))}) ‚Ä¢ cmdb:${escapeHtml(nodeById(a.cmdbId)?.name || "-")}</option>`;
    mFrom.innerHTML = apps.map(opt).join("");
    mTo.innerHTML = apps.map(opt).join("");
    if(selectedId && apps.some(a=>a.id===selectedId)) return;
  }

  function openModal(id){
    const n = nodeById(id);
    if(!n) return;
    editingId = id;

    // reset sections
    taskFields.style.display = "none";
    urlFields.style.display = "none";
    cmdbFields.style.display = "none";
    appFields.style.display = "none";
    connFields.style.display = "none";

    mName.value = n.name || "";
    mFolder.value = fullPathOf(n.parentId || "root");
    mPath.textContent = fullPathOf(id);

    if(isTask(n)){
      mTitle.textContent = "Editar atividade (task)";
      taskFields.style.display = "";
      mResp.value = n.resp || "";
      mDue.value = n.due || "";
      mType.value = n.taskType || "";
      mStatus.value = n.status || "todo";
      mPrio.value = String(n.prio || 3);
      mNotes.value = n.notes || "";
      mUpdated.value = (n.updatedAt||"").replace("T"," ").slice(0,19);
    } else if(isUrl(n)){
      mTitle.textContent = "Editar favorito (url)";
      urlFields.style.display = "";
      mUrl.value = n.url || "";
    } else if(isCMDBDir(n)){
      mTitle.textContent = "Editar pasta CMDB";
      cmdbFields.style.display = "";
      mHost.value = n.hostname || "";
      mIp.value = n.ip || "";
      mDc.value = n.datacenter || "";
      mEnv.value = n.ambiente || "";
      mNs.value = n.namespace || "";
    } else if(isApp(n)){
      mTitle.textContent = "Editar application";
      appFields.style.display = "";
      mAppPort.value = String(n.port || "");
      mAppCmdb.value = nodeById(n.cmdbId)?.name || "-";
    } else if(isConn(n)){
      mTitle.textContent = "Editar conectividade";
      connFields.style.display = "";
      fillAppDropdowns();
      mFrom.value = n.fromAppId || "";
      mTo.value = n.toAppId || "";
      mConnPort.value = String(n.port || "");
      mConnStatus.value = n.connStatus || "nao-testada";
      mConnUpdated.value = (n.updatedAt||"").replace("T"," ").slice(0,19);
    } else {
      mTitle.textContent = "Editar";
    }

    modalOverlay.style.display = "flex";
  }

  function closeModal(){ modalOverlay.style.display="none"; editingId=null; }
  modalOverlay.addEventListener("click", (e)=>{ if(e.target===modalOverlay) closeModal(); });
  mClose.addEventListener("click", closeModal);

  mSave.addEventListener("click", ()=>{
    const n = nodeById(editingId);
    if(!n) return;

    const newName = (mName.value||"").trim();
    if(!newName){ alert("Nome inv√°lido."); return; }

    const folderPath = (mFolder.value||"").trim() || "/";
    const folderId = resolvePath(folderPath);
    if(!folderId){ alert("Pasta inv√°lida."); return; }
    const folderNode = nodeById(folderId);
    if(!(isDir(folderNode) || isCMDBDir(folderNode))){ alert("Destino n√£o √© pasta."); return; }

    // CMDB dir pode ir para dentro de dir/cmdb
    if(childrenOf(folderId).some(x=>x.name===newName && x.id!==n.id)){
      alert("J√° existe item com esse nome na pasta destino.");
      return;
    }

    const oldParent = n.parentId;

    // update common
    n.name = newName;
    n.parentId = folderId;
    n.updatedAt = nowISO();

    if(isTask(n)){
      n.resp = (mResp.value||"").trim();
      n.due = (mDue.value||"").trim();
      n.taskType = (mType.value||"").trim();
      n.status = mStatus.value;
      n.prio = Number(mPrio.value||3);
      n.notes = mNotes.value || "";
    } else if(isUrl(n)){
      const u = (mUrl.value||"").trim();
      if(u && !/^https?:\/\//i.test(u)){ alert("URL inv√°lida (use http/https)."); return; }
      n.url = u;
    } else if(isCMDBDir(n)){
      n.hostname = (mHost.value||"").trim();
      n.ip = (mIp.value||"").trim();
      n.datacenter = (mDc.value||"").trim();
      n.ambiente = (mEnv.value||"").trim();
      n.namespace = (mNs.value||"").trim();
    } else if(isApp(n)){
      const port = Number(mAppPort.value||"");
      if(!(port>=1 && port<=65535)){ alert("Porta inv√°lida (1..65535)"); return; }
      n.port = port;
      // cmdbId ajusta conforme novo local
      const newCmdb = nearestCMDBDirId(folderId);
      if(newCmdb) n.cmdbId = newCmdb;
    } else if(isConn(n)){
      const fromId = mFrom.value;
      const toId = mTo.value;
      const port = Number(mConnPort.value||"");
      if(!(port>=1 && port<=65535)){ alert("Porta inv√°lida (1..65535)"); return; }
      const st = mConnStatus.value;
      if(st!=="nao-testada" && st!=="testada" && st!=="bloqueada" ){ alert("Status inv√°lido"); return; }

      const fromApp = nodeById(fromId);
      const toApp = nodeById(toId);
      if(!fromApp || !isApp(fromApp)){ alert("Origem inv√°lida"); return; }
      if(!toApp || !isApp(toApp)){ alert("Destino inv√°lido"); return; }

      n.fromAppId = fromId;
      n.toAppId = toId;
      n.port = port;
      n.connStatus = st;
      n.name = `${fromApp.name} -> ${toApp.name}:${port}`;
      // cmdbId ajusta pelo local
      const newCmdb = nearestCMDBDirId(folderId);
      if(newCmdb) n.cmdbId = newCmdb;
    }

    touch(oldParent);
    touch(folderId);
    saveState();

    closeModal();
    printLine("Salvo.", "ok");
    updateCwd();
    renderSidebar();
  });

  mDelete.addEventListener("click", ()=>{
    const n = nodeById(editingId);
    if(!n) return;
    if(!confirm("Excluir este item?")) return;
    const r = removeNode(n.id);
    if(!r.ok){ alert(r.err); return; }
    closeModal();
    printLine("Exclu√≠do.", "ok");
    updateCwd();
    renderSidebar();
  });

  // ---------------- Config drawer ----------------
  $("btnConfig").addEventListener("click", ()=> drawerOverlay.style.display="flex");
  $("btnCloseConfig").addEventListener("click", ()=> drawerOverlay.style.display="none");
  drawerOverlay.addEventListener("click", (e)=>{ if(e.target===drawerOverlay) drawerOverlay.style.display="none"; });

  defPriority.value = String(settings.defPriority || 3);
  defStatus.value = settings.defStatus || "todo";

  defPriority.addEventListener("change", ()=>{
    settings.defPriority = Number(defPriority.value||3);
    saveSettings();
  });
  defStatus.addEventListener("change", ()=>{
    settings.defStatus = defStatus.value;
    saveSettings();
  });

  function ensureFontLevels(){
    if(!settings.sidebarFontLevels) settings.sidebarFontLevels = {};
    for(let lvl=1; lvl<=5; lvl++){
      if(!settings.sidebarFontLevels[lvl]){
        settings.sidebarFontLevels[lvl] = { size: 12, bold: false, italic: false, color: "" };
      }
      const c = settings.sidebarFontLevels[lvl];
      if(typeof c.size !== "number") c.size = 12;
      if(typeof c.bold !== "boolean") c.bold = false;
      if(typeof c.italic !== "boolean") c.italic = false;
      if(typeof c.color !== "string") c.color = "";
    }
  }
  
  function renderFontLevelsUI(){
    ensureFontLevels();
    const box = document.getElementById("fontLevelsBox");
    if(!box) return;
  
    box.innerHTML = "";
  
    for(let lvl=1; lvl<=5; lvl++){
      const cfg = settings.sidebarFontLevels[lvl];
  
      const row = document.createElement("div");
      row.style.display = "grid";
      row.style.gridTemplateColumns = "70px 90px 80px 80px 1fr";
      row.style.gap = "8px";
      row.style.alignItems = "center";
      row.style.margin = "8px 0";
  
      const lab = document.createElement("div");
      lab.textContent = "N√≠vel " + lvl;
  
      const size = document.createElement("input");
      size.type = "number";
      size.min = "8";
      size.max = "28";
      size.value = String(cfg.size);
  
      const bold = document.createElement("label");
      bold.style.display = "flex";
      bold.style.gap = "6px";
      bold.style.alignItems = "center";
      const boldCk = document.createElement("input");
      boldCk.type = "checkbox";
      boldCk.checked = !!cfg.bold;
      bold.appendChild(boldCk);
      bold.appendChild(document.createTextNode("Negrito"));
  
      const ital = document.createElement("label");
      ital.style.display = "flex";
      ital.style.gap = "6px";
      ital.style.alignItems = "center";
      const italCk = document.createElement("input");
      italCk.type = "checkbox";
      italCk.checked = !!cfg.italic;
      ital.appendChild(italCk);
      ital.appendChild(document.createTextNode("It√°lico"));
  
      const color = document.createElement("input");
      color.type = "color";
      // se vazio, coloca uma cor ‚Äúdummy‚Äù s√≥ pra UI funcionar
      color.value = (cfg.color && cfg.color.startsWith("#")) ? cfg.color : "#7aa2ff";
  
      const apply = ()=>{
        cfg.size = Number(size.value || 12);
        cfg.bold = !!boldCk.checked;
        cfg.italic = !!italCk.checked;
        // se usu√°rio escolheu uma cor, grava; se quiser ‚Äúlimpar‚Äù, vamos tratar com duplo-clique (abaixo)
        cfg.color = color.value;
  
        saveSettings();
        renderSidebar();
      };
  
      size.addEventListener("change", apply);
      boldCk.addEventListener("change", apply);
      italCk.addEventListener("change", apply);
      color.addEventListener("change", apply);
  
      // ‚ÄúLimpar cor‚Äù (voltar pro padr√£o): duplo clique no seletor de cor
      color.addEventListener("dblclick", ()=>{
        cfg.color = "";
        saveSettings();
        renderSidebar();
        renderFontLevelsUI();
      });
  
      row.appendChild(lab);
      row.appendChild(size);
      row.appendChild(bold);
      row.appendChild(ital);
      row.appendChild(color);
  
      box.appendChild(row);
    }
  
    const tip = document.createElement("div");
    tip.style.opacity = "0.8";
    tip.style.fontSize = "12px";
    tip.style.marginTop = "6px";
    tip.textContent = "Dica: d√™ duplo clique na cor para voltar ao padr√£o do tema.";
    box.appendChild(tip);
  }
  
  // chame isso junto do renderAliasesUI()
  renderFontLevelsUI();

  function renderAliasesUI(){
    aliasesBox.innerHTML="";
    const entries = Object.entries(settings.aliases).sort((a,b)=>a[0].localeCompare(b[0]));
    for(const [k,v] of entries){
      const row = document.createElement("div");
      row.className = "aliasItem";

      const inK = document.createElement("input");
      inK.value = k;

      const inV = document.createElement("input");
      inV.value = v;

      const btn = document.createElement("button");
      btn.textContent = "Salvar";
      btn.onclick = ()=>{
        const nk=(inK.value||"").trim();
        const nv=(inV.value||"").trim();
        if(!nk || !nv) return;
        if(nk !== k) delete settings.aliases[k];
        settings.aliases[nk]=nv;
        saveSettings();
        renderAliasesUI();
        printLine(`Alias salvo: ${nk} ‚Üí ${nv}`, "ok");
      };

      row.appendChild(inK);
      row.appendChild(inV);
      row.appendChild(btn);
      aliasesBox.appendChild(row);
    }
  }
  renderAliasesUI();

  $("btnAddAlias").addEventListener("click", ()=>{
    const k = prompt("Nome do alias:");
    if(!k) return;
    const v = prompt("Comando alvo:");
    if(!v) return;
    settings.aliases[k.trim()] = v.trim();
    saveSettings();
    renderAliasesUI();
    printLine(`Alias criado: ${k.trim()} ‚Üí ${v.trim()}`, "ok");
  });

  // ---------------- Sidebar ----------------
  function isExpanded(id){ return !!settings.sidebarExpanded[id]; }
  function toggleExpanded(id){
    settings.sidebarExpanded[id] = !isExpanded(id);
    saveSettings();
    renderSidebar();
  }

  const hoverExpandTimers = new Map();
  function scheduleExpand(dirId){
    if(isExpanded(dirId)) return;
    if(hoverExpandTimers.has(dirId)) return;
    const t = setTimeout(()=>{
      settings.sidebarExpanded[dirId] = true;
      saveSettings();
      renderSidebar();
      hoverExpandTimers.delete(dirId);
    }, 550);
    hoverExpandTimers.set(dirId, t);
  }
  function cancelExpand(dirId){
    const t = hoverExpandTimers.get(dirId);
    if(t){ clearTimeout(t); hoverExpandTimers.delete(dirId); }
  }

  function collapseAll(){
    settings.sidebarExpanded = { "root": false };
    saveSettings();
    renderSidebar();
  }
  function expandAll(){
    const map = {};
    state.nodes.filter(n => isDir(n) || isCMDBDir(n)).forEach(d => map[d.id] = true);
    settings.sidebarExpanded = map;
    saveSettings();
    renderSidebar();
  }
  btnCollapseAll.addEventListener("click", collapseAll);
  btnExpandAll.addEventListener("click", expandAll);

  function renderSidebar(){
    sidebarTree.innerHTML = "";
    const root = nodeById("root");
    if(!root) return;

    function sortKids(kids){
      return kids.slice().sort((a,b)=>{
        const aDir = isDir(a) || isCMDBDir(a);
        const bDir = isDir(b) || isCMDBDir(b);
        if(aDir!==bDir) return aDir ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
    }

    function addRow(node, depth){
      const row = document.createElement("div");
      row.className = "node" + (depth>0 ? " indent" : "");
      row.style.marginLeft = (depth*10) + "px";
      row.dataset.nodeId = node.id;

      row.dataset.depth = String(depth);

      row.draggable = (node.id !== "root");
      row.addEventListener("dragstart", (e)=>{
        row.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", node.id);
      });
      row.addEventListener("dragend", ()=>{
        row.classList.remove("dragging");
        sidebarTree.querySelectorAll(".dropTarget").forEach(x=>x.classList.remove("dropTarget"));
      });

      if(isDir(node) || isCMDBDir(node)){
        row.addEventListener("dragover", (e)=>{
          e.preventDefault();
          e.stopPropagation();
          e.dataTransfer.dropEffect = "move";
          row.classList.add("dropTarget");
          scheduleExpand(node.id);
        });

        row.addEventListener("dragleave", (e)=>{
          if(!row.contains(e.relatedTarget)){
            row.classList.remove("dropTarget");
            cancelExpand(node.id);
          }
        });

        row.addEventListener("drop", (e)=>{
          e.preventDefault();
          e.stopPropagation();
          row.classList.remove("dropTarget");
          cancelExpand(node.id);

          const srcId = e.dataTransfer.getData("text/plain");
          if(!srcId) return;

          const r = moveNodeToDir(srcId, node.id);
          if(!r.ok){
            printLine("drag/drop: " + r.err, "err");
            return;
          }
          printLine(`Movido para: ${fullPathOf(node.id)}`, "ok");
          renderSidebar();
        });
      }

      const caret = document.createElement("span");
      if(isDir(node) || isCMDBDir(node)){
        caret.textContent = isExpanded(node.id) ? "‚ñº" : "‚ñ∂";
        caret.style.width = "18px";
        caret.style.userSelect = "none";
        caret.onclick = (e) => { e.stopPropagation(); toggleExpanded(node.id); };
      } else {
        caret.textContent = " ";
        caret.style.width = "18px";
      }

      const icon = document.createElement("span");
      if(isCMDBDir(node)) icon.textContent = "üóÑÔ∏è";
      else if(isDir(node)) icon.textContent = "üìÅ";
      else if(isUrl(node)) icon.textContent = "üîó";
      else if(isApp(node)) icon.textContent = "üß©";
      else if(isConn(node)) icon.textContent = "üîå";
      else if(node.type==="flow") icon.textContent = "üß≠";
      else if(isConnRef(node)) icon.textContent = "üîó";
      else icon.textContent = "üìÑ";

      const name = document.createElement("span");
      name.className = "name";
      name.textContent = (isDir(node)||isCMDBDir(node)) ? (node.name + "/") : node.name;

// ---- Fonte por n√≠vel (somente pastas) ----
if(isDir(node) || isCMDBDir(node)){
  const lvl = Math.max(1, Math.min(5, depth)); // depth 1..5
  const cfg = settings.sidebarFontLevels && settings.sidebarFontLevels[lvl];
  if(cfg){
    name.style.fontSize = (cfg.size || 12) + "px";
    name.style.fontWeight = cfg.bold ? "700" : "400";
    name.style.fontStyle  = cfg.italic ? "italic" : "normal";
    name.style.color = (cfg.color && cfg.color.trim()) ? cfg.color : "";
  }
}

      if(isTask(node)){
        name.classList.add(taskColorClass(node));
      }
      if(isConn(node)){
        name.classList.add(connColorClass(node));
      }

      if(isConnRef(node)){
        const target = nodeById(node.refConnId);
        if(target && isConn(target)) name.classList.add(connColorClass(target));
        else name.classList.add("c-red");
      }

      row.appendChild(caret);
      row.appendChild(icon);
      row.appendChild(name);

      if(isDir(node) || isCMDBDir(node)){
        row.onclick = () => {
          state.cwdId = node.id;
          saveState();
          updateCwd();
          renderSidebar();
          printLine(`${cwdPath()} $ cd ${fullPathOf(node.id)}`, "cmd");
          printLine(`Agora em: ${cwdPath()}`, "muted");
          runCommand("pwd"); // ‚Üê ajuste para o nome real da sua fun√ß√£o
          runCommand("tree"); // ‚Üê ajuste para o nome real da sua fun√ß√£o

        };
        row.ondblclick = (e) => { e.stopPropagation(); toggleExpanded(node.id); };
      } else if(isUrl(node)){
        row.ondblclick = () => {
          if(node.url) window.open(node.url, "_blank", "noopener,noreferrer");
        };
      } 
      else if(isConnRef(node)) {
        row.ondblclick = () => {
          const target = nodeById(node.refConnId);
          if(target && isConn(target)){
            openModal(target.id);
            return;
          }
          // ‚úÖ ref quebrada: dblclick apaga a connref
          const r = removeNode(node.id);
          if(!r.ok) printLine("ref: " + r.err, "err");
          else printLine("Ref quebrada removida.", "ok");
          updateCwd();
          renderSidebar();
        };
      } else {
        row.ondblclick = () => openModal(node.id);
      }
        sidebarTree.appendChild(row);
        }

    function walk(dirId, depth){
      const kids = sortKids(childrenOf(dirId));
      for(const k of kids){
        addRow(k, depth);
        if((isDir(k) || isCMDBDir(k)) && isExpanded(k.id)){
          walk(k.id, depth+1);
        }
      }
    }

    if(settings.sidebarExpanded["root"] === undefined) settings.sidebarExpanded["root"] = true;

    addRow(root, 0);
    if(isExpanded("root")) walk("root", 1);

    sidebarTree.ondragover = (e)=> e.preventDefault();
    sidebarTree.ondrop = (e)=>{
      if(e.target && e.target.closest && e.target.closest(".node")) return;

      const srcId = e.dataTransfer.getData("text/plain");
      if(!srcId) return;

      const r = moveNodeToDir(srcId, "root");
      if(!r.ok) printLine("drag/drop: " + r.err, "err");
      else { printLine("Movido para: /", "ok"); renderSidebar(); }
    };
  }

  function appScopeHint(app){
    const cmdb = app?.cmdbId ? nodeById(app.cmdbId) : null;
  
    const dc  = ((cmdb?.datacenter || cmdb?.dc) || "(sem dc)").trim();
    const env = ((cmdb?.ambiente   || cmdb?.env) || "(sem env)").trim();
  
    // namespace √© atributo da inst√¢ncia (cmdb)
    const ns  = ((cmdb?.namespace) || "(sem ns)").trim();
  
    // ‚Äúinst√¢ncia‚Äù = o pr√≥prio CMDB/host (use o melhor campo que voc√™ tiver)
    const inst = (cmdb?.name || cmdb?.hostname || cmdb?.id || "(sem inst√¢ncia)").toString().trim();
  
    return `${dc} ‚Ä∫ ${env} ‚Ä∫ ${ns} ‚Ä∫ ${inst}`;
  }

  // ---------------- Autocomplete ----------------
  function getKnownScoped(){
    const items = itemsInScope(state.cwdId);

    const resps = Array.from(new Set(items.filter(n => isTask(n) || isUrl(n)).map(t=>(t.resp||"").trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    const types = Array.from(new Set(items.filter(isTask).map(t=>(t.taskType||"").trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    const dues  = Array.from(new Set(items.filter(n => isTask(n) || isUrl(n)).map(t=>(t.due||"").trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));

    const apps = allApps().slice().sort((a,b)=>a.name.localeCompare(b.name)); // <- mant√©m objeto

    return {
      resps, types, dues,
      statuses:["todo","doing","blocked","sequenciado","done"],
      prios:["1","2","3","4","5"],
      cmdbTags: CMDB_TAGS,
      appTags: APP_TAGS,
      connTags: CONN_TAGS,
      apps
    };
  }

  function currentToken(text, caret){
    const left = text.slice(0, caret);
    const m = left.match(/(^|[\s"])([^\s"]*)$/);
    return m ? m[2] : "";
  }

  function detectActiveTag(text, caret){
    const left = text.slice(0, caret);

    // detect any @tag from known pools
    const ALL = [...TAGS, ...CMDB_TAGS, ...APP_TAGS, ...CONN_TAGS];
    let best = { tag:null, idx:-1 };
    for(const t of ALL){
      const i = left.lastIndexOf(t);
      if(i > best.idx) best = { tag:t, idx:i };
    }
    if(best.idx < 0) return null;
    const after = left.slice(best.idx + best.tag.length);
    if(after.length && !/^\s/.test(after)) return null;
    return best.tag;
  }

  function showAC(items){
    ac.innerHTML="";
    if(!items.length){ ac.style.display="none"; return; }
    for(const it of items.slice(0,60)){
      const div = document.createElement("div");
      div.className="item";
      div.innerHTML = `<span class="a">${escapeHtml(it.label)}</span><span class="b">${escapeHtml(it.hint||"")}</span>`;
      div.onclick = ()=> applyAC(it.insert);
      ac.appendChild(div);
    }
    ac.style.display="block";
  }
  function hideAC(){ ac.style.display="none"; }

  function applyAC(insert){
    const text = cli.value;
    const caret = cli.selectionStart || 0;

    const left = text.slice(0, caret);
    const right = text.slice(caret);
    const m = left.match(/(^|[\s"])([^\s"]*)$/);
    const tokenStart = m ? (left.length - m[2].length) : caret;

    const before = text.slice(0, tokenStart);
    const after = right;
    const space = (after.startsWith(" ") || after==="") ? "" : " ";
    cli.value = before + insert + space + after;

    const newCaret = (before + insert + space).length;
    cli.setSelectionRange(newCaret, newCaret);
    hideAC();
    cli.focus();
  }

  function refreshAC(){
    const text = cli.value;
    const caret = cli.selectionStart || 0;
    const tok = currentToken(text, caret);
    const activeTag = detectActiveTag(text, caret);
    const known = getKnownScoped();

// autocomplete especial para flow
// autocomplete especial para flow (INSERE ID)
// autocomplete especial para flow
if(text.startsWith("flow")){
  const q = tok.replace(/^flow\s*/,"").replace(/^>/,"").toLowerCase();

  const apps = state.nodes.filter(isApp);

  const items = apps
    .filter(a => a.name.toLowerCase().includes(q))
    .map(a => ({
      label: a.name,                 // üëà continua limpo na lista
      insert: `${a.name}#${a.id}`,   // üëà INSERE nome#id no CLI
      hint: "app cmdb"
    }));

  showAC(items);
  return;
}

    if(tok.startsWith("@")){
      const q = tok.toLowerCase();
      const ALL = [...TAGS, ...CMDB_TAGS, ...APP_TAGS, ...CONN_TAGS];
      const items = ALL.filter(t=>t.toLowerCase().startsWith(q)).map(t=>({label:t, insert:t, hint:"tag"}));
      showAC(items);
      return;
    }

    if(activeTag){
      const q = (tok||"").toLowerCase();

      if(activeTag==="@resp"){
        const list = known.resps;
        const items = list.filter(v=>v.toLowerCase().includes(q)).map(v=>({label:v, insert:v, hint:"respons√°vel"}));
        showAC(items.length ? items : list.map(v=>({label:v, insert:v, hint:"respons√°vel"})));
        return;
      }
      if(activeTag==="@type"){
        const list = known.types;
        const items = list.filter(v=>v.toLowerCase().includes(q)).map(v=>({label:v, insert:v, hint:"tipo"}));
        showAC(items.length ? items : list.map(v=>({label:v, insert:v, hint:"tipo"})));
        return;
      }
      if(activeTag==="@due"){
        const list = known.dues;
        const items = list.filter(v=>v.toLowerCase().includes(q)).map(v=>({label:v, insert:v, hint:"due"}));
        if(items.length){ showAC(items); return; }
        showAC([{label:todayISODate(), insert:todayISODate(), hint:"hoje"}]);
        return;
      }
      if(activeTag==="@status"){
        const list = known.statuses;
        const items = list.filter(v=>v.toLowerCase().includes(q)).map(v=>({label:v, insert:v, hint:"status"}));
        showAC(items);
        return;
      }
      if(activeTag==="@prio"){
        const list = known.prios;
        const items = list.filter(v=>v.includes(q)).map(v=>({label:v, insert:v, hint:"prioridade"}));
        showAC(items);
        return;
      }

      // CMDB tags values: no auto list (livre)
      if(activeTag==="@hostname" || activeTag==="@ip" || activeTag==="@dc" || activeTag==="@env"){
        hideAC();
        return;
      }

if(activeTag==="@from" || activeTag==="@to"){
  const list = known.apps; // agora √© array de objetos app
  const ql = (q || "").toLowerCase();

  const filtered = list.filter(a=>{
    const name = (a?.name || "").toLowerCase();
    // se quiser tamb√©m buscar pelo caminho, descomente:
    // const hint = appScopeHint(a).toLowerCase();
    // return name.includes(ql) || hint.includes(ql);
    return name.includes(ql);
  });

  const base = (filtered.length ? filtered : list).slice(0, 120);

  const items = base.map(a=>{
    const name = a?.name || "(sem nome)";
    const port = a?.port ? `:${a.port}` : "";
    return {
      label: `${name}${port}`,
      insert: `"${name}#${a.id}"`,
      hint: appScopeHint(a)
    };
  });

  showAC(items);
  return;
}
      if(activeTag==="@port"){
        hideAC(); return;
      }
    }

    if(tok === ">" || tok.endsWith(">")){
      const apps = allApps().slice().sort((a,b)=>a.name.localeCompare(b.name));
      const items = apps.map(a => ({
        label: a.name,
        insert: ` ${a.name}`,
        hint: `cmdb:${nodeById(a.cmdbId)?.name || "-"}`,
      }));
      showAC(items);
      return;
    }


    hideAC();
  }

  cli.addEventListener("input", refreshAC);
  cli.addEventListener("blur", ()=> setTimeout(hideAC, 120));
  cli.addEventListener("keydown", (e)=>{
    if(e.key==="Tab" && ac.style.display==="block"){
      e.preventDefault();
      const first = ac.querySelector(".item");
      if(first) first.click();
      return;
    }
    if(e.key==="Escape"){ hideAC(); return; }

    if(e.key==="ArrowUp"){
      if(inputHistory.length){
        e.preventDefault();
        if(histIdx < 0) histIdx = inputHistory.length;
        histIdx = Math.max(0, histIdx-1);
        cli.value = inputHistory[histIdx] || "";
        cli.setSelectionRange(cli.value.length, cli.value.length);
        hideAC();
      }
      return;
    }
    if(e.key==="ArrowDown"){
      if(inputHistory.length){
        e.preventDefault();
        if(histIdx < 0) return;
        histIdx = Math.min(inputHistory.length, histIdx+1);
        cli.value = inputHistory[histIdx] || "";
        cli.setSelectionRange(cli.value.length, cli.value.length);
        hideAC();
      }
      return;
    }
    if(e.key==="Enter"){
      const cmd = cli.value;
      cli.value = "";
      hideAC();
      inputHistory.push(cmd);
      histIdx = -1;
      runCommand(cmd);
      return;
    }
    setTimeout(refreshAC, 0);
  });

  // ---------------- Top buttons ----------------
  $("btnCopy").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(lastOutputText.trim());
      printLine("Copiado.", "ok");
    }catch{
      printLine("Falha ao copiar (permiss√£o do navegador).", "err");
    }
  });

  $("btnExport").addEventListener("click", ()=>{
    const payload = { state, settings };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type:"application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "cli-projects-v9-export.json";
    a.click();
    URL.revokeObjectURL(a.href);
    printLine("Exportado.", "ok");
  });

  $("btnImport").addEventListener("click", ()=>{
    const inp = document.createElement("input");
    inp.type="file";
    inp.accept="application/json";
    inp.onchange = async ()=>{
      const file = inp.files && inp.files[0];
      if(!file) return;
      const txt = await file.text();
      try{
        const obj = JSON.parse(txt);
        if(obj.state && obj.state.nodes) state = obj.state;
        if(obj.settings) settings = obj.settings;
        settings.aliases = { ...defaultSettings().aliases, ...(settings.aliases||{}) };
        settings.sidebarExpanded = settings.sidebarExpanded || { "root": true };
        saveState(); saveSettings();
        setTheme();
        defPriority.value = String(settings.defPriority || 3);
        defStatus.value = settings.defStatus || "todo";
        renderAliasesUI();
        updateCwd();
        renderSidebar();
        printLine("Importado.", "ok");
      }catch{
        printLine("JSON inv√°lido.", "err");
      }
    };
    inp.click();
  });

  $("btnTheme").addEventListener("click", ()=>{
    settings.theme = (settings.theme==="light") ? "dark" : "light";
    saveSettings();
    setTheme();
  });

  $("btnReset").addEventListener("click", ()=>{
    if(!confirm("Resetar tudo?")) return;
    localStorage.removeItem(LS_KEY);
    localStorage.removeItem(SET_KEY);
    state = defaultState();
    settings = defaultSettings();
    saveState(); saveSettings();
    setTheme();
    defPriority.value = String(settings.defPriority);
    defStatus.value = settings.defStatus;
    renderAliasesUI();
    term.innerHTML = "";
    boot();
    renderSidebar();
  });

  // ---------------- Command runner ----------------
  function runCommand(raw){
    const trimmed = (raw||"").trim();
    if(!trimmed) return;

    clearOutBuf();
    echoCmd(trimmed);

    const head = tokenize(trimmed)[0];
    if(settings.aliases[head] && head !== "aliases"){
      const replaced = settings.aliases[head] + trimmed.slice(head.length);
      return runCommand(replaced);
    }

    const parts = tokenize(trimmed);
    const cmd = parts[0];
    const args = parts.slice(1);

    switch(cmd){
      case "help": cmd_help(); break;
      case "ls": cmd_ls(args); break;
      case "tree": cmd_tree(args); break;
      case "mkdir": cmd_mkdir(args); break;
      case "validate": cmd_validate(args); break;
      case "cd": cmd_cd(args); break;
      case "rm": cmd_rm(args); break;
      case "mv": cmd_mv(args); break;
      case "flow": cmd_flow(raw); break;
      case "add": cmd_add(trimmed); break;
      case "url": cmd_url(trimmed); break;
      case "mkcmdb": cmd_mkcmdb(trimmed); break;
      case "app": cmd_app(trimmed); break;
      case "operacao": cmd_operacao(raw); break;
      case "conn":
      if(args[0] === "pendentes" || args[0] === "testadas" || args[0] === "status"){
        cmd_conn_query(args);
      } else {
        cmd_conn(trimmed); // continua criando conectividade via @from/@to/@port
      }
      break;
      case "cmdb": cmd_cmdb(args); break;
      case "q": cmd_q(args); break;
      case "resumo": cmd_resumo(); break;
      case "@resp": cmd_at_resp(); break;
      case "focus": cmd_focus(); break;
      case "aliases": cmd_aliases(); break;
      case "pwd": cmd_pwd(); break;
      case "clear": cmd_clear(); break;
      default: printLine(`Comando n√£o reconhecido: ${cmd} (digite help)`, "err");
    }

    updateCwd();
    renderSidebar();
  }

  function cmd_operacao(raw){
    const name = raw.replace(/^operacao\s*/,"").trim();
    if(!name){
      printLine("Use: operacao nome-do-flow", "muted");
      return;
    }
  
    const flow = state.nodes.find(n => isFlow(n) && n.name === name);
    if(!flow){
      printLine(`Flow n√£o encontrado: ${name}`, "err");
      return;
    }
  
    const apps = flow.apps
      .map(id => state.nodes.find(n=>isApp(n) && n.id===id))
      .filter(Boolean);
  
    if(!apps.length){
      printLine("Flow sem apps v√°lidas.", "err");
      return;
    }
  
    flow.status = "executada";
    flow.updatedAt = nowISO();
  
    openFlowModal(apps);
  }

// ======== CONSULTAS DE CONECTIVIDADE (recursivo no escopo atual) ========
function connsInScope(scopeDirId){
    return state.nodes
      .filter(isConn)
      .filter(c => isDescendantOrSelf(c.parentId, scopeDirId));
  }
  
  function fmtConnLine(c){
    const fa = nodeById(c.fromAppId);
    const ta = nodeById(c.toAppId);
    const stCls = connColorClass(c);
    const fromCm = fa ? nodeById(fa.cmdbId) : null;
    const toCm = ta ? nodeById(ta.cmdbId) : null;
  
    const fromLabel = `${fromCm?fromCm.name:"-"}:${fa?fa.name:"-"}`;
    const toLabel   = `${toCm?toCm.name:"-"}:${ta?ta.name:"-"}`;
  
    return `üîå <span class="${stCls}">${escapeHtml(c.connStatus||"nao-testada")}</span> ` +
           `<span class="muted">${escapeHtml(fromLabel)} ‚Üí ${escapeHtml(toLabel)}:${escapeHtml(String(c.port||"-"))}</span>` +
           ` <span class="muted">${escapeHtml("(" + fullPathOf(c.id) + ")")}</span>`;
  }

  function renderConnAsHTML(c, icon="üîå"){
    const fa = nodeById(c.fromAppId);
    const ta = nodeById(c.toAppId);
    const stCls = connColorClass(c);
  
    const fromCm = fa ? nodeById(fa.cmdbId) : null;
    const toCm   = ta ? nodeById(ta.cmdbId) : null;
  
    const fromLabel = `${fromCm?fromCm.name:"-"}:${fa?fa.name:"-"}`;
    const toLabel   = `${toCm?toCm.name:"-"}:${ta?ta.name:"-"}`;
  
    // ‚úÖ mesma est√©tica sempre (status + ‚ÄúA ‚Üí B:porta‚Äù + path)
    return `${icon} <span class="${stCls}">${escapeHtml(c.connStatus||"nao-testada")}</span> ` +
           `<span class="clickable" data-open="${c.id}">${escapeHtml(fromLabel)} ‚Üí ${escapeHtml(toLabel)}:${escapeHtml(String(c.port||"-"))}</span>` +
           ` <span class="muted">${escapeHtml("(" + fullPathOf(c.id) + ")")}</span>`;
  }
  
  function cmd_conn_query(args){
    const mode = (args[0]||"").toLowerCase();
  
    let wanted = null;
    if(mode === "pendentes") wanted = "nao-testada";
    else if(mode === "testadas") wanted = "testada";
    else if(mode === "status") wanted = (args[1]||"").toLowerCase();
  
    if(!wanted || (wanted!=="nao-testada" && wanted!=="testada")){
      printLine("conn: uso: conn pendentes | conn testadas | conn status <nao-testada|testada>", "muted");
      return;
    }
  
    const all = connsInScope(state.cwdId);
    const list = all.filter(c => (c.connStatus||"nao-testada") === wanted)
                    .slice()
                    .sort((a,b)=>a.name.localeCompare(b.name));
  
    const title = wanted === "nao-testada"
      ? "Conectividades pendentes (n√£o-testadas)"
      : "Conectividades testadas";
  
    printLine(`${title} ‚Äî escopo atual, recursivo:`, "out");
    if(!list.length){ printLine("(nenhuma)", "muted"); return; }
  
    list.forEach(c => printHTMLLine("  " + fmtConnLine(c), "out"));
    attachDblClickHandlers();
  }

  function norm(s){
    return (s||"").toString().trim().toLowerCase();
  }
  
  function includesCI(hay, needle){
    const h = norm(hay);
    const n = norm(needle);
    if(!n) return false;
    return h.includes(n);
  }
  
  function cmdbFind(query){
    const q = (query||"").trim();
    if(!q){
      printLine("cmdb find: uso: cmdb find <trecho>", "muted");
      return;
    }
  
    // fontes
    const cmdbs = state.nodes.filter(isCMDBDir);
    const apps  = state.nodes.filter(isApp);
    const conns = state.nodes.filter(isConn);

    // match em campos relevantes (inclui namespace)
    const cmdbHits = cmdbs.filter(c =>
      includesCI(c.name, q) ||
      includesCI(c.hostname, q) ||
      includesCI(c.ip, q) ||
      includesCI(c.datacenter, q) ||
      includesCI(c.ambiente, q) ||
      includesCI(c.namespace, q)
    );
  
    const appHits = apps.filter(a => {
      const cm = nodeById(a.cmdbId);
      return (
        includesCI(a.name, q) ||
        includesCI(String(a.port||""), q) ||
        (cm && (
          includesCI(cm.name, q) ||
          includesCI(cm.datacenter, q) ||
          includesCI(cm.ambiente, q) ||
          includesCI(cm.namespace, q)
        ))
      );
    });
  
    const connHits = conns.filter(c => {
      const fa = nodeById(c.fromAppId);
      const ta = nodeById(c.toAppId);
      const fromCm = fa ? nodeById(fa.cmdbId) : null;
      const toCm   = ta ? nodeById(ta.cmdbId) : null;
  
      return (
        includesCI(c.name, q) ||
        includesCI(c.connStatus, q) ||
        includesCI(String(c.port||""), q) ||
        (fa && includesCI(fa.name, q)) ||
        (ta && includesCI(ta.name, q)) ||
        (fromCm && (
          includesCI(fromCm.name, q) ||
          includesCI(fromCm.datacenter, q) ||
          includesCI(fromCm.ambiente, q) ||
          includesCI(fromCm.namespace, q)
        )) ||
        (toCm && (
          includesCI(toCm.name, q) ||
          includesCI(toCm.datacenter, q) ||
          includesCI(toCm.ambiente, q) ||
          includesCI(toCm.namespace, q)
        ))
      );
    });
  
    // Agrupar por Datacenter > Ambiente > Namespace > Inst√¢ncia(CMDB)
    const tree = new Map(); // dc -> env -> ns -> cmdbId -> {cmdb, apps[], conns[]}
  
    function ensure(dc, env, ns, cmdb){
      const kdc  = dc || "(sem dc)";
      const kenv = env || "(sem ambiente)";
      const kns  = ns || "(sem namespace)";
  
      if(!tree.has(kdc)) tree.set(kdc, new Map());
      const envMap = tree.get(kdc);
  
      if(!envMap.has(kenv)) envMap.set(kenv, new Map());
      const nsMap = envMap.get(kenv);
  
      if(!nsMap.has(kns)) nsMap.set(kns, new Map());
      const instMap = nsMap.get(kns);
  
      if(!instMap.has(cmdb.id)) instMap.set(cmdb.id, { cmdb, apps: [], conns: [] });
      return instMap.get(cmdb.id);
    }
  
    // CMDB hits diretos
    for(const c of cmdbHits){
      ensure(c.datacenter, c.ambiente, c.namespace, c);
    }
  
    // apps hit (garante cmdb pai)
    for(const a of appHits){
      const cm = nodeById(a.cmdbId);
      if(!cm || !isCMDBDir(cm)) continue;
      const bucket = ensure(cm.datacenter, cm.ambiente, cm.namespace, cm);
      bucket.apps.push(a);
    }
  
    // conns hit (associa aos cmdbs de origem/destino e ao cmdbId do conn)
    for(const c of connHits){
      const fa = nodeById(c.fromAppId);
      const ta = nodeById(c.toAppId);
      const fromCm = fa ? nodeById(fa.cmdbId) : null;
      const toCm   = ta ? nodeById(ta.cmdbId) : null;
      const ownCm  = c.cmdbId ? nodeById(c.cmdbId) : null;
  
      const targets = [fromCm, toCm, ownCm].filter(x => x && isCMDBDir(x));
      const seen = new Set();
      for(const cm of targets){
        if(seen.has(cm.id)) continue;
        seen.add(cm.id);
        const bucket = ensure(cm.datacenter, cm.ambiente, cm.namespace, cm);
        bucket.conns.push(c);
      }
    }
  
    // render
    const dcs = Array.from(tree.keys()).sort((a,b)=>a.localeCompare(b));
    printLine(`CMDB find: "${q}"`, "out");
    if(!dcs.length){
      printLine("(nenhum resultado)", "muted");
      return;
    }
  
    for(const dc of dcs){
      printLine(`\n== Datacenter: ${dc} ==`, "muted");
  
      const envMap = tree.get(dc);
      const envs = Array.from(envMap.keys()).sort((a,b)=>a.localeCompare(b));
  
      for(const env of envs){
        printLine(`-- Ambiente: ${env}`, "muted");
  
        const nsMap = envMap.get(env);
        const nss = Array.from(nsMap.keys()).sort((a,b)=>a.localeCompare(b));
  
        for(const ns of nss){
          printLine(`   Namespace: ${ns}`, "muted");
  
          const instMap = nsMap.get(ns);
          const insts = Array.from(instMap.values()).sort((a,b)=> (a.cmdb.name||"").localeCompare(b.cmdb.name||""));
  
          for(const inst of insts){
            const c = inst.cmdb;
  
            // INST√ÇNCIA
            const meta = `host=${c.hostname||"-"} ip=${c.ip||"-"}`;
            printHTMLLine(
              `‚Ä¢ üóÑÔ∏è ${renderClickableName(c)} <span class="muted">${escapeHtml("{inst} " + meta + " ("+fullPathOf(c.id)+")")}</span>`,
              "out"
            );
  
            // APPS
            const appsList = inst.apps.slice().sort((x,y)=> (x.name||"").localeCompare(y.name||""));
            if(appsList.length){
              printLine("   Apps:", "muted");
              for(const a of appsList){
                printHTMLLine(
                  `     - üß© ${renderClickableName(a)} <span class="muted">${escapeHtml("{app} port="+(a.port||"-")+" ("+fullPathOf(a.id)+")")}</span>`,
                  "out"
                );
              }
            }
  
            // CONNS
            const uniqConn = (() => {
              const m = new Map();
              for(const x of inst.conns) m.set(x.id, x);
              return Array.from(m.values());
            })().sort((x,y)=> (x.name||"").localeCompare(y.name||""));
  
            if(uniqConn.length){
              printLine("   Conectividades:", "muted");
              for(const cn of uniqConn){
                printHTMLLine(`     - ${fmtConnLine(cn)}`, "out");
              }
            }
          }
        }
      }
    }
  
    attachDblClickHandlers();
  }

  // ---------------- Boot ----------------
  function boot(){
    updateCwd();
    printLine("Bem-vindo. Digite 'help' para ver comandos.", "muted");
    printLine("Exemplos CMDB:", "muted");
    printLine(`  mkcmdb srv01 @hostname srv01.local @ip 10.0.0.10 @dc DC1 @env prod`, "muted");
    printLine(`  app "orders-api" @port 8080`, "muted");
    printLine(`  cd ..`, "muted");
    printLine(`  mkcmdb srv02 @hostname srv02.local @ip 10.0.0.11 @dc DC1 @env prod`, "muted");
    printLine(`  app "db" @port 5432`, "muted");
    printLine(`  cd /infra/srv01`, "muted");
    printLine(`  conn @from "orders-api" @to "db" @port 5432 @status nao-testada`, "muted");
    printLine(`  cmdb rel`, "muted");
    printLine("", "muted");
    printLine("Exemplos tarefas:", "muted");
    printLine(`  mkdir app`, "muted");
    printLine(`  add "Implementar login" @resp Darlan @due ${todayISODate()} @status todo @type feature @prio 1`, "muted");
    printLine("  cmdb graph [errors|nao-testada]  (grafo DC/ENV/CMDB; portas IN/OUT; no modo normal, hover na app destaca conex√µes)", "muted");
  }

  // init
  setTheme();
  defPriority.value = String(settings.defPriority || 3);
  defStatus.value = settings.defStatus || "todo";
  saveState(); saveSettings();
  boot();
  renderSidebar();
})();
</script>
<!-- ===== GRAPH MODAL FULLSCREEN ===== -->
<div id="graphOverlay" style="
  position:fixed;
  inset:0;
  z-index:9999;
  background:rgba(0,0,0,0.88);
  display:none;
  flex-direction:column;
">

  <!-- HEADER -->
  <div style="
    height:48px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:0 16px;
    background:#0f1117;
    color:#fff;
    border-bottom:1px solid #222;
  ">
    <strong>CMDB ‚Äî Visualiza√ß√£o</strong>
    <button id="graphClose"
      style="background:#222;color:#fff;border:0;padding:6px 12px;border-radius:6px;cursor:pointer">
      ‚úï Fechar
    </button>
  </div>

  <!-- CANVAS -->
  <div id="graphViewport"
       style="flex:1; position:relative; overflow:hidden; background:#0b0f14;">
    <svg id="graphSvg"
         style="width:100%; height:100%; display:block;"></svg>
  </div>
</div>

<style>/* ===== FULLSCREEN GRAPH MODAL ===== */

  .modal.fullscreen {
    width: 100vw;
    height: 100vh;
    max-width: none;
    max-height: none;
    border-radius: 0;
    display: flex;
    flex-direction: column;
  }
  
  .modal .mh {
    flex: 0 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: var(--panel);
    border-bottom: 1px solid var(--line);
  }
  
  .graphViewport {
    flex: 1;
    overflow: hidden;
    position: relative;
    background: #0f1115;
    cursor: grab;
  }
  
  .graphViewport:active {
    cursor: grabbing;
  }
  
  #graphCanvas {
    position: absolute;
    inset: 0;
    transform-origin: 0 0;
  }
  
  #graphSvg {
    width: 3000px;
    height: 3000px;
  }
  
  /* Bot√µes */
  .mh .ghost {
    padding: 6px 10px;
    border-radius: 6px;
    background: #222;
    border: 1px solid #333;
    color: #eee;
    cursor: pointer;
  }
  .mh .ghost:hover {
    background: #333;
  }</style>
  

  <script>(function(){
    const overlay = document.getElementById("graphOverlay");
    const svg = document.getElementById("graphSvg");
    const viewport = document.getElementById("graphViewport");
  
    let view = { x:0, y:0, w:2000, h:1200 };
    let dragging = false;
    let last = {x:0,y:0};
  
    function applyView(){
      svg.setAttribute("viewBox", `${view.x} ${view.y} ${view.w} ${view.h}`);
    }
  
    function zoomAt(px, py, factor){
      const nx = view.x + (px / viewport.clientWidth) * view.w;
      const ny = view.y + (py / viewport.clientHeight) * view.h;
  
      view.w *= factor;
      view.h *= factor;
  
      view.x = nx - (px / viewport.clientWidth) * view.w;
      view.y = ny - (py / viewport.clientHeight) * view.h;
  
      applyView();
    }
  
    // Mouse wheel zoom
    viewport.addEventListener("wheel", e => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 1.1 : 0.9;
      zoomAt(e.offsetX, e.offsetY, factor);
    }, { passive:false });
  
    // Pan
    viewport.addEventListener("mousedown", e => {
      if(e.button !== 0) return;
      dragging = true;
      last = { x: e.clientX, y: e.clientY };
    });
  
    window.addEventListener("mousemove", e => {
      if(!dragging) return;
      const dx = e.clientX - last.x;
      const dy = e.clientY - last.y;
      last = { x: e.clientX, y: e.clientY };
      view.x -= dx * (view.w / viewport.clientWidth);
      view.y -= dy * (view.h / viewport.clientHeight);
      applyView();
    });
  
    window.addEventListener("mouseup", ()=> dragging = false);
  
    // API p√∫blica
    window.openGraph = function(){
      overlay.style.display = "flex";
      setTimeout(() => {
        view = { x:0, y:0, w:2000, h:1200 };
        applyView();
      }, 50);
    };
  
    document.getElementById("graphClose").onclick = () => {
      overlay.style.display = "none";
    };
  })();
    </script>



    <script>
    
      </script> 

    
</body>
</html>
