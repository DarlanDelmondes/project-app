<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CLI Projects — LocalStorage (v9 CMDB)</title>
    <style>
      :root {
        --bg: #0b0f19;
        --panel: #0f1627;
        --panel2: #111a2e;
        --text: #e8eefc;
        --muted: #9db0d1;
        --line: #243252;
        --accent: #7aa2ff;
        --ok: #55e6a5;
        --warn: #ffd36b;
        --danger: #ff6b6b;
        --blue: #65a8ff;
        --shadow: 0 14px 40px rgba(0, 0, 0, 0.45);
        --radius: 14px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
      }
      [data-theme="light"] {
        --bg: #f6f7fb;
        --panel: #ffffff;
        --panel2: #f3f5fb;
        --text: #0b1220;
        --muted: #4b5b78;
        --line: #d7deee;
        --accent: #2f6bff;
        --ok: #1a9b66;
        --warn: #b27b00;
        --danger: #d83a3a;
        --blue: #1e64ff;
        --shadow: 0 14px 40px rgba(9, 20, 45, 0.12);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: var(--sans);
      }
      .wrap {
        max-width: 2250px;
        margin: 18px auto;
        padding: 0 14px;
        display: grid;
        gap: 12px;
      }
      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.02)
        );
        box-shadow: var(--shadow);
      }
      .brand {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brand .t {
        font-weight: 900;
        letter-spacing: 0.2px;
      }
      .brand .s {
        color: var(--muted);
        font-size: 12px;
      }
      .actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      button {
        border: 1px solid var(--line);
        background: var(--panel2);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 750;
      }
      button:hover {
        border-color: rgba(122, 162, 255, 0.6);
      }
      .danger {
        border-color: rgba(255, 107, 107, 0.55);
        color: var(--danger);
      }
      .ghost {
        background: transparent;
      }
      .mini {
        padding: 6px 8px;
        border-radius: 10px;
        font-size: 12px;
      }

      .grid {
        display: grid;
        grid-template-columns: 0.52fr 1.48fr;
        gap: 12px;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        border: 1px solid var(--line);
        border-radius: var(--radius);
        background: var(--panel);
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      .card .hd {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .card .hd .left {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .card .hd .left .k {
        font-weight: 900;
      }
      .card .hd .left .v {
        color: var(--muted);
        font-size: 12px;
      }
      .card .bd {
        padding: 12px 14px;
      }

      .pill {
        font-family: var(--mono);
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        color: var(--muted);
        background: rgba(255, 255, 255, 0.03);
      }

      .terminal {
        font-family: var(--mono);
        font-size: 13px;
        line-height: 1.5;
        height: 830px;
        overflow: auto;
        padding: 12px;
        border-radius: 12px;
        background: radial-gradient(
            900px 420px at 10% 0%,
            rgba(122, 162, 255, 0.1),
            transparent 60%
          ),
          radial-gradient(
            900px 420px at 90% 0%,
            rgba(85, 230, 165, 0.08),
            transparent 55%
          ),
          rgba(0, 0, 0, 0.08);
        border: 1px solid var(--line);
      }
      .line {
        white-space: pre-wrap;
        word-break: break-word;
        margin: 0 0 6px 0;
      }
      .cmd {
        color: var(--text);
      }
      .out {
        color: var(--text);
      }
      .muted {
        color: var(--muted);
      }
      .err {
        color: var(--danger);
      }
      .ok {
        color: var(--ok);
      }
      .warn {
        color: var(--warn);
      }

      .c-red {
        color: var(--danger);
      }
      .c-yellow {
        color: var(--warn);
      }
      .c-blue {
        color: var(--blue);
      }
      .c-green {
        color: var(--ok);
      }

      .seqBadge {
        background: #ffffff;
        color: #000000 !important;
        font-weight: 900;
        padding: 1px 6px;
        border-radius: 8px;
      }

      .clickable {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-color: rgba(122, 162, 255, 0.45);
      }
      .clickable:hover {
        text-decoration-color: rgba(122, 162, 255, 0.9);
      }

      .inputrow {
        position: relative;
        display: flex;
        gap: 10px;
        align-items: center;
        margin-top: 10px;
      }
      .cli {
        width: 100%;
        padding: 12px 12px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: var(--panel2);
        color: var(--text);
        font-family: var(--mono);
        font-size: 13px;
        outline: none;
      }
      .cli:focus {
        border-color: rgba(122, 162, 255, 0.7);
        box-shadow: 0 0 0 4px rgba(122, 162, 255, 0.12);
      }

      .ac {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 46px;
        z-index: 20;
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 12px;
        box-shadow: var(--shadow);
        overflow: hidden;
        display: none;
        max-height: 280px;
        overflow: auto;
      }
      .ac .item {
        padding: 10px 10px;
        display: flex;
        justify-content: space-between;
        gap: 10px;
        cursor: pointer;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      [data-theme="light"] .ac .item {
        border-bottom: 1px solid rgba(10, 10, 10, 0.06);
      }
      .ac .item:last-child {
        border-bottom: none;
      }
      .ac .item:hover {
        background: rgba(122, 162, 255, 0.08);
      }
      .ac .a {
        font-family: var(--mono);
      }
      .ac .b {
        color: var(--muted);
        font-size: 12px;
      }

      .treeWrap {
        font-family: var(--mono);
        font-size: 12.5px;
        line-height: 1.45;
        height: 830px;
        overflow: auto;
        padding-right: 6px;
      }
      .node {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 6px 8px;
        border-radius: 10px;
        cursor: pointer;
        position: relative;
      }
      .node:hover {
        background: rgba(122, 162, 255, 0.08);
      }
      .node .name {
        flex: 1;
      }
      .indent {
        padding-left: 16px;
      }
      .node.dragging {
        opacity: 0.55;
      }

      .node.dropTarget {
        outline: 2px dashed rgba(122, 162, 255, 0.7);
        background: rgba(122, 162, 255, 0.1);
        padding-bottom: 18px;
      }
      .node.dropTarget::after {
        content: "Solte aqui para mover";
        position: absolute;
        left: 44px;
        bottom: 4px;
        font-size: 11px;
        color: var(--muted);
        font-family: var(--mono);
      }

      .drawerOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        display: none;
        align-items: flex-end;
        justify-content: center;
        padding: 16px;
        z-index: 60;
      }
      .drawer {
        width: min(980px, 100%);
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 18px;
        box-shadow: var(--shadow);
        overflow: hidden;
        max-height: 90vh;
        overflow-y: auto;
        padding-right: 8px; /* espaço pro scrollbar */
      }
      .drawer .dh {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }
      .drawer .db {
        padding: 12px 14px;
      }
      .kv {
        display: grid;
        gap: 10px;
      }
      .row2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      label {
        display: grid;
        gap: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      input,
      select,
      textarea {
        width: 100%;
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: var(--panel2);
        color: var(--text);
        outline: none;
        font-family: var(--sans);
      }
      textarea {
        min-height: 92px;
        resize: vertical;
      }
      .sep {
        height: 1px;
        background: var(--line);
        margin: 12px 0;
      }
      .aliasItem {
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 8px;
        align-items: center;
      }

      .modalOverlay {
        position: fixed;
        inset: 0;
        z-index: 99999;
        background: rgba(0, 0, 0, 0.55);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 18px;
        z-index: 80;
      }
      .modalOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.45);
        z-index: 99999;
        display: none;
      }
      .modal {
        z-index: 100000;
        width: min(980px, 100%);
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 18px;
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      .modal {
        z-index: 100000;
        position: relative;
      }
      .modal .mh {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }
      .modal .mh .title {
        font-weight: 950;
      }
      .modal .mb {
        padding: 12px 14px;
      }
      .modal .mf {
        padding: 12px 14px;
        border-top: 1px solid var(--line);
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        flex-wrap: wrap;
      }
      .row3 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
      }
      .badge {
        font-family: var(--mono);
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.03);
      }
      .hint {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="topbar">
        <div class="brand">
          <div class="t">CLI Projects — LocalStorage</div>
          <div class="s">
            Terminal + Árvore • <span class="pill" id="cwdPill">/</span>
          </div>
        </div>
        <div class="actions">
          <button id="btnCopy">Copiar saída</button>
          <button id="btnExport">Exportar</button>
          <button id="btnImport">Importar</button>
          <button id="btnConfig">Config</button>
          <button id="btnSaveGraph">Save Graph</button>
          <button id="btnTheme">Tema</button>
          <button class="danger" id="btnReset">Reset</button>
        </div>
      </div>

      <div class="grid">
        <div class="card">
          <div class="hd">
            <div class="left">
              <div class="k">Árvore</div>
              <div class="v">
                Rolável • Clique pasta = cd • ▶/▼ expande • Arraste e solte na
                pasta
              </div>
            </div>
            <div
              style="
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                align-items: center;
              "
            >
              <button class="mini" id="btnCollapseAll">Colapsar tudo</button>
              <button class="mini" id="btnExpandAll">Expandir tudo</button>
            </div>
          </div>
          <div class="bd">
            <div class="treeWrap" id="sidebarTree"></div>
          </div>
        </div>

        <div class="card">
          <div class="hd">
            <div class="left">
              <div class="k">Terminal</div>
              <div class="v">
                <span class="pill">help</span>
                <span class="pill">mkcmdb</span>
                <span class="pill">app</span>
                <span class="pill">conn</span>
                <span class="pill">cmdb rel</span>
                <span class="pill">focus</span>
                <span class="pill">resumo</span>
              </div>
            </div>
            <div class="left" style="text-align: right">
              <div class="k">Atalhos</div>
              <div class="v">↑/↓ histórico • Tab completa • Esc fecha</div>
            </div>
          </div>
          <div class="bd">
            <div class="terminal" id="term"></div>
            <div class="inputrow">
              <input
                class="cli"
                id="cli"
                autocomplete="off"
                spellcheck="false"
                placeholder="Digite um comando (ex: help)"
              />
              <div class="ac" id="ac"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Drawer config -->
      <div class="drawerOverlay" id="drawerOverlay">
        <div class="drawer">
          <div class="dh">
            <div style="display: flex; flex-direction: column; gap: 2px">
              <div style="font-weight: 950">Configurações</div>
              <div style="font-size: 12px; color: var(--muted)">
                Aliases e defaults
              </div>
              <!-- ===== Configuração de Fonte por Nível (Tree) ===== -->
              <div class="cfgBlock">
                <div class="cfgTitle">Fonte da Árvore (níveis)</div>

                <div id="fontLevelsBox" class="cfgGroup">
                  <!-- gerado via JS -->
                </div>
              </div>
            </div>
            <button class="ghost" id="btnCloseConfig">Fechar</button>
          </div>
          <div class="db">
            <div class="kv">
              <div class="row2">
                <label
                  >Prioridade padrão (1 alta, 5 baixa)
                  <select id="defPriority">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                  </select>
                </label>
                <label
                  >Status padrão
                  <select id="defStatus">
                    <option value="todo">todo</option>
                    <option value="doing">doing</option>
                    <option value="blocked">blocked</option>
                    <option value="sequenciado">sequenciado</option>
                    <option value="done">done</option>
                  </select>
                </label>
              </div>

              <div class="sep"></div>

              <div style="font-size: 12px; color: var(--muted)">
                <b>Aliases</b> (comando → execução)
              </div>
              <div id="aliases"></div>
              <button id="btnAddAlias">Adicionar alias</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Modal editor -->
      <div class="modalOverlay" id="modalOverlay">
        <div class="modal">
          <div class="mh">
            <div class="title" id="mTitle">Editar</div>
            <div style="display: flex; gap: 8px; align-items: center">
              <span class="badge" id="mPath"></span>
              <button class="ghost" id="mClose">Fechar</button>
            </div>
          </div>
          <div class="mb">
            <!-- Common -->
            <div class="row2">
              <label
                >Nome
                <input id="mName" />
              </label>
              <label
                >Pasta (caminho)
                <input id="mFolder" placeholder="/projetos/x" />
              </label>
            </div>

            <!-- TASK fields -->
            <div id="taskFields">
              <div class="row3" style="margin-top: 10px">
                <label
                  >Responsável
                  <input id="mResp" />
                </label>
                <label
                  >Data (due)
                  <input id="mDue" type="date" />
                </label>
                <label
                  >Tipo
                  <input id="mType" />
                </label>
              </div>

              <div class="row3" style="margin-top: 10px">
                <label
                  >Status
                  <select id="mStatus">
                    <option value="todo">todo</option>
                    <option value="doing">doing</option>
                    <option value="blocked">blocked</option>
                    <option value="sequenciado">sequenciado</option>
                    <option value="done">done</option>
                  </select>
                </label>
                <label
                  >Prioridade (1..5)
                  <select id="mPrio">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                  </select>
                </label>
                <label
                  >Atualizado em
                  <input id="mUpdated" disabled />
                </label>
              </div>

              <label style="margin-top: 10px"
                >Anotações
                <textarea id="mNotes"></textarea>
              </label>
            </div>

            <!-- URL fields -->
            <div id="urlFields" style="display: none; margin-top: 10px">
              <label
                >URL
                <input id="mUrl" placeholder="https://..." />
              </label>
              <div class="hint">Duplo clique no item abre em nova aba.</div>
            </div>

            <!-- CMDB fields -->
            <div id="cmdbFields" style="display: none; margin-top: 10px">
              <div class="row2">
                <label
                  >Hostname
                  <input id="mHost" />
                </label>
                <label
                  >IP
                  <input id="mIp" placeholder="10.0.0.10" />
                </label>
              </div>

              <div class="row2" style="margin-top: 10px">
                <label
                  >Datacenter
                  <input id="mDc" placeholder="DC1" />
                </label>
                <label
                  >Ambiente
                  <input id="mEnv" placeholder="prod|hml|dev" />
                </label>
              </div>

              <div class="row2" style="margin-top: 10px">
                <label
                  >Namespace
                  <input id="mNs" placeholder="payments|core|shared" />
                </label>
                <div></div>
              </div>

              <div class="hint">
                Esta pasta é do tipo <b>cmdb</b> e representa um host/servidor.
              </div>
            </div>

            <!-- APP fields -->
            <div id="appFields" style="display: none; margin-top: 10px">
              <div class="row2">
                <label
                  >Porta
                  <input id="mAppPort" type="number" min="1" max="65535" />
                </label>
                <label
                  >Ligado ao CMDB (somente leitura)
                  <input id="mAppCmdb" disabled />
                </label>
              </div>
            </div>

            <!-- CONN fields -->
            <div id="connFields" style="display: none; margin-top: 10px">
              <div class="row3">
                <label
                  >Origem (application)
                  <select id="mFrom"></select>
                </label>
                <label
                  >Destino (application)
                  <select id="mTo"></select>
                </label>
                <label
                  >Porta
                  <input id="mConnPort" type="number" min="1" max="65535" />
                </label>
              </div>
              <div class="row2" style="margin-top: 10px">
                <label
                  >Status conectividade
                  <select id="mConnStatus">
                    <option value="nao-testada">nao-testada</option>
                    <option value="testada">testada</option>
                    <option value="bloqueada">bloqueada</option>
                  </select>
                </label>
                <label
                  >Atualizado em
                  <input id="mConnUpdated" disabled />
                </label>
              </div>
              <div class="hint">
                A origem/destino são applications existentes (podem estar em
                qualquer CMDB).
              </div>
            </div>
          </div>

          <div class="mf">
            <button class="danger" id="mDelete">Excluir</button>
            <button id="mSave">Salvar</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const LS_KEY = "cli_projects_v9_state";
        const SET_KEY = "cli_projects_v9_settings";
        const $ = (id) => document.getElementById(id);

        const term = $("term");
        const cli = $("cli");
        const ac = $("ac");
        const cwdPill = $("cwdPill");
        const sidebarTree = $("sidebarTree");

        const drawerOverlay = $("drawerOverlay");
        const defPriority = $("defPriority");
        const defStatus = $("defStatus");
        const aliasesBox = $("aliases");

        const modalOverlay = $("modalOverlay");
        const mTitle = $("mTitle");
        const mPath = $("mPath");
        const mClose = $("mClose");
        const mName = $("mName");
        const mFolder = $("mFolder");

        // Task fields
        const taskFields = $("taskFields");
        const mResp = $("mResp");
        const mDue = $("mDue");
        const mType = $("mType");
        const mStatus = $("mStatus");
        const mPrio = $("mPrio");
        const mNotes = $("mNotes");
        const mUpdated = $("mUpdated");

        // URL fields
        const urlFields = $("urlFields");
        const mUrl = $("mUrl");

        // CMDB fields
        const cmdbFields = $("cmdbFields");
        const mHost = $("mHost");
        const mIp = $("mIp");
        const mNs = $("mNs");
        const mDc = $("mDc");
        const mEnv = $("mEnv");

        // APP fields
        const appFields = $("appFields");
        const mAppPort = $("mAppPort");
        const mAppCmdb = $("mAppCmdb");

        // CONN fields
        const connFields = $("connFields");
        const mFrom = $("mFrom");
        const mTo = $("mTo");
        const mConnPort = $("mConnPort");
        const mConnStatus = $("mConnStatus");
        const mConnUpdated = $("mConnUpdated");

        const mDelete = $("mDelete");
        const mSave = $("mSave");

        const btnCollapseAll = $("btnCollapseAll");
        const btnExpandAll = $("btnExpandAll");

        let editingId = null;
        let lastOutputText = "";
        let inputHistory = [];
        let histIdx = -1;

        // Tags gerais (tarefas)
        const TAGS = ["@resp", "@due", "@status", "@type", "@prio", "@note"];

        // Tags CMDB
        const CMDB_TAGS = ["@hostname", "@ip", "@dc", "@env"];

        // Tags app/conn
        const APP_TAGS = ["@port"];
        const CONN_TAGS = ["@from", "@to", "@port", "@status"];

        function nowISO() {
          return new Date().toISOString();
        }
        function rid() {
          return (
            Math.random().toString(16).slice(2) +
            Math.random().toString(16).slice(2)
          );
        }
        function pad(n) {
          return String(n).padStart(2, "0");
        }
        function todayISODate() {
          const d = new Date();
          return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(
            d.getDate()
          )}`;
        }
        function parseDateTS(dateStr) {
          if (!dateStr) return null;
          const t = Date.parse(dateStr + "T00:00:00");
          return isNaN(t) ? null : t;
        }
        function isoToDateOnly(iso) {
          return (iso || "").slice(0, 10);
        }
        function daysBetween(tsA, tsB) {
          return Math.floor((tsA - tsB) / (24 * 3600 * 1000));
        }

        function escapeHtml(s) {
          return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
        }

        function defaultState() {
          return {
            nodes: [
              {
                id: "root",
                type: "dir",
                name: "/",
                parentId: null,
                createdAt: nowISO(),
                updatedAt: nowISO(),
              },
              {
                id: rid(),
                type: "dir",
                name: "projetos",
                parentId: "root",
                createdAt: nowISO(),
                updatedAt: nowISO(),
              },
              {
                id: rid(),
                type: "dir",
                name: "infra",
                parentId: "root",
                createdAt: nowISO(),
                updatedAt: nowISO(),
              },
              {
                id: rid(),
                type: "negocio",
                name: "negocio",
                parentId: "root",
                createdAt: nowISO(),
                updatedAt: nowISO(),
              },
            ],
            cwdId: "root",
          };
        }

        function defaultSettings() {
          return {
            theme: "dark",
            defPriority: 3,
            defStatus: "todo",
            sidebarExpanded: { root: true },
            aliases: {
              hoje: "q hoje",
              atrasadas: "q atrasadas",
              "por-pessoa": "q por-pessoa",
              "sem-data": "q sem-data",
              "sem-resp": "q sem-resp",
              "sem-att": "q sem-att",
              "por-projeto": "q por-projeto",
              "sem-tipo": "q sem-tipo",
              "por-tipo": "q por-tipo",
              agora: "focus",
              r: "resumo",
              cm: "cmdb",
              rel: "cmdb rel",
            },
            sidebarFontLevels: {
              1: { size: 14, bold: true, italic: false, color: "" },
              2: { size: 13, bold: true, italic: false, color: "" },
              3: { size: 12, bold: false, italic: false, color: "" },
              4: { size: 12, bold: false, italic: true, color: "" },
              5: { size: 11, bold: false, italic: false, color: "" },
            },
          };
        }

        function loadJSON(key, fallback) {
          const raw = localStorage.getItem(key);
          if (!raw) return fallback;
          try {
            return JSON.parse(raw);
          } catch {
            return fallback;
          }
        }
        function saveState() {
          localStorage.setItem(LS_KEY, JSON.stringify(state));
        }
        function saveSettings() {
          localStorage.setItem(SET_KEY, JSON.stringify(settings));
        }

        let state = loadJSON(LS_KEY, defaultState());
        let settings = loadJSON(SET_KEY, defaultSettings());
        settings.aliases = {
          ...defaultSettings().aliases,
          ...(settings.aliases || {}),
        };
        settings.sidebarExpanded = settings.sidebarExpanded || { root: true };

        function setTheme() {
          document.documentElement.setAttribute(
            "data-theme",
            settings.theme === "light" ? "light" : "dark"
          );
        }

        function printLine(text, cls = "out") {
          const div = document.createElement("div");
          div.className = "line " + cls;
          div.textContent = text;
          term.appendChild(div);
          term.scrollTop = term.scrollHeight;
          lastOutputText += text + "\n";
        }
        function printHTMLLine(html, cls = "out") {
          const div = document.createElement("div");
          div.className = "line " + cls;
          div.innerHTML = html;
          term.appendChild(div);
          term.scrollTop = term.scrollHeight;
          const tmp = document.createElement("div");
          tmp.innerHTML = html;
          lastOutputText += (tmp.textContent || "") + "\n";
        }
        function clearOutBuf() {
          lastOutputText = "";
        }

        function nodeById(id) {
          return state.nodes.find((n) => n.id === id) || null;
        }
        function childrenOf(pid) {
          return state.nodes.filter((n) => n.parentId === pid);
        }

        function isDir(n) {
          return n && n.type === "dir";
        }
        function isCMDBDir(n) {
          return n && n.type === "cmdbdir";
        }
        function isTask(n) {
          return n && n.type === "file";
        }
        function isUrl(n) {
          return n && n.type === "url";
        }
        function isApp(n) {
          return n && n.type === "app";
        }
        function isConnRef(n) {
          return n && n.type === "connref";
        }
        function isConn(n) {
          return n && n.type === "conn";
        }

        const isBizDir = (n) => n && n.type === "biz";
        const isFlow = (n) => n && n.type === "flow";
        const isOperacao = (n) => n && n.type === "operacao";

        function isAnyItem(n) {
          return isTask(n) || isUrl(n) || isApp(n) || isConn(n) || isConnRef(n);
        }

        function cwdPath() {
          let cur = nodeById(state.cwdId) || nodeById("root");
          if (!cur) {
            state = defaultState();
            saveState();
            cur = nodeById("root");
          }
          if (cur.id === "root") return "/";
          const parts = [];
          while (cur && cur.id !== "root") {
            parts.push(cur.name);
            cur = nodeById(cur.parentId);
          }
          return "/" + parts.reverse().join("/");
        }
        function updateCwd() {
          cwdPill.textContent = cwdPath();
        }

        function fullPathOf(id) {
          const n = nodeById(id);
          if (!n) return "";
          if (n.id === "root") return "/";
          const parts = [];
          let cur = n;
          while (cur && cur.id !== "root") {
            parts.push(cur.name);
            cur = nodeById(cur.parentId);
          }
          return "/" + parts.reverse().join("/");
        }

        function resolvePath(pathStr) {
          if (!pathStr || pathStr === ".") return state.cwdId;
          let curId = pathStr.startsWith("/") ? "root" : state.cwdId;
          const parts = (pathStr.startsWith("/") ? pathStr.slice(1) : pathStr)
            .split("/")
            .filter(Boolean);

          for (const part of parts) {
            if (part === ".") continue;
            if (part === "..") {
              const cur = nodeById(curId);
              if (cur && cur.parentId) curId = cur.parentId;
              continue;
            }
            const next = childrenOf(curId).find((n) => n.name === part);
            if (!next) return null;
            curId = next.id;
          }
          return curId;
        }

        function splitParentAndName(pathStr) {
          const abs = pathStr.startsWith("/");
          const cleaned = pathStr.replace(/\/+$/, "");
          const parts = cleaned.split("/").filter(Boolean);
          const name = parts.pop() || "";
          const parentPath = (abs ? "/" : "") + parts.join("/");
          return { parentPath: parentPath || (abs ? "/" : "."), name };
        }

        function touch(id) {
          const n = nodeById(id);
          if (n) n.updatedAt = nowISO();
        }

        function createDir(name, parentId) {
          if (!name || name.includes("/"))
            return { ok: false, err: "Nome inválido." };
          if (childrenOf(parentId).some((n) => n.name === name))
            return { ok: false, err: "Já existe." };
          const n = {
            id: rid(),
            type: "dir",
            name,
            parentId,
            createdAt: nowISO(),
            updatedAt: nowISO(),
          };
          state.nodes.push(n);
          touch(parentId);
          saveState();
          return { ok: true, node: n };
        }

        function createCMDBDir(name, parentId, meta) {
          if (!name || name.includes("/"))
            return { ok: false, err: "Nome inválido." };
          if (childrenOf(parentId).some((n) => n.name === name))
            return { ok: false, err: "Já existe." };
          const n = {
            id: rid(),
            type: "cmdbdir",
            name,
            parentId,
            createdAt: nowISO(),
            updatedAt: nowISO(),
            hostname: meta.hostname || "",
            ip: meta.ip || "",
            datacenter: meta.dc || "",
            ambiente: meta.env || "",
          };
          state.nodes.push(n);
          touch(parentId);
          saveState();
          return { ok: true, node: n };
        }

        function createTaskFile(name, parentId, meta) {
          if (!name || name.includes("/"))
            return { ok: false, err: "Nome inválido." };
          if (childrenOf(parentId).some((n) => n.name === name))
            return { ok: false, err: "Já existe." };
          const f = {
            id: rid(),
            type: "file",
            name,
            parentId,
            createdAt: nowISO(),
            updatedAt: nowISO(),
            resp: meta.resp || "",
            due: meta.due || "",
            status: meta.status || settings.defStatus,
            taskType: meta.type || "",
            prio: Number(meta.prio || settings.defPriority),
            notes: meta.note || "",
          };
          state.nodes.push(f);
          touch(parentId);
          saveState();
          return { ok: true, node: f };
        }

        function createUrl(name, link, parentId, meta) {
          if (!name || name.includes("/"))
            return { ok: false, err: "Nome inválido." };
          if (!link || !/^https?:\/\//i.test(link))
            return { ok: false, err: "URL inválida (use http/https)." };
          if (childrenOf(parentId).some((n) => n.name === name))
            return { ok: false, err: "Já existe." };

          const u = {
            id: rid(),
            type: "url",
            name,
            parentId,
            createdAt: nowISO(),
            updatedAt: nowISO(),
            url: link,
            resp: meta.resp || "",
            due: meta.due || "",
            status: meta.status || settings.defStatus,
            taskType: meta.type || "",
            prio: Number(meta.prio || settings.defPriority),
            notes: meta.note || "",
          };
          state.nodes.push(u);
          touch(parentId);
          saveState();
          return { ok: true, node: u };
        }

        function nearestCMDBDirId(fromDirId) {
          let cur = nodeById(fromDirId);
          while (cur) {
            if (isCMDBDir(cur)) return cur.id;
            if (!cur.parentId) break;
            cur = nodeById(cur.parentId);
          }
          return null;
        }

        function createApp(name, parentId, meta) {
          if (!name || name.includes("/"))
            return { ok: false, err: "Nome inválido." };
          if (childrenOf(parentId).some((n) => n.name === name))
            return { ok: false, err: "Já existe." };

          const cmdbId = nearestCMDBDirId(parentId);
          if (!cmdbId)
            return {
              ok: false,
              err: "Crie applications dentro de uma pasta cmdb (mkcmdb ... e entre nela).",
            };
          const port = Number(meta.port || "");
          if (!(port >= 1 && port <= 65535))
            return { ok: false, err: "@port inválida (1..65535)." };

          const a = {
            id: rid(),
            type: "app",
            name,
            parentId,
            createdAt: nowISO(),
            updatedAt: nowISO(),
            port,
            cmdbId,
          };
          state.nodes.push(a);
          touch(parentId);
          saveState();
          return { ok: true, node: a };
        }

        function allApps() {
          return state.nodes.filter(isApp);
        }

        function findAppByName(name) {
          const n = (name || "").trim().toLowerCase();
          if (!n) return null;
          // tenta match exato primeiro
          const exact = allApps().find(
            (a) => (a.name || "").trim().toLowerCase() === n
          );
          if (exact) return exact;
          // fallback: contains único
          const hits = allApps().filter((a) =>
            (a.name || "").trim().toLowerCase().includes(n)
          );
          if (hits.length === 1) return hits[0];
          return null;
        }

        function parseAppRefToken(raw) {
          const s = (raw || "").toString().trim();
          if (!s) return { name: "", id: "" };

          // aceita "Nome#ID" (ID após o último #)
          const idx = s.lastIndexOf("#");
          if (idx > 0 && idx < s.length - 1) {
            return {
              name: s.slice(0, idx).trim(),
              id: s.slice(idx + 1).trim(),
            };
          }
          return { name: s, id: "" };
        }

        function resolveAppFromRefToken(raw) {
          const { name, id } = parseAppRefToken(raw);

          // 1) se vier ID e existir app com esse ID, usa
          if (id) {
            const byId = nodeById(id);
            if (byId && isApp(byId)) return byId;
          }

          // 2) fallback: tenta pelo name
          const byName = findAppByName(name);
          if (byName) return byName;

          // 3) fallback final: se o token inteiro for um id puro
          const maybeId = nodeById(raw);
          if (maybeId && isApp(maybeId)) return maybeId;

          return null;
        }

        function createConn(parentId, meta) {
          const cmdbId = nearestCMDBDirId(parentId);
          if (!cmdbId)
            return {
              ok: false,
              err: "Crie conectividades dentro de uma pasta cmdb.",
            };

          const fromRaw = meta.from || "";
          const toRaw = meta.to || "";

          const fromApp = resolveAppFromRefToken(fromRaw);
          const toApp = resolveAppFromRefToken(toRaw);

          if (!fromApp || !isApp(fromApp))
            return {
              ok: false,
              err: "@from precisa ser um application existente (nome#id, nome ou id).",
            };
          if (!toApp || !isApp(toApp))
            return {
              ok: false,
              err: "@to precisa ser um application existente (nome#id, nome ou id).",
            };
          const port = Number(meta.port || "");
          if (!(port >= 1 && port <= 65535))
            return { ok: false, err: "@port inválida (1..65535)." };

          const st = (meta.status || "nao-testada").toLowerCase();
          if (st !== "nao-testada" && st !== "testada" && st !== "bloqueada")
            return {
              ok: false,
              err: "@status deve ser nao-testada, testada ou bloqueada.",
            };

          const name = `${fromApp.name} -> ${toApp.name}:${port}`;
          if (childrenOf(parentId).some((n) => n.name === name))
            return {
              ok: false,
              err: "Já existe conectividade com esse nome na pasta.",
            };

          const c = {
            id: rid(),
            type: "conn",
            name,
            parentId,
            createdAt: nowISO(),
            updatedAt: nowISO(),
            fromAppId: fromApp.id,
            toAppId: toApp.id,
            port,
            connStatus: st,
            cmdbId,
          };
          state.nodes.push(c);
          touch(parentId);
          saveState();
          createCrossRefForConn(c, cmdbId);
          return { ok: true, node: c };
        }

        function connRefName(conn, fromApp, toApp) {
          // Nome estável: não inclui status para não “ficar desatualizado”
          return `[ref] ${fromApp.name} -> ${toApp.name}:${conn.port}`;
        }

        function existingConnRef(targetDirId, connId) {
          return (
            childrenOf(targetDirId).find(
              (n) => isConnRef(n) && n.refConnId === connId
            ) || null
          );
        }

        function createConnRef(targetDirId, conn) {
          const fromApp = nodeById(conn.fromAppId);
          const toApp = nodeById(conn.toAppId);
          if (!fromApp || !toApp)
            return { ok: false, err: "apps não encontrados" };

          if (existingConnRef(targetDirId, conn.id))
            return { ok: true, noop: true };

          const name = connRefName(conn, fromApp, toApp);
          // evita colisão por nome
          if (childrenOf(targetDirId).some((n) => n.name === name)) {
            // se colidir, só cria com sufixo curto
            const name2 = name + " #" + conn.id.slice(0, 4);
            if (childrenOf(targetDirId).some((n) => n.name === name2))
              return { ok: true, noop: true };
            return createConnRefNode(targetDirId, conn, name2);
          }
          return createConnRefNode(targetDirId, conn, name);
        }

        function createConnRefNode(targetDirId, conn, name) {
          const ref = {
            id: rid(),
            type: "connref",
            name,
            parentId: targetDirId,
            createdAt: nowISO(),
            updatedAt: nowISO(),
            refConnId: conn.id,
          };
          state.nodes.push(ref);
          touch(targetDirId);
          saveState();
          return { ok: true, node: ref };
        }

        /**
         * Regra que você pediu:
         * - Se a conectividade foi criada no cmdb da ORIGEM, cria ref no cmdb do DESTINO
         * - Se foi criada no cmdb do DESTINO, cria ref no cmdb da ORIGEM
         * - Se foi criada em outro cmdb (ou fora), cria refs em ambos (fallback seguro)
         */
        function createCrossRefForConn(conn, createdInCmdbId) {
          const fromApp = nodeById(conn.fromAppId);
          const toApp = nodeById(conn.toAppId);
          if (!fromApp || !toApp) return;

          const fromCmdbId = fromApp.cmdbId;
          const toCmdbId = toApp.cmdbId;

          if (!fromCmdbId || !toCmdbId) return;

          if (createdInCmdbId === fromCmdbId && toCmdbId !== fromCmdbId) {
            createConnRef(toCmdbId, conn);
            return;
          }
          if (createdInCmdbId === toCmdbId && fromCmdbId !== toCmdbId) {
            createConnRef(fromCmdbId, conn);
            return;
          }

          // fallback: cria nos dois lados quando não dá pra inferir “lado onde criou”
          if (fromCmdbId !== toCmdbId) {
            createConnRef(fromCmdbId, conn);
            createConnRef(toCmdbId, conn);
          }
        }

        function removeNode(id) {
          if (id === "root") return { ok: false, err: "Não pode." };

          const n = nodeById(id);
          if (!n)
            return {
              ok: false,
              err: "Ref não encontrada (id inválido ou já removida).",
            };

          if ((isDir(n) || isCMDBDir(n)) && childrenOf(id).length)
            return { ok: false, err: "Pasta não vazia (use rm -r)." };

          // se remover app, previne se tiver conn referenciando
          if (isApp(n)) {
            const used = state.nodes
              .filter(isConn)
              .some((c) => c.fromAppId === n.id || c.toAppId === n.id);
            if (used)
              return {
                ok: false,
                err: "Esse application está referenciado em conectividades. Remova/ajuste as conectividades antes.",
              };
          }

          const p = n.parentId;
          state.nodes = state.nodes.filter((x) => x.id !== id);
          touch(p);
          if (state.cwdId === id) state.cwdId = p || "root";
          saveState();
          return { ok: true };
        }

        function removeTree(id) {
          const n = nodeById(id);
          if (!n || id === "root") return { ok: false, err: "Não pode." };

          // bloqueia remover árvore se ela contém app referenciado fora? (simplificação: bloqueia se qualquer app dentro tem conn em qualquer lugar)
          const del = new Set();
          (function dfs(x) {
            del.add(x);
            for (const c of childrenOf(x)) dfs(c.id);
          })(id);

          const appsToDel = state.nodes
            .filter(isApp)
            .filter((a) => del.has(a.id));
          for (const a of appsToDel) {
            const used = state.nodes
              .filter(isConn)
              .some((c) => c.fromAppId === a.id || c.toAppId === a.id);
            if (used)
              return {
                ok: false,
                err: `Árvore contém application referenciado em conectividade (${a.name}). Remova/ajuste conectividades antes.`,
              };
          }

          const p = n.parentId;
          state.nodes = state.nodes.filter((x) => !del.has(x.id));
          touch(p);
          if (del.has(state.cwdId)) state.cwdId = p || "root";
          saveState();
          return { ok: true, count: del.size };
        }

        function moveNode(srcId, dstParentId, newName = null) {
          const src = nodeById(srcId);
          if (!src || srcId === "root")
            return { ok: false, err: "Origem inválida." };
          const nm = newName || src.name;
          if (
            childrenOf(dstParentId).some((n) => n.name === nm && n.id !== srcId)
          )
            return { ok: false, err: "Destino já tem esse nome." };
          const oldP = src.parentId;
          src.parentId = dstParentId;
          src.name = nm;
          src.updatedAt = nowISO();
          touch(oldP);
          touch(dstParentId);
          saveState();
          return { ok: true, node: src };
        }

        function isDescendantDir(targetDirId, maybeAncestorDirId) {
          if (targetDirId === maybeAncestorDirId) return true;
          let cur = nodeById(targetDirId);
          while (cur && cur.parentId) {
            if (cur.parentId === maybeAncestorDirId) return true;
            cur = nodeById(cur.parentId);
          }
          return false;
        }
        function canMove(srcId, dstDirId) {
          if (!srcId || !dstDirId) return { ok: false, err: "Move inválido." };
          if (srcId === "root")
            return { ok: false, err: "Não pode mover root." };

          const src = nodeById(srcId);
          const dst = nodeById(dstDirId);
          if (!src) return { ok: false, err: "Origem não existe." };
          if (!(isDir(dst) || isCMDBDir(dst)))
            return { ok: false, err: "Destino não é pasta." };

          if (src.parentId === dstDirId) return { ok: true, noop: true };

          if (
            (isDir(src) || isCMDBDir(src)) &&
            isDescendantDir(dstDirId, srcId)
          ) {
            return {
              ok: false,
              err: "Não pode mover uma pasta para dentro dela mesma.",
            };
          }

          if (
            childrenOf(dstDirId).some(
              (n) => n.name === src.name && n.id !== src.id
            )
          ) {
            return {
              ok: false,
              err: "Já existe um item com esse nome na pasta destino.",
            };
          }

          return { ok: true, noop: false };
        }
        function moveNodeToDir(srcId, dstDirId) {
          const chk = canMove(srcId, dstDirId);
          if (!chk.ok) return chk;
          if (chk.noop) return chk;

          const src = nodeById(srcId);
          const oldP = src.parentId;

          src.parentId = dstDirId;
          src.updatedAt = nowISO();

          // se app muda de cmdb, atualiza cmdbId
          if (isApp(src)) {
            const newCmdb = nearestCMDBDirId(dstDirId);
            if (newCmdb) src.cmdbId = newCmdb;
          }
          // se conn muda de cmdb, atualiza cmdbId
          if (isConn(src)) {
            const newCmdb = nearestCMDBDirId(dstDirId);
            if (newCmdb) src.cmdbId = newCmdb;
          }

          touch(oldP);
          touch(dstDirId);

          saveState();
          return { ok: true };
        }

        function tokenize(s) {
          const out = [];
          let cur = "";
          let inQ = false;
          for (let i = 0; i < s.length; i++) {
            const c = s[i];
            if (c === '"') {
              inQ = !inQ;
              continue;
            }
            if (!inQ && /\s/.test(c)) {
              if (cur) {
                out.push(cur);
                cur = "";
              }
            } else cur += c;
          }
          if (cur) out.push(cur);
          return out;
        }

        function promptPrefix() {
          return `${cwdPath()} $`;
        }
        function echoCmd(cmd) {
          printLine(`${promptPrefix()} ${cmd}`, "cmd");
        }

        function isDescendantOrSelf(nodeId, rootId) {
          if (nodeId === rootId) return true;
          let cur = nodeById(nodeId);
          while (cur && cur.parentId) {
            if (cur.parentId === rootId) return true;
            cur = nodeById(cur.parentId);
            if (cur && cur.id === rootId) return true;
          }
          return false;
        }
        function itemsInScope(scopeDirId) {
          return state.nodes
            .filter(isAnyItem)
            .filter((f) => isDescendantOrSelf(f.parentId, scopeDirId));
        }

        function sortByImportance(a, b) {
          const pa = Number(a.prio || 3),
            pb = Number(b.prio || 3);
          if (pa !== pb) return pa - pb;
          const ta = Date.parse(a.updatedAt || a.createdAt || nowISO());
          const tb = Date.parse(b.updatedAt || b.createdAt || nowISO());
          if (ta !== tb) return ta - tb;
          return a.name.localeCompare(b.name);
        }
        function groupBy(arr, keyFn) {
          const m = new Map();
          for (const x of arr) {
            const k = keyFn(x);
            if (!m.has(k)) m.set(k, []);
            m.get(k).push(x);
          }
          return m;
        }

        function taskColorClass(t) {
          const today = todayISODate();
          if ((t.status || "") === "sequenciado") return "seqBadge";
          if ((t.status || "") === "done") return "c-blue";
          if (t.due) {
            if (t.due < today) return "c-red";
            if (t.due === today) return "c-yellow";
          }
          return "c-green";
        }

        function connColorClass(c) {
          if (c.connStatus === "bloqueada") return "c-red";
          return c.connStatus === "testada" ? "c-blue" : "c-yellow";
        }

        function renderClickableName(node) {
          if (isUrl(node)) {
            return `<span class="clickable" data-url="${escapeHtml(
              node.url || ""
            )}">${escapeHtml(node.name)}</span>`;
          }
          if (isTask(node)) {
            const cls = taskColorClass(node);
            return `<span class="clickable ${cls}" data-open="${
              node.id
            }">${escapeHtml(node.name)}</span>`;
          }
          if (isCMDBDir(node) || isApp(node) || isConn(node)) {
            return `<span class="clickable" data-open="${node.id}">${escapeHtml(
              node.name
            )}</span>`;
          }
          return escapeHtml(node.name);
        }

        function attachDblClickHandlers() {
          term.querySelectorAll("[data-open]").forEach((elm) => {
            elm.ondblclick = () => openModal(elm.getAttribute("data-open"));
          });

          term.querySelectorAll("[data-url]").forEach((elm) => {
            elm.ondblclick = () => {
              const u = elm.getAttribute("data-url");
              if (u) window.open(u, "_blank", "noopener,noreferrer");
            };
          });

          // ✅ novo: duplo clique apaga connref quebrada
          term.querySelectorAll("[data-delref]").forEach((elm) => {
            elm.ondblclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              const id = elm.dataset.delref; // <- aqui
              if (!id) {
                printLine("ref: id vazio", "err");
                return;
              }

              const r = removeNode(id);
              if (!r.ok) printLine("ref: " + r.err, "err");
              else printLine("Ref quebrada removida.", "ok");

              updateCwd();
              renderSidebar();
            };
          });
        }

        function focusScore(t) {
          if ((t.status || "") === "done")
            return { score: -99999, reason: ["done"] };

          const today = todayISODate();
          const todayTS = parseDateTS(today);
          const dueTS = t.due ? parseDateTS(t.due) : null;

          let score = 0;
          const reason = [];

          const pr = Number(t.prio || 3);
          score += (6 - pr) * 25;
          reason.push(`prio p${pr} → +${(6 - pr) * 25}`);

          const st = t.status || "todo";
          if (st === "doing") {
            score += 20;
            reason.push("doing → +20");
          }
          if (st === "blocked") {
            score -= 30;
            reason.push("blocked → -30");
          }
          if (st === "sequenciado") {
            score += 35;
            reason.push("sequenciado → +35");
          }

          if (dueTS !== null) {
            const daysLate = Math.max(0, daysBetween(todayTS, dueTS));
            const daysAhead = Math.max(0, daysBetween(dueTS, todayTS));
            if (t.due < today) {
              const add = 140 + Math.min(200, daysLate * 18);
              score += add;
              reason.push(`atrasado ${daysLate}d → +${add}`);
            } else if (t.due === today) {
              score += 90;
              reason.push("vence hoje → +90");
            } else {
              const boost = Math.max(0, 60 - daysAhead * 12);
              score += boost;
              reason.push(`vence em ${daysAhead}d → +${boost}`);
            }
          } else {
            score -= 15;
            reason.push("sem due → -15");
          }

          const upd = Date.parse(t.updatedAt || t.createdAt || nowISO());
          const ageDays = Math.max(
            0,
            Math.floor((Date.now() - upd) / (24 * 3600 * 1000))
          );
          const staleBoost = Math.min(40, ageDays * 3);
          score += staleBoost;
          if (staleBoost)
            reason.push(`sem update ${ageDays}d → +${staleBoost}`);

          if (!(t.resp || "").trim()) {
            score -= 10;
            reason.push("sem resp → -10");
          }

          return { score, reason };
        }

        function cmd_focus() {
          const tasks = itemsInScope(state.cwdId)
            .filter(isTask)
            .filter((t) => (t.status || "") !== "done");
          if (!tasks.length) {
            printLine(
              "focus: nenhum item (task) pendente no escopo atual.",
              "muted"
            );
            return;
          }
          let best = null;
          let bestS = -1e9;
          let bestR = [];
          for (const t of tasks) {
            const { score, reason } = focusScore(t);
            if (score > bestS) {
              bestS = score;
              best = t;
              bestR = reason;
            }
          }
          printLine(
            "Seu foco agora (tarefas, escopo atual, recursivo):",
            "out"
          );
          printHTMLLine(
            "  " +
              fmtTaskLine(best) +
              ` <span class="muted">[score ${bestS}]</span>`,
            "out"
          );
          printLine("Motivo:", "muted");
          bestR.slice(0, 8).forEach((r) => printLine("  - " + r, "muted"));
          attachDblClickHandlers();
        }

        function cmd_help() {
          printLine("Comandos:", "out");
          printLine("  ls | ls -ltra", "muted");
          printLine("  mkdir <pasta>        (cria e entra)", "muted");
          printLine("  cd <pasta|/caminho|..>", "muted");
          printLine("  rm <caminho> | rm -r <pasta>", "muted");
          printLine("  mv <origem> <destino>", "muted");
          printLine("  tree [--depth N]", "muted");
          printLine(
            "  add <nome> @resp <x> @due <YYYY-MM-DD> @status <todo|doing|blocked|sequenciado|done> @type <...> @prio <1-5> @note <...>",
            "muted"
          );
          printLine('  url "Nome" https://site.com', "muted");
          printLine(
            "  mkcmdb <nome> @hostname X @ip 10.0.0.1 @dc DC1 @env prod   (cria pasta cmdb e entra)",
            "muted"
          );
          printLine(
            '  app "NomeApp" @port 8080   (cria application dentro de cmdb)',
            "muted"
          );
          printLine(
            '  conn @from "AppA" @to "AppB" @port 443 @status nao-testada|testada',
            "muted"
          );
          printLine("  cmdb | cmdb rel", "muted");
          printLine(
            "  q hoje | atrasadas | por-pessoa | sem-data | sem-resp | sem-att | por-projeto | sem-tipo | por-tipo | tipo <X>",
            "muted"
          );
          printLine("  resumo  (tarefas)", "muted");
          printLine("  @resp   (lista responsáveis)", "muted");
          printLine("  focus", "muted");
          printLine("  aliases | pwd | clear", "muted");
          printLine(
            "  conn pendentes | conn testadas | conn status <nao-testada|testada>",
            "muted"
          );
          printLine(
            "  cmdb graph [errors|nao-testada]  (grafo DC/ENV/CMDB; portas IN/OUT; no modo normal, hover na app destaca conexões)",
            "muted"
          );
          printLine(
            "  cmdb find <trecho>   (busca sem case-sensitive em CMDB, apps e conectividades)",
            "muted"
          );
          printLine(
            "  flow app1 > app2 > app3  — anima o fluxo no grafo",
            "muted"
          );
        }

        function cmd_pwd() {
          printLine(cwdPath(), "out");
        }
        function cmd_clear() {
          term.innerHTML = "";
        }

        function cmd_ls(args) {
          const flags = args.filter((a) => a.startsWith("-")).join("");
          const longFmt = flags.includes("l");
          const sortTime = flags.includes("t");
          const reverse = flags.includes("r");
          const showAll = flags.includes("a");

          let list = childrenOf(state.cwdId);
          if (!showAll) list = list.filter((n) => !n.name.startsWith("."));

          list.sort((a, b) => {
            if (sortTime)
              return (
                Date.parse(a.updatedAt || a.createdAt || nowISO()) -
                Date.parse(b.updatedAt || b.createdAt || nowISO())
              );
            return a.name.localeCompare(b.name);
          });
          if (reverse) list.reverse();

          if (!list.length) {
            printLine("(vazio)", "muted");
            return;
          }

          // curto
          if (!longFmt) {
            printLine(
              list
                .map((n) => {
                  if (isDir(n)) return `${n.name}/`;
                  if (isCMDBDir(n)) return `${n.name}{cmdb}/`;
                  if (isUrl(n)) return `${n.name}@`;
                  if (isApp(n)) return `${n.name}{app}`;
                  if (isConn(n)) return `${n.name}{conn}`;
                  if (isConnRef(n)) return `${n.name}{ref}`;
                  return n.name;
                })
                .join("  "),
              "out"
            );
            return;
          }

          // longo
          for (const n of list) {
            if (isDir(n)) {
              printLine(`d   ${isoToDateOnly(n.updatedAt)}  ${n.name}/`, "out");
              continue;
            }

            if (isCMDBDir(n)) {
              const meta = `host=${n.hostname || "-"} ip=${n.ip || "-"} dc=${
                n.datacenter || "-"
              } env=${n.ambiente || "-"}`;
              printHTMLLine(
                `C   ${escapeHtml(
                  isoToDateOnly(n.updatedAt)
                )}  ${renderClickableName(n)} <span class="muted">${escapeHtml(
                  "{cmdb} " + meta
                )}</span>`,
                "out"
              );
              continue;
            }

            if (isUrl(n)) {
              printHTMLLine(
                `@   ${escapeHtml(
                  isoToDateOnly(n.updatedAt)
                )}  🔗 ${renderClickableName(
                  n
                )} <span class="muted">${escapeHtml(
                  "(" + (n.url || "") + ")"
                )}</span>`,
                "out"
              );
              continue;
            }

            if (isApp(n)) {
              const cm = nodeById(n.cmdbId);
              const cmName = cm ? cm.name : "-";
              printHTMLLine(
                `A   ${escapeHtml(
                  isoToDateOnly(n.updatedAt)
                )}  ${renderClickableName(n)} <span class="muted">${escapeHtml(
                  "{app} port=" + (n.port || "-") + " cmdb=" + cmName
                )}</span>`,
                "out"
              );
              continue;
            }

            if (isConn(n)) {
              const fa = nodeById(n.fromAppId);
              const ta = nodeById(n.toAppId);
              const stCls = connColorClass(n);
              const st = n.connStatus || "nao-testada";
              printHTMLLine(
                `N   ${escapeHtml(
                  isoToDateOnly(n.updatedAt)
                )}  <span class="${stCls}">${escapeHtml(
                  st
                )}</span>  ${renderClickableName(n)} ` +
                  `<span class="muted">${escapeHtml(
                    "{conn} " +
                      (fa ? fa.name : "-") +
                      " -> " +
                      (ta ? ta.name : "-") +
                      ":" +
                      (n.port || "-")
                  )}</span>`,
                "out"
              );
              continue;
            }

            // ✅ connref “igualzinha” à conn (status/cor/texto), puxando do alvo
            if (isConnRef(n)) {
              const target = nodeById(n.refConnId);
              if (!target || !isConn(target)) {
                printHTMLLine(
                  `R   ${escapeHtml(isoToDateOnly(n.updatedAt))}  🔗 ` +
                    `<span class="clickable c-red" data-delref="${escapeHtml(
                      n.id
                    )}">ref quebrada (dblclick apaga)</span> ` +
                    `<span class="muted">{connref}</span> <span class="muted">id=${escapeHtml(
                      n.id
                    )}</span>`,
                  "out"
                );
              } else {
                printHTMLLine(
                  `R   ${escapeHtml(isoToDateOnly(n.updatedAt))}  ` +
                    fmtConnLine(target).replace("🔌", "🔗") +
                    ` <span class="muted">{connref}</span> <span class="muted">id=${escapeHtml(
                      n.id
                    )}</span>`,
                  "out"
                );
              }

              continue;
            }

            // fallback
            printHTMLLine(
              `-   ${escapeHtml(
                isoToDateOnly(n.updatedAt)
              )}  ${renderClickableName(n)}`,
              "out"
            );
          }

          attachDblClickHandlers();
        }

        function cmd_tree(args) {
          const maxDepth = (() => {
            const i = args.findIndex((a) => a === "--depth");
            if (i >= 0 && args[i + 1])
              return Math.max(1, parseInt(args[i + 1], 10) || 10);
            return 50;
          })();

          printLine(cwdPath(), "out");

          const lines = [];
          function walk(dirId, prefix, depth) {
            if (depth > maxDepth) return;
            const kids = childrenOf(dirId)
              .slice()
              .sort((a, b) => {
                const aDir = isDir(a) || isCMDBDir(a);
                const bDir = isDir(b) || isCMDBDir(b);
                if (aDir !== bDir) return aDir ? -1 : 1;
                return a.name.localeCompare(b.name);
              });
            kids.forEach((n, idx) => {
              const last = idx === kids.length - 1;
              const branch = last ? "└── " : "├── ";
              const nextPrefix = prefix + (last ? "    " : "│   ");
              if (isDir(n) || isCMDBDir(n)) {
                const suffix = isCMDBDir(n) ? "{cmdb}/" : "/";
                lines.push(
                  `${escapeHtml(prefix + branch)}${renderClickableName(
                    n
                  )} <span class="muted">${escapeHtml(suffix)}</span>`
                );
                walk(n.id, nextPrefix, depth + 1);
              } else if (isUrl(n)) {
                lines.push(
                  `${escapeHtml(prefix + branch)}🔗 ${renderClickableName(
                    n
                  )} <span class="muted">${escapeHtml(
                    "(" + (n.url || "") + ")"
                  )}</span>`
                );
              } else if (isApp(n)) {
                lines.push(
                  `${escapeHtml(prefix + branch)}🧩 ${renderClickableName(
                    n
                  )} <span class="muted">${escapeHtml(
                    "{app}:" + (n.port || "-")
                  )}</span>`
                );
              } else if (isConn(n)) {
                const stCls = connColorClass(n);
                lines.push(
                  `${escapeHtml(
                    prefix + branch
                  )}🔌 <span class="${stCls}">${escapeHtml(
                    n.connStatus || "nao-testada"
                  )}</span> ${renderClickableName(n)}`
                );
              } else if (isConnRef(n)) {
                const target = nodeById(n.refConnId);
                if (!target || !isConn(target)) {
                  lines.push(
                    `${escapeHtml(prefix + branch)}🔗 ` +
                      `<span class="clickable c-red" data-delref="${escapeHtml(
                        n.id
                      )}">ref quebrada (dblclick apaga)</span> ` +
                      `<span class="muted">{connref}</span>`
                  );
                } else {
                  const label = shortConnLabel(target);
                  lines.push(
                    `${escapeHtml(prefix + branch)}🔗 ` +
                      `<span class="clickable" data-openconn="${escapeHtml(
                        target.id
                      )}">${escapeHtml(label)}</span> ` +
                      `<span class="muted">{connref}</span>`
                  );
                }
              } else {
                lines.push(
                  `${escapeHtml(prefix + branch)}${renderClickableName(n)}`
                );
              }
            });
          }
          walk(state.cwdId, "", 1);
          if (!lines.length) printLine("(vazio)", "muted");
          else lines.forEach((l) => printHTMLLine(l, "out"));
          attachDblClickHandlers();
        }

        function shortConnLabel(conn) {
          const raw =
            conn?.title ||
            conn?.name ||
            conn?.label ||
            conn?.ref ||
            conn?.path ||
            conn?.url ||
            conn?.id ||
            "conn";

          const s = String(raw).trim();
          const noQ = s.split("?")[0].split("#")[0];

          // se parecer caminho/URL, pega o último segmento
          const parts = noQ.split("/").filter(Boolean);
          const last = parts.length ? parts[parts.length - 1] : noQ;

          return last.length > 28
            ? last.slice(0, 14) + "…" + last.slice(-10)
            : last;
        }

        function cmd_cd(args) {
          const target = args[0] || "/";
          const id = resolvePath(target);
          if (!id) {
            printLine(`cd: não encontrado: ${target}`, "err");
            return;
          }
          const n = nodeById(id);
          if (!(isDir(n) || isCMDBDir(n))) {
            printLine(`cd: não é pasta: ${target}`, "err");
            return;
          }
          state.cwdId = id;
          saveState();
          updateCwd();
          renderSidebar();
        }

        function cmd_mkdir(args) {
          if (!args[0]) {
            printLine("mkdir: faltou nome", "err");
            return;
          }
          const pathStr = args[0];
          const { parentPath, name } = splitParentAndName(pathStr);
          const parentId = resolvePath(parentPath);
          if (!parentId) {
            printLine(`mkdir: caminho inválido: ${parentPath}`, "err");
            return;
          }
          const p = nodeById(parentId);
          if (!(isDir(p) || isCMDBDir(p))) {
            printLine(`mkdir: não é pasta: ${parentPath}`, "err");
            return;
          }

          const r = createDir(name, parentId);
          if (!r.ok) {
            printLine("mkdir: " + r.err, "err");
            return;
          }

          state.cwdId = r.node.id; // entra automaticamente
          saveState();
          updateCwd();
          renderSidebar();
          printLine(`Agora em: ${cwdPath()}`, "muted");
        }

        function cmd_rm(args) {
          if (!args.length) {
            printLine("rm: uso: rm [-r] <caminho>", "err");
            return;
          }
          const recursive =
            args.includes("-r") || args.includes("-rf") || args.includes("-fr");
          const pathArg = args.find((a) => !a.startsWith("-"));
          if (!pathArg) {
            printLine("rm: faltou caminho", "err");
            return;
          }

          const id = resolvePath(pathArg);
          if (!id) {
            printLine(`rm: não encontrado: ${pathArg}`, "err");
            return;
          }

          const n = nodeById(id);
          if ((isDir(n) || isCMDBDir(n)) && recursive) {
            const r = removeTree(id);
            if (!r.ok) printLine("rm: " + r.err, "err");
            else printLine(`Removido (recursivo): ${r.count} nós`, "ok");
          } else {
            const r = removeNode(id);
            if (!r.ok) printLine("rm: " + r.err, "err");
            else printLine("Removido.", "ok");
          }

          updateCwd();
          renderSidebar();
        }

        function cmd_mv(args) {
          if (args.length < 2) {
            printLine("mv: uso: mv <origem> <destino>", "err");
            return;
          }
          const srcId = resolvePath(args[0]);
          if (!srcId) {
            printLine(`mv: origem não encontrada: ${args[0]}`, "err");
            return;
          }

          const dstId = resolvePath(args[1]);
          if (dstId) {
            const dst = nodeById(dstId);
            if (!(isDir(dst) || isCMDBDir(dst))) {
              printLine("mv: destino existe e não é pasta", "err");
              return;
            }
            const src = nodeById(srcId);
            if (
              (isDir(src) || isCMDBDir(src)) &&
              isDescendantDir(dstId, srcId)
            ) {
              printLine(
                "mv: não pode mover pasta para dentro dela mesma.",
                "err"
              );
              return;
            }
            const r = moveNode(srcId, dstId, null);
            if (!r.ok) printLine("mv: " + r.err, "err");
            updateCwd();
            renderSidebar();
            return;
          }

          const { parentPath, name } = splitParentAndName(args[1]);
          const parentId = resolvePath(parentPath);
          if (!parentId) {
            printLine(`mv: destino inválido: ${parentPath}`, "err");
            return;
          }
          const p = nodeById(parentId);
          if (!(isDir(p) || isCMDBDir(p))) {
            printLine(`mv: destino não é pasta: ${parentPath}`, "err");
            return;
          }

          const r = moveNode(srcId, parentId, name);
          if (!r.ok) printLine("mv: " + r.err, "err");
          updateCwd();
          renderSidebar();
        }

        function parseMetaFromTokens(tokens, startIndex, mapping) {
          // mapping: { "@tag": "fieldName" }
          const meta = {};
          let i = startIndex;
          while (i < tokens.length) {
            const tk = tokens[i];
            if (tk && tk.startsWith("@")) {
              const tag = tk;
              const val =
                tokens[i + 1] && !tokens[i + 1].startsWith("@")
                  ? tokens[i + 1]
                  : "";
              if (mapping[tag]) meta[mapping[tag]] = val;
              i += val ? 2 : 1;
            } else {
              i++;
            }
          }
          return meta;
        }

        function parseAdd(raw) {
          const tokens = tokenize(raw);
          let i = 1;
          const nameParts = [];
          const meta = {};
          while (i < tokens.length) {
            const tk = tokens[i];
            if (tk.startsWith("@")) {
              const tag = tk;
              const val =
                tokens[i + 1] && !tokens[i + 1].startsWith("@")
                  ? tokens[i + 1]
                  : "";
              if (tag === "@resp") meta.resp = val;
              else if (tag === "@due") meta.due = val;
              else if (tag === "@status") meta.status = val;
              else if (tag === "@type") meta.type = val;
              else if (tag === "@prio") meta.prio = val;
              else if (tag === "@note") meta.note = val;
              i += val ? 2 : 1;
            } else {
              nameParts.push(tk);
              i++;
            }
          }
          return { name: nameParts.join(" ").trim(), meta };
        }

        function cmd_add(raw) {
          const { name, meta } = parseAdd(raw);
          if (!name) {
            printLine(
              "add: uso: add <nome> @resp <pessoa> @due <YYYY-MM-DD> @status <...> @type <...> @prio <1-5> @note <...>",
              "muted"
            );
            return;
          }
          if (meta.due && !/^\d{4}-\d{2}-\d{2}$/.test(meta.due)) {
            printLine("add: @due deve ser YYYY-MM-DD", "err");
            return;
          }
          if (
            meta.prio &&
            !(Number(meta.prio) >= 1 && Number(meta.prio) <= 5)
          ) {
            printLine("add: @prio deve ser 1..5", "err");
            return;
          }
          const r = createTaskFile(name, state.cwdId, meta);
          if (!r.ok) printLine("add: " + r.err, "err");
          else printLine(`Criado: ${name}`, "ok");
          renderSidebar();
        }

        function cmd_url(raw) {
          const tokens = tokenize(raw);
          const name = tokens[1] || "";
          const link = tokens[2] || "";
          if (!name || !link) {
            printLine('url: uso: url "Nome" https://site.com', "muted");
            return;
          }
          const meta = parseMetaFromTokens(tokens, 3, {
            "@resp": "resp",
            "@due": "due",
            "@status": "status",
            "@type": "type",
            "@prio": "prio",
            "@note": "note",
          });
          if (meta.due && !/^\d{4}-\d{2}-\d{2}$/.test(meta.due)) {
            printLine("url: @due deve ser YYYY-MM-DD", "err");
            return;
          }
          if (
            meta.prio &&
            !(Number(meta.prio) >= 1 && Number(meta.prio) <= 5)
          ) {
            printLine("url: @prio deve ser 1..5", "err");
            return;
          }
          const r = createUrl(name, link, state.cwdId, meta);
          if (!r.ok) printLine("url: " + r.err, "err");
          else printLine(`Criado favorito: ${name}`, "ok");
          renderSidebar();
        }

        function cmd_mkcmdb(raw) {
          const tokens = tokenize(raw);
          const name = tokens[1] || "";
          if (!name) {
            printLine(
              "mkcmdb: uso: mkcmdb <nome> @hostname X @ip 10.0.0.1 @dc DC1 @env prod",
              "muted"
            );
            return;
          }
          const meta = parseMetaFromTokens(tokens, 2, {
            "@hostname": "hostname",
            "@ip": "ip",
            "@dc": "dc",
            "@env": "env",
          });
          const r = createCMDBDir(name, state.cwdId, meta);
          if (!r.ok) {
            printLine("mkcmdb: " + r.err, "err");
            return;
          }

          // entra automaticamente
          state.cwdId = r.node.id;
          saveState();
          updateCwd();
          renderSidebar();
          printLine(`CMDB criado e entrou: ${cwdPath()}`, "ok");
        }

        function cmd_app(raw) {
          const tokens = tokenize(raw);
          const name = tokens[1] || "";
          if (!name) {
            printLine('app: uso: app "NomeApp" @port 8080', "muted");
            return;
          }
          const meta = parseMetaFromTokens(tokens, 2, { "@port": "port" });
          const r = createApp(name, state.cwdId, meta);
          if (!r.ok) printLine("app: " + r.err, "err");
          else printLine(`Application criado: ${name}`, "ok");
          renderSidebar();
        }

        function cmd_conn(raw) {
          const tokens = tokenize(raw);
          const meta = parseMetaFromTokens(tokens, 1, {
            "@from": "from",
            "@to": "to",
            "@port": "port",
            "@status": "status",
          });
          const r = createConn(state.cwdId, meta);
          if (!r.ok) printLine("conn: " + r.err, "err");
          else printLine(`Conectividade criada: ${r.node.name}`, "ok");
          renderSidebar();
        }

        function cmd_at_resp() {
          const items = itemsInScope(state.cwdId).filter(
            (n) => isTask(n) || isUrl(n)
          );
          const resps = Array.from(
            new Set(items.map((t) => (t.resp || "").trim()).filter(Boolean))
          ).sort((a, b) => a.localeCompare(b));
          printLine(
            "Responsáveis (tarefas/urls, escopo atual, recursivo):",
            "out"
          );
          if (!resps.length) {
            printLine("(nenhum)", "muted");
            return;
          }
          resps.forEach((r) => printLine("  - " + r, "out"));
        }

        function fmtTaskLine(t) {
          const due = t.due || "-";
          const resp = t.resp || "-";
          const st = t.status || "todo";
          const pr = t.prio || 3;
          const type = t.taskType || "-";
          const base = `[p${pr}] [${st}] [${due}] [${resp}] [type:${type}] `;
          return `${escapeHtml(base)}${renderClickableName(
            t
          )} <span class="muted">${escapeHtml(
            "(" + fullPathOf(t.id) + ")"
          )}</span>`;
        }

        function cmd_q(args) {
          const mode = args[0] || "";
          const items = itemsInScope(state.cwdId);
          const today = todayISODate();

          const tasks = items.filter(isTask);

          if (mode === "hoje") {
            const t = tasks
              .filter((x) => x.due === today && x.status !== "done")
              .sort(sortByImportance);
            printLine("Atividades de hoje (recursivo):", "out");
            if (!t.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            t.forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            attachDblClickHandlers();
            return;
          }

          if (mode === "atrasadas") {
            const t = tasks
              .filter((x) => x.due && x.due < today && x.status !== "done")
              .sort(sortByImportance);
            const g = groupBy(t, (x) => fullPathOf(x.parentId));
            const keys = Array.from(g.keys()).sort((a, b) =>
              a.localeCompare(b)
            );
            printLine("Atrasadas por projeto (recursivo):", "out");
            if (!keys.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            for (const k of keys) {
              printLine("• " + k, "warn");
              g.get(k)
                .slice()
                .sort(sortByImportance)
                .forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            }
            attachDblClickHandlers();
            return;
          }

          if (mode === "por-pessoa") {
            const t = tasks
              .filter((x) => (x.resp || "").trim())
              .sort(sortByImportance);
            const g = groupBy(t, (x) => x.resp.trim());
            const people = Array.from(g.keys()).sort((a, b) =>
              a.localeCompare(b)
            );
            printLine("Atividades por pessoa (recursivo):", "out");
            if (!people.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            for (const p of people) {
              printLine("• " + p, "out");
              g.get(p)
                .slice()
                .sort(sortByImportance)
                .forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            }
            attachDblClickHandlers();
            return;
          }

          if (mode === "sem-data") {
            const t = tasks.filter((x) => !x.due).sort(sortByImportance);
            printLine("Sem data (recursivo):", "out");
            if (!t.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            t.forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            attachDblClickHandlers();
            return;
          }

          if (mode === "sem-resp") {
            const t = tasks
              .filter((x) => !(x.resp || "").trim())
              .sort(sortByImportance);
            printLine("Sem responsável (recursivo):", "out");
            if (!t.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            t.forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            attachDblClickHandlers();
            return;
          }

          if (mode === "sem-att") {
            const t = tasks
              .filter((x) => x.status !== "done")
              .slice()
              .sort((a, b) => {
                const ta = Date.parse(a.updatedAt || a.createdAt || nowISO());
                const tb = Date.parse(b.updatedAt || b.createdAt || nowISO());
                return ta - tb;
              })
              .slice(0, 30);
            printLine(
              "Mais antigas sem atualização (top 30, recursivo):",
              "out"
            );
            if (!t.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            t.forEach((x) =>
              printHTMLLine(
                "  " +
                  fmtTaskLine(x) +
                  ` <span class="muted">(upd ${escapeHtml(
                    isoToDateOnly(x.updatedAt)
                  )})</span>`,
                "out"
              )
            );
            attachDblClickHandlers();
            return;
          }

          if (mode === "por-projeto") {
            const t = tasks.slice().sort(sortByImportance);
            const g = groupBy(t, (x) => fullPathOf(x.parentId));
            const keys = Array.from(g.keys()).sort((a, b) =>
              a.localeCompare(b)
            );
            printLine("Atividades por projeto (recursivo):", "out");
            if (!keys.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            for (const k of keys) {
              printLine("• " + k, "out");
              g.get(k)
                .slice()
                .sort(sortByImportance)
                .forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            }
            attachDblClickHandlers();
            return;
          }

          if (mode === "sem-tipo") {
            const t = tasks
              .filter((x) => !(x.taskType || "").trim())
              .sort(sortByImportance);
            printLine("Sem tipo (recursivo):", "out");
            if (!t.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            t.forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            attachDblClickHandlers();
            return;
          }

          if (mode === "por-tipo") {
            const t = tasks.slice().sort(sortByImportance);
            const g = groupBy(
              t,
              (x) => (x.taskType || "").trim() || "(sem tipo)"
            );
            const keys = Array.from(g.keys()).sort((a, b) =>
              a.localeCompare(b)
            );
            printLine("Atividades por tipo (recursivo):", "out");
            if (!keys.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            for (const k of keys) {
              printLine("• " + k, "out");
              g.get(k)
                .slice()
                .sort(sortByImportance)
                .forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            }
            attachDblClickHandlers();
            return;
          }

          if (mode === "tipo") {
            const wanted = (args.slice(1).join(" ") || "").trim().toLowerCase();
            if (!wanted) {
              printLine("q tipo: uso: q tipo <nome-do-tipo>", "muted");
              return;
            }
            const t = tasks
              .filter((x) => (x.taskType || "").trim().toLowerCase() === wanted)
              .sort(sortByImportance);
            printLine(`Atividades do tipo "${wanted}" (recursivo):`, "out");
            if (!t.length) {
              printLine("(nenhuma)", "muted");
              return;
            }
            t.forEach((x) => printHTMLLine("  " + fmtTaskLine(x), "out"));
            attachDblClickHandlers();
            return;
          }

          printLine(
            "q: modos: hoje | atrasadas | por-pessoa | sem-data | sem-resp | sem-att | por-projeto | sem-tipo | por-tipo | tipo <X>",
            "muted"
          );
        }

        function cmd_resumo() {
          printLine("Resumo (tarefas, escopo atual, recursivo):", "out");
          const sections = [
            { title: "Hoje", run: () => cmd_q(["hoje"]) },
            {
              title: "Atrasadas (por projeto)",
              run: () => cmd_q(["atrasadas"]),
            },
            { title: "Por pessoa", run: () => cmd_q(["por-pessoa"]) },
            { title: "Sem data", run: () => cmd_q(["sem-data"]) },
            { title: "Sem responsável", run: () => cmd_q(["sem-resp"]) },
            {
              title: "Mais antigas sem atualização",
              run: () => cmd_q(["sem-att"]),
            },
            { title: "Por projeto", run: () => cmd_q(["por-projeto"]) },
            { title: "Sem tipo", run: () => cmd_q(["sem-tipo"]) },
            { title: "Por tipo", run: () => cmd_q(["por-tipo"]) },
          ];
          for (const s of sections) {
            printLine("", "out");
            printLine("==== " + s.title + " ====", "muted");
            s.run();
          }
        }

        function cmd_aliases() {
          printLine("Aliases:", "out");
          Object.entries(settings.aliases)
            .sort((a, b) => a[0].localeCompare(b[0]))
            .forEach(([k, v]) => printLine(`  ${k} → ${v}`, "muted"));
        }

        // --------- CMDB Views ----------
        function cmdbSummary() {
          const cmdbs = state.nodes
            .filter(isCMDBDir)
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name));
          const apps = state.nodes.filter(isApp);
          const conns = state.nodes.filter(isConn);

          printLine("CMDB — Visão hierárquica:", "out");
          printLine(
            `  CMDBs: ${cmdbs.length} | Apps: ${apps.length} | Conectividades: ${conns.length}`,
            "muted"
          );

          if (!cmdbs.length) {
            printLine(
              "  (nenhum cmdb ainda — use: mkcmdb srv01 @hostname ...)",
              "muted"
            );
            return;
          }

          // Deriva Namespace pela árvore (pastas acima da instância), se o node não tiver c.namespace.
          function deriveNamespace(cmdbNode) {
            if (cmdbNode && cmdbNode.namespace)
              return String(cmdbNode.namespace);

            // tenta montar algo a partir da hierarquia de pastas (parentId → parentId…)
            const names = [];
            let cur = cmdbNode;
            let guard = 0;

            while (cur && cur.parentId && guard++ < 50) {
              const p = nodeById(cur.parentId);
              if (!p) break;

              // Evita poluir com itens que não sejam pasta/diretório
              // (se seu modelo usa type "dir", ok; se não, ainda funciona)
              if (p.name && p.name !== "/" && p.name.toLowerCase() !== "root") {
                names.push(p.name);
              }
              cur = p;
            }

            names.reverse();

            // Heurística: muitas vezes o “namespace” é a pasta imediatamente acima da instância.
            // Se houver várias pastas acima, junta com "/".
            if (!names.length) return "default";
            return names.join(" / ");
          }

          // Agrupa: dc -> env -> ns -> [cmdb...]
          const bucket = new Map();

          function getOrCreate(map, key) {
            if (!map.has(key)) map.set(key, new Map());
            return map.get(key);
          }

          for (const c of cmdbs) {
            const dc = (c.datacenter || c.dc || "-").toString().trim() || "-";
            const env = (c.ambiente || c.env || "-").toString().trim() || "-";
            const ns = deriveNamespace(c);

            const envMap = getOrCreate(bucket, dc);
            const nsMap = getOrCreate(envMap, env);
            if (!nsMap.has(ns)) nsMap.set(ns, []);
            nsMap.get(ns).push(c);
          }

          // Ordenação “bonita”
          const sortKeys = (m) =>
            Array.from(m.keys()).sort((a, b) =>
              String(a).localeCompare(String(b))
            );

          for (const dc of sortKeys(bucket)) {
            printHTMLLine(`🏢 <b>${escapeHtml(dc)}</b>`, "out");
            const envMap = bucket.get(dc);

            for (const env of sortKeys(envMap)) {
              printHTMLLine(`&nbsp;&nbsp;🌿 <b>${escapeHtml(env)}</b>`, "out");
              const nsMap = envMap.get(env);

              for (const ns of sortKeys(nsMap)) {
                printHTMLLine(
                  `&nbsp;&nbsp;&nbsp;&nbsp;🧭 <b>${escapeHtml(ns)}</b>`,
                  "out"
                );

                const instances = nsMap
                  .get(ns)
                  .slice()
                  .sort((a, b) => a.name.localeCompare(b.name));

                for (const c of instances) {
                  const meta = `host=${c.hostname || "-"} ip=${c.ip || "-"}`;
                  printHTMLLine(
                    `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🧱 <b>${renderClickableName(
                      c
                    )}</b> <span class="muted">${escapeHtml(meta)}</span>`,
                    "out"
                  );

                  // Apps dentro da instância
                  const appsIn = apps
                    .filter((a) => a.cmdbId === c.id)
                    .slice()
                    .sort((a, b) => a.name.localeCompare(b.name));
                  if (appsIn.length) {
                    appsIn.forEach((a) => {
                      printHTMLLine(
                        `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🧩 ${renderClickableName(
                          a
                        )} <span class="muted">${escapeHtml(
                          "port=" + a.port
                        )}</span>`,
                        "out"
                      );
                    });
                  } else {
                    printHTMLLine(
                      `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="muted">- (sem apps)</span>`,
                      "out"
                    );
                  }

                  // Conectividades relacionadas (origem/destino ou cmdbId direto)
                  const connsRelated = conns.filter((n) => {
                    const fa = nodeById(n.fromAppId);
                    const ta = nodeById(n.toAppId);
                    return (
                      (fa && fa.cmdbId === c.id) ||
                      (ta && ta.cmdbId === c.id) ||
                      n.cmdbId === c.id
                    );
                  });

                  if (connsRelated.length) {
                    connsRelated
                      .slice()
                      .sort((x, y) => x.name.localeCompare(y.name))
                      .forEach((n) => {
                        const fa = nodeById(n.fromAppId);
                        const ta = nodeById(n.toAppId);
                        const stCls = connColorClass(n);

                        // Porta exibida: a do DESTINO (como você definiu)
                        const port = n.port ?? (ta && ta.port) ?? "-";

                        printHTMLLine(
                          `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🔌 <span class="${stCls}">${escapeHtml(
                            n.connStatus || "nao-testada"
                          )}</span> <span class="muted">${escapeHtml(
                            (fa ? fa.name : "-") +
                              " → " +
                              (ta ? ta.name : "-") +
                              ":" +
                              port
                          )}</span>`,
                          "out"
                        );
                      });
                  } else {
                    printHTMLLine(
                      `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="muted">- (sem conectividades)</span>`,
                      "out"
                    );
                  }
                }
              }
            }
          }

          attachDblClickHandlers();
        }

        function cmdbRelations() {
          const cmdbs = state.nodes
            .filter(isCMDBDir)
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name));
          const conns = state.nodes.filter(isConn);

          printLine("CMDB — Relações (grafo):", "out");
          if (!cmdbs.length) {
            printLine("(nenhum cmdb)", "muted");
            return;
          }
          if (!conns.length) {
            printLine("(nenhuma conectividade)", "muted");
            return;
          }

          // agrupa por cmdb (pelo cmdbId do conn)
          const g = groupBy(conns, (c) => c.cmdbId || "(sem-cmdb)");
          const keys = Array.from(g.keys()).sort((a, b) =>
            String(a).localeCompare(String(b))
          );

          for (const k of keys) {
            const cm = nodeById(k);
            printLine("• " + (cm ? cm.name : k), "out");
            g.get(k).forEach((c) => {
              const fa = nodeById(c.fromAppId);
              const ta = nodeById(c.toAppId);
              const stCls = connColorClass(c);
              const fromCm = fa ? nodeById(fa.cmdbId) : null;
              const toCm = ta ? nodeById(ta.cmdbId) : null;
              const fromLabel = `${fromCm ? fromCm.name : "-"}:${
                fa ? fa.name : "-"
              }`;
              const toLabel = `${toCm ? toCm.name : "-"}:${ta ? ta.name : "-"}`;

              printHTMLLine(
                `   - 🔌 <span class="${stCls}">${escapeHtml(
                  c.connStatus || "nao-testada"
                )}</span> <span class="muted">${escapeHtml(
                  fromLabel
                )} → ${escapeHtml(toLabel)}:${escapeHtml(
                  String(c.port || "-")
                )}</span>`,
                "out"
              );
            });
          }
          attachDblClickHandlers();
        }

        function cmd_cmdb(args) {
          const sub = (args[0] || "").toLowerCase();

          if (sub === "rel") return cmdbRelations();

          if (sub === "graph") {
            const mode = (args[1] || "").toLowerCase();
            if (mode === "bloqueada") return openGraph("bloqueada");
            if (mode === "testada") return openGraph("testada");
            if (mode === "nao-testada") return openGraph("nao-testada");
            return openGraph("hover");
          }

          if (sub === "find") {
            const q = (args.slice(1).join(" ") || "").trim();
            return cmdbFind(q);
          }

          return cmdbSummary();
        }

        function openGraph(mode = "hover") {
          const overlay = document.getElementById("graphOverlay");
          const svg = document.getElementById("graphSvg");
          const close = document.getElementById("graphClose");

          overlay.style.display = "flex";

          close.onclick = () => (overlay.style.display = "none");
          overlay.onclick = (e) => {
            if (e.target === overlay) overlay.style.display = "none";
          };

          renderGraph(svg, mode);
        }

        function svgEl(tag, attrs = {}) {
          const el = document.createElementNS(
            "http://www.w3.org/2000/svg",
            tag
          );
          for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
          return el;
        }

        /* =========================================================
   FLOW VIEW — SVG INFINITO + ANIMAÇÃO SEQUENCIAL (HIERÁRQUICO)
   Datacenter → Ambiente → Instância → App
   ========================================================= */

        /* ---------- Modal SVG ---------- */
        /* ================= FLOW MODAL (SVG) + PAN (ARRASTAR) + ZOOM (WHEEL) ================= */
        (function () {
          if (document.getElementById("flowOverlay")) return;

          const overlay = document.createElement("div");
          overlay.id = "flowOverlay";
          overlay.style.cssText = `
      position:fixed; inset:0; z-index:99999;
      background:rgba(0,0,0,.65);
      display:none;
    `;

          overlay.innerHTML = `
      <div style="
        position:absolute; inset:20px;
        background:#0b0f19;
        border-radius:16px;
        display:flex; flex-direction:column;
        overflow:hidden;
      ">
        <div style="
          padding:12px 16px;
          border-bottom:1px solid rgba(255,255,255,.1);
          display:flex; justify-content:space-between; align-items:center;
        ">
          <strong>Flow — Animação de Operação</strong>
          <button id="flowClose" class="ghost">Fechar</button>
        </div>
  
        <!-- viewport: SEM scrollbars; navegação via arrasto + zoom -->
        <div id="flowViewport" style="
          flex:1;
          overflow:hidden;
          position:relative;
          cursor:grab;
          overscroll-behavior:contain;
          touch-action:none;
        ">
          <svg id="flowSvg" width="8000" height="1400" style="display:block;"></svg>
        </div>
      </div>
    `;

          document.body.appendChild(overlay);

          const svg = document.getElementById("flowSvg");
          const viewport = document.getElementById("flowViewport");

          // ---------- Pan/Zoom state (via viewBox) ----------
          const st = {
            vbX: 0,
            vbY: 0,
            vbW: Number(svg.getAttribute("width")) || 8000,
            vbH: Number(svg.getAttribute("height")) || 1400,
            minZoom: 0.2, // 20%
            maxZoom: 4.0, // 400%
            dragging: false,
            dragStart: null, // {x,y,vbX,vbY}
          };

          function applyViewBox() {
            svg.setAttribute(
              "viewBox",
              `${st.vbX} ${st.vbY} ${st.vbW} ${st.vbH}`
            );
          }

          // converte coordenada de mouse para espaço do viewBox atual
          function clientToVb(clientX, clientY) {
            const r = svg.getBoundingClientRect();
            const sx = (clientX - r.left) / (r.width || 1);
            const sy = (clientY - r.top) / (r.height || 1);
            return { x: st.vbX + sx * st.vbW, y: st.vbY + sy * st.vbH };
          }

          // init viewBox
          applyViewBox();

          // ---------- PAN (arrastar) ----------
          viewport.addEventListener("pointerdown", (e) => {
            // arrasta com botão esquerdo / toque
            if (e.button !== undefined && e.button !== 0) return;

            st.dragging = true;
            viewport.style.cursor = "grabbing";

            const p = clientToVb(e.clientX, e.clientY);
            st.dragStart = { x: p.x, y: p.y, vbX: st.vbX, vbY: st.vbY };

            viewport.setPointerCapture?.(e.pointerId);
            e.preventDefault();
          });

          viewport.addEventListener("pointermove", (e) => {
            if (!st.dragging || !st.dragStart) return;

            const p = clientToVb(e.clientX, e.clientY);
            const dx = p.x - st.dragStart.x;
            const dy = p.y - st.dragStart.y;

            st.vbX = st.dragStart.vbX - dx;
            st.vbY = st.dragStart.vbY - dy;

            applyViewBox();
            e.preventDefault();
          });

          function endDrag() {
            st.dragging = false;
            st.dragStart = null;
            viewport.style.cursor = "grab";
          }
          viewport.addEventListener("pointerup", endDrag);
          viewport.addEventListener("pointercancel", endDrag);
          viewport.addEventListener("pointerleave", endDrag);

          // ---------- ZOOM (wheel) ----------
          viewport.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();

              // zoom com wheel: para cima aproxima, para baixo afasta
              const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;

              // zoom atual baseado em vbW vs base width
              const baseW = Number(svg.getAttribute("width")) || 8000;
              const currentZoom = baseW / st.vbW;
              let nextZoom = currentZoom / zoomFactor;

              // clamp zoom
              nextZoom = Math.max(st.minZoom, Math.min(st.maxZoom, nextZoom));

              // calcula novo vbW/vbH
              const newVbW = baseW / nextZoom;
              const baseH = Number(svg.getAttribute("height")) || 1400;
              const newVbH = baseH / nextZoom;

              // mantém o ponto do mouse “fixo” durante o zoom
              const before = clientToVb(e.clientX, e.clientY);

              // atualiza tamanho
              st.vbW = newVbW;
              st.vbH = newVbH;

              // reposiciona viewBox para manter o mesmo ponto
              const after = clientToVb(e.clientX, e.clientY);
              st.vbX += before.x - after.x;
              st.vbY += before.y - after.y;

              applyViewBox();
            },
            { passive: false }
          );

          // ---------- Close ----------
          document.getElementById("flowClose").onclick = () => {
            overlay.style.display = "none";
            svg.innerHTML = "";
            // reset viewBox ao fechar (opcional)
            st.vbX = 0;
            st.vbY = 0;
            st.vbW = Number(svg.getAttribute("width")) || 8000;
            st.vbH = Number(svg.getAttribute("height")) || 1400;
            applyViewBox();
          };

          // expõe um helper opcional para você chamar após render
          window.__flowPanZoomReset = function () {
            st.vbX = 0;
            st.vbY = 0;
            st.vbW = Number(svg.getAttribute("width")) || 8000;
            st.vbH = Number(svg.getAttribute("height")) || 1400;
            applyViewBox();
          };
        })();

        /* ---------- helpers ---------- */

        function ensureNegocioDir() {
          let dir = state.nodes.find(
            (n) => isDir(n) && n.name === "negocio" && n.parentId === "root"
          );

          if (!dir) {
            dir = {
              id: rid(),
              type: "dir",
              name: "negocio",
              parentId: "root",
              createdAt: nowISO(),
              updatedAt: nowISO(),
            };
            state.nodes.push(dir);
          }

          return dir;
        }

        function getNegocioDir() {
          return state.nodes.find(
            (n) => n.type === "negocio" && n.parentId === "root"
          );
        }

        function flowConnStyle(fromApp, toApp) {
          const conn = state.nodes.find(
            (n) =>
              isConn(n) && n.fromAppId === fromApp.id && n.toAppId === toApp.id
          );

          if (!conn) {
            return { color: "#ffffff", dash: "6 6", width: 2 };
          }

          const st = conn.connStatus || "nao-testada";
          if (st === "bloqueada")
            return { color: "#ff6b6b", dash: "6 6", width: 3 };
          if (st === "testada") return { color: "#65a8ff", dash: "", width: 3 };
          return { color: "#ffd36b", dash: "", width: 2.5 };
        }

        /* ================= FLOW RENDER (MERGE DC/ENV/INST) ================= */
        function openFlowModal(apps) {
          const overlay = document.getElementById("flowOverlay");
          const svg = document.getElementById("flowSvg");
          overlay.style.display = "flex";
          svg.innerHTML = "";

          // ---------- layout ----------
          const startX = 120;
          const gap = 300;

          // níveis (Y)
          const yDC = 120;
          const hDC = 180;

          const yENV = yDC + 26;
          const hENV = 140;

          const yINST = yENV + 26;
          const hINST = 92;

          const yAPP = yINST + 26;
          const wAPP = 164;
          const hAPP = 28;

          // largura de coluna (precisa caber o wAPP + paddings)
          const colW = 220;

          // ---------- helpers SVG ----------
          const NS = "http://www.w3.org/2000/svg";
          const el = (tag) => document.createElementNS(NS, tag);

          const drawBox = (x, y, w, h, rx, fill, stroke, sw = "1.2") => {
            const r = el("rect");
            r.setAttribute("x", x);
            r.setAttribute("y", y);
            r.setAttribute("width", w);
            r.setAttribute("height", h);
            r.setAttribute("rx", rx);
            r.setAttribute("fill", fill);
            r.setAttribute("stroke", stroke);
            r.setAttribute("stroke-width", sw);
            return r;
          };

          const drawText = (
            x,
            y,
            txt,
            size = 12,
            muted = false,
            weight = "400"
          ) => {
            const t = el("text");
            t.setAttribute("x", x);
            t.setAttribute("y", y);
            t.setAttribute("fill", muted ? "#9db0d1" : "#fff");
            t.setAttribute("font-size", String(size));
            t.setAttribute("font-weight", weight);
            t.textContent = txt;
            return t;
          };

          const animateLine = (x1, y1, x2, y2, style, delayMs) => {
            // desenha horizontal e anima com dash
            const line = el("line");
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("stroke", style.color);
            line.setAttribute("stroke-width", style.width || 3);
            line.setAttribute("stroke-linecap", "round");
            if (style.dash) line.setAttribute("stroke-dasharray", style.dash);

            // animação "esticando"
            const len = Math.max(1, Math.abs(x2 - x1));
            line.style.strokeDasharray = String(len);
            line.style.strokeDashoffset = String(len);

            svg.appendChild(line);

            setTimeout(() => {
              line.getBoundingClientRect(); // força layout
              line.style.transition = "stroke-dashoffset 520ms ease-out";
              line.style.strokeDashoffset = "0";
            }, delayMs);

            return line;
          };

          // ---------- 1) preparar steps ----------
          const steps = apps.map((app, idx) => {
            const cmdb = nodeById(app.cmdbId) || {};
            const dc = (cmdb.datacenter || "dc?").trim();
            const env = (cmdb.ambiente || "env?").trim();
            const inst = (cmdb.name || "inst?").trim();

            const x = startX + idx * gap;
            const appX = x + 28; // app box dentro da coluna
            const appY = yAPP;
            const appCenterY = appY + hAPP / 2;
            const appInX = appX; // “entrada” da app
            const appOutX = appX + wAPP; // “saída” da app

            return {
              app,
              cmdb,
              dc,
              env,
              inst,
              x,
              colLeft: x,
              colRight: x + colW,
              appX,
              appY,
              appInX,
              appOutX,
              appCenterY,
            };
          });

          // dimensiona o canvas pra caber tudo
          const totalW =
            startX + Math.max(1, steps.length - 1) * gap + colW + 200;
          const totalH = yDC + hDC + 220;
          svg.setAttribute("width", String(Math.max(2200, totalW)));
          svg.setAttribute("height", String(Math.max(900, totalH)));

          // ---------- 2) agrupar com merge hierárquico ----------
          // DC: agrupa por dc (contíguo)
          const dcGroups = [];
          for (let i = 0; i < steps.length; i++) {
            const s = steps[i];
            const last = dcGroups[dcGroups.length - 1];
            if (!last || last.dc !== s.dc) {
              dcGroups.push({ dc: s.dc, i0: i, i1: i });
            } else {
              last.i1 = i;
            }
          }

          // ENV: dentro de cada DC
          const envGroups = [];
          for (const dg of dcGroups) {
            let cur = null;
            for (let i = dg.i0; i <= dg.i1; i++) {
              const s = steps[i];
              if (!cur || cur.env !== s.env) {
                cur = { dc: dg.dc, env: s.env, i0: i, i1: i };
                envGroups.push(cur);
              } else {
                cur.i1 = i;
              }
            }
          }

          // INST: dentro de cada ENV
          const instGroups = [];
          for (const eg of envGroups) {
            let cur = null;
            for (let i = eg.i0; i <= eg.i1; i++) {
              const s = steps[i];
              if (!cur || cur.inst !== s.inst) {
                cur = { dc: eg.dc, env: eg.env, inst: s.inst, i0: i, i1: i };
                instGroups.push(cur);
              } else {
                cur.i1 = i;
              }
            }
          }

          // helpers span
          const spanX = (i0, i1) => {
            const left = steps[i0].colLeft;
            const right = steps[i1].colRight;
            return { x: left, w: right - left };
          };

          // ---------- 3) desenhar caixas MERGEADAS (DC / ENV / INST) ----------
          // DC
          dcGroups.forEach((g) => {
            const { x, w } = spanX(g.i0, g.i1);

            svg.appendChild(
              drawBox(
                x,
                yDC,
                w,
                hDC,
                16,
                "rgba(255,255,255,.04)",
                "rgba(122,162,255,.25)",
                "1.2"
              )
            );
            svg.appendChild(
              drawText(x + 12, yDC + 20, "DC: " + g.dc, 12, true, "600")
            );
          });

          // ENV
          envGroups.forEach((g) => {
            const { x, w } = spanX(g.i0, g.i1);

            svg.appendChild(
              drawBox(
                x + 12,
                yENV,
                w - 24,
                hENV,
                14,
                "rgba(255,255,255,.05)",
                "rgba(255,255,255,.12)",
                "1.1"
              )
            );
            svg.appendChild(
              drawText(x + 20, yENV + 18, "ENV: " + g.env, 12, true, "600")
            );
          });

          // INST
          instGroups.forEach((g) => {
            const { x, w } = spanX(g.i0, g.i1);

            svg.appendChild(
              drawBox(
                x + 20,
                yINST,
                w - 40,
                hINST,
                12,
                "rgba(255,255,255,.06)",
                "rgba(255,255,255,.18)",
                "1.1"
              )
            );
            svg.appendChild(
              drawText(x + 28, yINST + 18, "INST: " + g.inst, 12, true, "600")
            );
          });

          // ---------- 4) desenhar APPS (sequencial) + linhas com status ----------
          let prev = null;

          steps.forEach((s, idx) => {
            const delay = idx * 650;

            setTimeout(() => {
              // linha do passo anterior -> atual
              if (prev) {
                const style = flowConnStyle(prev.app, s.app); // << usa sua função existente

                // linha reta horizontal no centro do APP
                const x1 = prev.appOutX + 10;
                const x2 = s.appInX - 10;
                const y = s.appCenterY;

                // se não houver conectividade, seu flowConnStyle deve devolver branco pontilhado
                animateLine(x1, y, x2, y, style, 0);
              }

              // APP box
              const g = el("g");

              const r = drawBox(
                s.appX,
                s.appY,
                wAPP,
                hAPP,
                10,
                "rgba(255,255,255,.12)",
                "rgba(122,162,255,.9)",
                "1.3"
              );

              const t = drawText(
                s.appX + wAPP / 2,
                s.appY + 19,
                s.app.name,
                13,
                false,
                "600"
              );
              t.setAttribute("text-anchor", "middle");

              g.appendChild(r);
              g.appendChild(t);
              svg.appendChild(g);

              prev = s;
            }, delay);
          });
        }

        /* ================= VALIDATE (flows) ================= */

        // helpers locais (não conflitam com os seus)
        function childrenOf(parentId) {
          return state.nodes.filter((n) => n.parentId === parentId);
        }

        function collectFlowsRecursive(startDirId) {
          const out = [];
          const stack = [startDirId];

          while (stack.length) {
            const cur = stack.pop();
            const kids = childrenOf(cur);

            for (const k of kids) {
              if (isDir(k) || isCMDBDir(k)) {
                stack.push(k.id);
              } else if (isFlow(k)) {
                out.push(k);
              }
            }
          }
          return out;
        }

        // acha conexões entre duas apps (se existir mais de uma, usamos o "pior" status)
        function connStatusBetween(fromAppId, toAppId) {
          const list = state.nodes.filter(
            (n) =>
              isConn(n) && n.fromAppId === fromAppId && n.toAppId === toAppId
          );

          if (!list.length) return "missing";

          // pior caso: bloqueada > nao-testada > testada
          let hasBlocked = false;
          let hasNaoTestada = false;

          for (const c of list) {
            const st = c.connStatus || "nao-testada";
            if (st === "bloqueada") hasBlocked = true;
            else if (st === "nao-testada") hasNaoTestada = true;
          }

          if (hasBlocked) return "bloqueada";
          if (hasNaoTestada) return "nao-testada";
          return "testada";
        }

        function flowOverallStatus(hopStatuses) {
          // vermelho se qualquer bloqueada
          if (hopStatuses.includes("bloqueada")) return "blocked";
          // amarelo se qualquer nao-testada OU missing
          if (
            hopStatuses.includes("nao-testada") ||
            hopStatuses.includes("missing")
          )
            return "warning";
          // verde se tudo testada
          return "ok";
        }

        function flowStatusBadge(status) {
          // usa suas vars CSS (se existirem) com fallback
          const ok = "var(--ok, #55e6a5)";
          const warn = "var(--warn, #ffd36b)";
          const bad = "var(--danger, #ff6b6b)";
          const muted = "var(--muted, #9db0d1)";

          if (status === "ok")
            return `<span style="color:${ok};font-weight:800">● OK</span>`;
          if (status === "warning")
            return `<span style="color:${warn};font-weight:800">● ATENÇÃO</span>`;
          if (status === "blocked")
            return `<span style="color:${bad};font-weight:800">● BLOQUEADO</span>`;
          return `<span style="color:${muted};font-weight:800">● ?</span>`;
        }

        function cmd_validate(args) {
          // começa na pasta atual
          const startId = state.cwdId || "root";

          const flows = collectFlowsRecursive(startId)
            .slice()
            .sort((a, b) => (a.name || "").localeCompare(b.name || ""));

          if (!flows.length) {
            printLine(
              "validate: nenhum arquivo flow abaixo da pasta atual.",
              "muted"
            );
            return;
          }

          printLine("VALIDATE — Flows abaixo da pasta atual:", "out");
          printLine(`  Encontrados: ${flows.length}`, "muted");

          let okCount = 0,
            warnCount = 0,
            blockedCount = 0;

          for (const f of flows) {
            const ids = Array.isArray(f.apps) ? f.apps.slice() : [];
            const hops = [];
            const hopDetails = [];

            // flow com 0/1 app não tem conectividade para validar
            if (ids.length < 2) {
              f.status = "warning";
              f.updatedAt = nowISO();
              warnCount++;

              const p = fullPathOf(f.id);
              printHTMLLine(
                `${flowStatusBadge("warning")} <b>${escapeHtml(
                  p
                )}</b> <span class="muted">— flow com poucas apps</span>`,
                "out"
              );
              continue;
            }

            // avalia cada salto (A -> B)
            for (let i = 0; i < ids.length - 1; i++) {
              const aId = ids[i];
              const bId = ids[i + 1];
              const a = nodeById(aId);
              const b = nodeById(bId);

              const st = connStatusBetween(aId, bId);
              hops.push(st);

              const aName = a?.name || "app?:" + aId.slice(0, 6);
              const bName = b?.name || "app?:" + bId.slice(0, 6);
              hopDetails.push(`${aName} → ${bName}: ${st}`);
            }

            const overall = flowOverallStatus(hops); // ok | warning | blocked

            // persiste no arquivo flow
            f.status = overall;
            f.updatedAt = nowISO();

            if (overall === "ok") okCount++;
            else if (overall === "warning") warnCount++;
            else blockedCount++;

            const p = fullPathOf(f.id);

            // imprime resumo por flow (e mostra os hops em linha compacta)
            const hint = escapeHtml(hopDetails.join(" | "));
            printHTMLLine(
              `${flowStatusBadge(overall)} <b>${escapeHtml(
                p
              )}</b><div class="muted" style="margin-left:12px;margin-top:3px">${hint}</div>`,
              "out"
            );
          }

          saveState();

          printLine("", "out");
          printLine(
            `Resumo: OK=${okCount} | ATENÇÃO=${warnCount} | BLOQUEADO=${blockedCount}`,
            "muted"
          );
        }

        /* ================= INCIDENT COMMAND =================
   incident app  > AppName#AppId
   incident flow FlowName#FlowId
====================================================== */

        function _cleanToken(s) {
          return String(s || "")
            .trim()
            .replace(/^["']|["']$/g, "")
            .trim();
        }

        function _resolveAppToken(token) {
          const s = _cleanToken(token);
          if (!s) return null;

          // aceita name#id (e também suporta caso venha com aspas)
          if (s.includes("#")) {
            const parts = s.split("#");
            const id = _cleanToken(parts[parts.length - 1]).replace(
              /["']/g,
              ""
            );
            const byId = state.nodes.find((n) => isApp(n) && n.id === id);
            if (byId) return byId;

            // fallback por nome (se id falhar)
            const name = _cleanToken(parts.slice(0, -1).join("#"));
            return state.nodes.find((n) => isApp(n) && n.name === name) || null;
          }

          return state.nodes.find((n) => isApp(n) && n.name === s) || null;
        }

        function _resolveFlowToken(token) {
          const s = _cleanToken(token);
          if (!s) return null;

          // suporta name#id
          if (s.includes("#")) {
            const parts = s.split("#");
            const id = _cleanToken(parts[parts.length - 1]).replace(
              /["']/g,
              ""
            );
            const fById = state.nodes.find(
              (n) => n && n.type === "flow" && n.id === id
            );
            if (fById) return fById;

            const name = _cleanToken(parts.slice(0, -1).join("#"));
            return (
              state.nodes.find(
                (n) => n && n.type === "flow" && n.name === name
              ) || null
            );
          }

          // tenta por nome direto
          let f = state.nodes.find(
            (n) => n && n.type === "flow" && n.name === s
          );
          if (f) return f;

          // fallback: permitir passar caminho completo ou sufixo do caminho
          const candidates = state.nodes.filter((n) => n && n.type === "flow");
          const hit = candidates.find(
            (n) => fullPathOf(n.id) === s || fullPathOf(n.id).endsWith("/" + s)
          );
          return hit || null;
        }

        function _severity(matches) {
          if (matches <= 0) return { label: "-", color: "var(--muted)" };
          if (matches === 1)
            return { label: "baixa", color: "rgba(255,211,107,0.95)" };
          if (matches === 2)
            return { label: "média", color: "rgba(255,190,80,0.95)" };
          return { label: "alta", color: "rgba(255,107,107,0.95)" };
        }

        function _groupByDirPath(nodes) {
          const groups = new Map(); // dirPath -> [nodes]
          for (const n of nodes) {
            const dirId = n.parentId || "root";
            const dirPath = fullPathOf(dirId);
            if (!groups.has(dirPath)) groups.set(dirPath, []);
            groups.get(dirPath).push(n);
          }
          // sort groups and items
          const sortedKeys = Array.from(groups.keys()).sort((a, b) =>
            a.localeCompare(b)
          );
          const out = [];
          for (const k of sortedKeys) {
            const arr = groups
              .get(k)
              .slice()
              .sort((a, b) => String(a.name).localeCompare(String(b.name)));
            out.push([k, arr]);
          }
          return out;
        }

        function cmd_incident(raw) {
          const trimmed = (raw || "").trim();

          // modo 1) incident app > App#id
          if (/^incident\s+app\b/i.test(trimmed)) {
            let rest = trimmed.replace(/^incident\s+app\b/i, "").trim();
            rest = rest.replace(/^>\s*/, "").trim();

            if (!rest) {
              printLine("Use: incident app > AppName#AppId", "muted");
              return;
            }

            const app = _resolveAppToken(rest);
            if (!app) {
              printLine(`App inválida: ${rest}`, "err");
              return;
            }

            const flows = state.nodes.filter(
              (n) => n && n.type === "flow" && Array.isArray(n.apps)
            );
            const affected = flows.filter((f) => f.apps.includes(app.id));

            printLine(`INCIDENT — App: ${app.name}#${app.id}`, "out");
            if (!affected.length) {
              printLine(
                "Nenhum flow afetado encontrado a partir da raiz.",
                "muted"
              );
              return;
            }

            const grouped = _groupByDirPath(affected);
            for (const [dirPath, items] of grouped) {
              printLine(dirPath + "/", "muted");
              for (const f of items) {
                // mostra o flow e quantas vezes a app aparece (normalmente 1)
                const cnt = f.apps.filter((x) => x === app.id).length;
                printHTMLLine(
                  `  • <span style="color:rgba(255,211,107,0.95)">flow</span> ${escapeHtml(
                    f.name
                  )} <span class="muted">(${cnt} match)</span>`,
                  "out"
                );
              }
            }
            return;
          }

          // modo 2) incident flow <flow>
          if (/^incident\s+flow\b/i.test(trimmed)) {
            let rest = trimmed.replace(/^incident\s+flow\b/i, "").trim();

            if (!rest) {
              printLine("Use: incident flow FlowName#FlowId", "muted");
              return;
            }

            const baseFlow = _resolveFlowToken(rest);
            if (!baseFlow || !Array.isArray(baseFlow.apps)) {
              printLine(`Flow não encontrado/inválido: ${rest}`, "err");
              return;
            }

            const baseSet = new Set(baseFlow.apps);
            const flows = state.nodes.filter(
              (n) =>
                n &&
                n.type === "flow" &&
                Array.isArray(n.apps) &&
                n.id !== baseFlow.id
            );

            const impacted = [];
            for (const f of flows) {
              let matches = 0;
              for (const id of f.apps) {
                if (baseSet.has(id)) matches++;
              }
              if (matches > 0) {
                impacted.push({ flow: f, matches });
              }
            }

            printLine(
              `INCIDENT — Flow: ${baseFlow.name}#${baseFlow.id}`,
              "out"
            );
            if (!impacted.length) {
              printLine(
                "Nenhum outro flow afetado encontrado a partir da raiz.",
                "muted"
              );
              return;
            }

            // ordena por severidade (matches desc) e nome
            impacted.sort(
              (a, b) =>
                b.matches - a.matches ||
                String(a.flow.name).localeCompare(String(b.flow.name))
            );

            // agrupa por pasta
            const groupedMap = new Map();
            for (const it of impacted) {
              const dirPath = fullPathOf(it.flow.parentId || "root");
              if (!groupedMap.has(dirPath)) groupedMap.set(dirPath, []);
              groupedMap.get(dirPath).push(it);
            }

            const dirKeys = Array.from(groupedMap.keys()).sort((a, b) =>
              a.localeCompare(b)
            );
            for (const dirPath of dirKeys) {
              printLine(dirPath + "/", "muted");
              const items = groupedMap.get(dirPath);

              for (const it of items) {
                const sev = _severity(it.matches);
                printHTMLLine(
                  `  • <span style="color:${sev.color};font-weight:700">${sev.label}</span> ` +
                    `${escapeHtml(it.flow.name)} <span class="muted">(${
                      it.matches
                    } app(s) em comum)</span>`,
                  "out"
                );
              }
            }
            return;
          }

          // help
          printLine("Use:", "muted");
          printLine("  incident app  > AppName#AppId", "muted");
          printLine("  incident flow FlowName#FlowId", "muted");
        }

        /* ================= CLI COMMAND ================= */
        function cmd_flow(raw) {
          const args = raw.replace(/^flow\s*/, "").trim();

          // ----------------------------
          // MODO VISUALIZAR
          // ----------------------------
          if (args.startsWith("ver ")) {
            const name = args.replace(/^ver\s+/, "").trim();
            if (!name) {
              printLine("Use: flow ver <nome>", "muted");
              return;
            }

            const flow = state.nodes.find(
              (n) => n.type === "flow" && n.name === name
            );

            if (!flow) {
              printLine(`Flow não encontrado: ${name}`, "err");
              return;
            }

            openFlowModal(flow.apps.map((id) => nodeById(id)));
            return;
          }

          // ----------------------------
          // CRIAÇÃO DO FLOW
          // ----------------------------
          if (!args) {
            printLine("Use: flow App1 > App2 > App3", "muted");
            return;
          }

          const tokens = args
            .split(">")
            .map((s) => s.trim())
            .filter(Boolean);
          if (!tokens.length) {
            printLine("Fluxo vazio.", "err");
            return;
          }

          const apps = [];

          for (const token of tokens) {
            let app = null;

            if (token.includes("#")) {
              const [, id] = token.split("#");
              app = state.nodes.find((n) => isApp(n) && n.id === id);
            } else {
              app = state.nodes.find((n) => isApp(n) && n.name === token);
            }

            if (!app) {
              printLine(`App inválida: ${token}`, "err");
              return;
            }

            apps.push(app);
          }

          // cria nó flow NO DIRETÓRIO ATUAL
          const flowNode = {
            id: rid(),
            type: "flow",
            name: `flow-${Date.now()}`,
            parentId: state.cwdId,
            apps: apps.map((a) => a.id),
            createdAt: nowISO(),
            updatedAt: nowISO(),
          };

          state.nodes.push(flowNode);
          saveState?.();

          printLine(`Flow criado: ${flowNode.name}`, "ok");

          // já abre o visual
          openFlowModal(apps);
        }

        function renderGraph(svg, mode = "hover") {
          svg.innerHTML = "";

          // =========================
          // Drag infra (self-contained)
          // =========================
          state.ui = state.ui || {};
          state.ui.graphOffsets = state.ui.graphOffsets || {}; // key -> {dx,dy}

          // =========================
          // Resize infra (self-contained)
          // =========================
          state.ui = state.ui || {};
          state.ui.graphSizes = state.ui.graphSizes || {}; // key -> {dw, dh}

          const getSize = (key) => {
            if (!state.ui.graphSizes[key])
              state.ui.graphSizes[key] = { dw: 0, dh: 0 };
            return state.ui.graphSizes[key];
          };

          // limites mínimos por tipo (pra não “colapsar” a caixa)
          const minSizeFor = (key, baseW, baseH) => {
            if (key.startsWith("dc:"))
              return {
                minW: Math.max(600, baseW * 0.55),
                minH: Math.max(240, baseH * 0.55),
              };
            if (key.startsWith("env:"))
              return {
                minW: Math.max(520, baseW * 0.55),
                minH: Math.max(220, baseH * 0.55),
              };
            if (key.startsWith("ns:"))
              return {
                minW: Math.max(420, baseW * 0.55),
                minH: Math.max(180, baseH * 0.55),
              };
            if (key.startsWith("cmdb:"))
              return {
                minW: Math.max(300, baseW * 0.8),
                minH: Math.max(120, baseH * 0.7),
              };
            return {
              minW: Math.max(160, baseW * 0.6),
              minH: Math.max(120, baseH * 0.6),
            };
          };

          const clampSize = (key, baseW, baseH, dw, dh, maxW, maxH) => {
            const { minW, minH } = minSizeFor(key, baseW, baseH);
            const w = clamp(baseW + dw, minW, maxW);
            const h = clamp(baseH + dh, minH, maxH);
            return { dw: w - baseW, dh: h - baseH };
          };

          const getOffset = (key) => {
            if (!state.ui.graphOffsets[key])
              state.ui.graphOffsets[key] = { dx: 0, dy: 0 };
            return state.ui.graphOffsets[key];
          };

          const clientToSvg = (clientX, clientY) => {
            const r = svg.getBoundingClientRect();
            const w = Number(svg.getAttribute("width") || r.width || 1);
            const h = Number(svg.getAttribute("height") || r.height || 1);
            return {
              x: (clientX - r.left) * (w / (r.width || 1)),
              y: (clientY - r.top) * (h / (r.height || 1)),
            };
          };

          const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

          // init drag handlers once per svg
          if (!svg.__cmdbDragInit) {
            svg.__cmdbDragInit = true;
            svg.__cmdbDragState = null;

            svg.addEventListener("dblclick", (ev) => {
              const hit =
                ev.target &&
                ev.target.closest &&
                ev.target.closest("[data-nodeid],[data-appid]");
              if (!hit) return;
              ev.preventDefault();
              ev.stopPropagation();

              const nodeId =
                hit.getAttribute("data-nodeid") ||
                hit.getAttribute("data-appid");
              if (!nodeId) return;
              openModal(nodeId);
            });

            svg.addEventListener("pointerdown", (ev) => {
              const target = ev.target;
              if (!target) return;

              // >>> RESIZE HANDLE
              const h = target.closest && target.closest("[data-resizekey]");
              if (h) {
                const key = h.getAttribute("data-resizekey");
                if (!key) return;
                ev.preventDefault();

                const pt = clientToSvg(ev.clientX, ev.clientY);
                const sz = getSize(key);

                svg.__cmdbDragState = {
                  type: "resize",
                  key,
                  startPt: pt,
                  startSize: { dw: sz.dw, dh: sz.dh },
                  modeAtStart: mode,
                };

                if (target.setPointerCapture)
                  target.setPointerCapture(ev.pointerId);
                return;
              }

              // >>> NORMAL DRAG (como você já tinha)
              const g = target.closest && target.closest("[data-dragkey]");
              if (!g) return;

              const key = g.getAttribute("data-dragkey");
              if (!key) return;

              ev.preventDefault();

              const pt = clientToSvg(ev.clientX, ev.clientY);
              const off = getOffset(key);

              svg.__cmdbDragState = {
                type: "drag",
                key,
                startPt: pt,
                startOff: { dx: off.dx, dy: off.dy },
                modeAtStart: mode,
              };

              if (target.setPointerCapture)
                target.setPointerCapture(ev.pointerId);
            });

            svg.addEventListener("pointermove", (ev) => {
              const ds = svg.__cmdbDragState;
              if (!ds) return;

              const pt = clientToSvg(ev.clientX, ev.clientY);

              if (ds.type === "resize") {
                const key = ds.key;
                const sz = getSize(key);

                // delta do mouse em coords do SVG
                const dx = pt.x - ds.startPt.x;
                const dy = pt.y - ds.startPt.y;

                // aplica direto (clamp real é feito dentro de applyRootRect/applyChildRect)
                sz.dw = ds.startSize.dw + dx;
                sz.dh = ds.startSize.dh + dy;

                renderGraph(svg, ds.modeAtStart || mode);
                return;
              }

              // drag normal
              const off = getOffset(ds.key);
              off.dx = ds.startOff.dx + (pt.x - ds.startPt.x);
              off.dy = ds.startOff.dy + (pt.y - ds.startPt.y);

              renderGraph(svg, ds.modeAtStart || mode);
            });

            const end = () => {
              svg.__cmdbDragState = null;
            };
            svg.addEventListener("pointerup", end);
            svg.addEventListener("pointercancel", end);
            svg.addEventListener("pointerleave", end);
          }

          // =========================
          // Data
          // =========================
          const cmdbs = state.nodes
            .filter(isCMDBDir)
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name));
          const apps = state.nodes.filter(isApp);
          const conns = state.nodes.filter(isConn);

          // --------- SUPRIMENTO (entrada/saída) por app ----------
          const hasIn = new Map();
          const hasOut = new Map();
          apps.forEach((a) => {
            hasIn.set(a.id, false);
            hasOut.set(a.id, false);
          });

          for (const c of conns) {
            if (c.toAppId && hasIn.has(c.toAppId)) hasIn.set(c.toAppId, true);
            if (c.fromAppId && hasOut.has(c.fromAppId))
              hasOut.set(c.fromAppId, true);
          }
          const isSuppliedApp = (appId) =>
            !!hasIn.get(appId) && !!hasOut.get(appId);

          // --------- HEALTH por app (ok/warning/blocked/default) ----------
          function getAppHealth(appId) {
            let hasBlocked = false;
            let hasWarning = false;

            for (const c of conns) {
              const rel = c.fromAppId === appId || c.toAppId === appId;
              if (!rel) continue;

              const st = c.connStatus || "nao-testada";
              if (st === "bloqueada") {
                hasBlocked = true;
                break;
              }
              if (st === "nao-testada") hasWarning = true;
            }

            if (hasBlocked) return "blocked";
            if (hasWarning) return "warning";
            if (isSuppliedApp(appId)) return "ok";
            return "default";
          }

          function colorsForHealth(appHealth, isolated = false) {
            if (isolated)
              return {
                fill: "rgba(255,255,255,0.95)",
                stroke: "rgba(0,0,0,0.25)",
              };

            if (appHealth === "ok") {
              return {
                fill: "rgba(120, 255, 160, 0.55)",
                stroke: "rgba(70, 255, 150, 0.98)",
              };
            } else if (appHealth === "warning") {
              return {
                fill: "rgba(255, 210, 120, 0.40)",
                stroke: "rgba(255, 190, 80, 0.95)",
              };
            } else if (appHealth === "blocked") {
              return {
                fill: "rgba(255, 120, 120, 0.42)",
                stroke: "rgba(255, 80, 80, 0.95)",
              };
            } else {
              return {
                fill: "rgba(255,255,255,0.06)",
                stroke: "rgba(85,230,165,0.28)",
              };
            }
          }

          // ---------- helpers ----------
          const getDc = (c) =>
            (c.datacenter || c.dc || "").trim() || "(sem dc)";
          const getEnv = (c) =>
            (c.ambiente || c.env || "").trim() || "(sem env)";
          const getNs = (c) =>
            (c.namespace || c.ns || c.nspace || c.nameSpace || "").trim() ||
            "(sem namespace)";

          // filtro de modo
          function allowConnByMode(c) {
            const st = c.connStatus || "nao-testada";
            if (mode === "bloqueada") return st === "bloqueada";
            if (mode === "nao-testada") return st === "nao-testada";
            if (mode === "testada") return st === "testada";
            return true;
          }

          function strokeForConn(c) {
            const st = c.connStatus || "nao-testada";
            if (st === "bloqueada")
              return { color: "rgba(255,107,107,0.95)", w: 2.6, dash: "7 6" };
            if (st === "testada")
              return { color: "rgba(101,168,255,0.9)", w: 2.4, dash: "" };
            return { color: "rgba(255,211,107,0.95)", w: 2.0, dash: "" };
          }

          // graus (isolados)
          const appDegree = new Map();
          const cmdbDegree = new Map();
          const inc = (m, k) => m.set(k, (m.get(k) || 0) + 1);

          apps.forEach((a) => appDegree.set(a.id, 0));
          cmdbs.forEach((c) => cmdbDegree.set(c.id, 0));

          for (const c of conns) {
            inc(appDegree, c.fromAppId);
            inc(appDegree, c.toAppId);
            const fa = nodeById(c.fromAppId);
            const ta = nodeById(c.toAppId);
            if (fa?.cmdbId) inc(cmdbDegree, fa.cmdbId);
            if (ta?.cmdbId) inc(cmdbDegree, ta.cmdbId);
          }
          const isIsolatedApp = (id) => (appDegree.get(id) || 0) === 0;
          const isIsolatedCmdb = (id) => (cmdbDegree.get(id) || 0) === 0;

          // apps por cmdb
          const appsByCmdb = new Map();
          for (const c of cmdbs) appsByCmdb.set(c.id, []);
          for (const a of apps) {
            if (!appsByCmdb.has(a.cmdbId)) appsByCmdb.set(a.cmdbId, []);
            appsByCmdb.get(a.cmdbId).push(a);
          }
          for (const [k, v] of appsByCmdb.entries())
            v.sort((x, y) => x.name.localeCompare(y.name));

          // ---------- layout params ----------
          const pad = 18;
          const dcPad = 18;
          const envPad = 16;

          const nsPad = 14;
          const nsTitleH = 26;
          const nsGap = 14;

          const cmdbW = 330;
          const cmdbColGap = 22;
          const cmdbRowGap = 22;

          const headerH = 34;
          const appH = 24;

          const envTitleH = 30;
          const dcTitleH = 30;

          const perRow = 3;

          // ---------- 1) agrupar: DC -> ENV -> NAMESPACE -> CMDB ----------
          const dcMap = new Map();
          for (const c of cmdbs) {
            const dc = getDc(c);
            const env = getEnv(c);
            const ns = getNs(c);

            if (!dcMap.has(dc)) dcMap.set(dc, new Map());
            const envMap = dcMap.get(dc);
            if (!envMap.has(env)) envMap.set(env, new Map());
            const nsMap = envMap.get(env);
            if (!nsMap.has(ns)) nsMap.set(ns, []);
            nsMap.get(ns).push(c);
          }

          const dcs = Array.from(dcMap.keys()).sort((a, b) =>
            a.localeCompare(b)
          );
          for (const dc of dcs) {
            const envMap = dcMap.get(dc);
            const envs = Array.from(envMap.keys()).sort((a, b) =>
              a.localeCompare(b)
            );
            const newEnvMap = new Map();

            for (const env of envs) {
              const nsMap = envMap.get(env);
              const nss = Array.from(nsMap.keys()).sort((a, b) =>
                a.localeCompare(b)
              );
              const newNsMap = new Map();
              for (const ns of nss) {
                const list = nsMap
                  .get(ns)
                  .slice()
                  .sort((a, b) => a.name.localeCompare(b.name));
                newNsMap.set(ns, list);
              }
              newEnvMap.set(env, newNsMap);
            }
            dcMap.set(dc, newEnvMap);
          }

          // =========================================================
          // BASE LAYOUT (sem offsets)  -> SEM reflow por drag
          // =========================================================
          const baseDcPos = new Map(); // dc -> {x,y,w,h}
          const baseEnvPos = new Map(); // "dc||env" -> {x,y,w,h}
          const baseNsPos = new Map(); // "dc||env||ns" -> {x,y,w,h}
          const baseCmdbPos = new Map(); // cmdbId -> {x,y,w,h}

          function computeNsBox_BASE(dc, env, ns, cmdbList, startX, startY) {
            let x = startX + nsPad;
            let y = startY + nsTitleH + nsPad;

            let colMaxH = 0;
            let maxX = x,
              maxY = y;

            cmdbList.forEach((c, idx) => {
              const appsIn = appsByCmdb.get(c.id) || [];
              const cmdbH = headerH + Math.max(1, appsIn.length) * appH + 22;

              if (idx > 0 && idx % perRow === 0) {
                x = startX + nsPad;
                y = y + colMaxH + cmdbRowGap; // <-- usa base Y (não depende offset)
                colMaxH = 0;
              }

              const cx = x;
              const cy = y;

              baseCmdbPos.set(c.id, { x: cx, y: cy, w: cmdbW, h: cmdbH });

              colMaxH = Math.max(colMaxH, cmdbH);
              maxX = Math.max(maxX, cx + cmdbW);
              maxY = Math.max(maxY, cy + cmdbH);

              x = x + cmdbW + cmdbColGap; // <-- base X (não depende offset)
            });

            const nsW = maxX - startX + nsPad;
            const nsH = maxY - startY + nsPad;

            return {
              w: Math.max(nsW, cmdbW + nsPad * 2),
              h: Math.max(nsH, nsTitleH + 80),
            };
          }

          function computeEnvBox_BASE(dc, env, nsMap, startX, startY) {
            let innerY = startY + envTitleH + envPad;
            const envX = startX;

            let maxX = envX + envPad;
            let maxY = innerY;

            for (const ns of Array.from(nsMap.keys())) {
              const cmdbList = nsMap.get(ns) || [];

              const nxBase = envX + envPad;
              const nyBase = innerY;

              const { w: nsW, h: nsH } = computeNsBox_BASE(
                dc,
                env,
                ns,
                cmdbList,
                nxBase,
                nyBase
              );
              baseNsPos.set(dc + "||" + env + "||" + ns, {
                x: nxBase,
                y: nyBase,
                w: nsW,
                h: nsH,
              });

              // IMPORTANTE: avança pelo BASE (sem offset)
              innerY = nyBase + nsH + nsGap;

              maxX = Math.max(maxX, nxBase + nsW);
              maxY = Math.max(maxY, nyBase + nsH);
            }

            const envW = maxX - startX + envPad;
            const envH = maxY - startY + envPad;

            return {
              w: Math.max(envW, cmdbW + envPad * 2),
              h: Math.max(envH, envTitleH + 120),
            };
          }

          // DCs empilhados (BASE) — cursor não usa offset
          let cursorY = pad;
          const canvasWMin = 1800;
          let canvasW = canvasWMin;
          let maxBaseY = cursorY;

          for (const dc of dcs) {
            const envMap = dcMap.get(dc);
            const envs = Array.from(envMap.keys());

            const dcXBase = pad;
            const dcYBase = cursorY;

            let innerY = dcYBase + dcTitleH + dcPad;

            let dcMaxW = 0;
            let dcMaxY = innerY;

            for (const env of envs) {
              const nsMap = envMap.get(env);

              const envXBase = dcXBase + dcPad;
              const envYBase = innerY;

              const { w: envW, h: envH } = computeEnvBox_BASE(
                dc,
                env,
                nsMap,
                envXBase,
                envYBase
              );
              baseEnvPos.set(dc + "||" + env, {
                x: envXBase,
                y: envYBase,
                w: envW,
                h: envH,
              });

              // IMPORTANTE: avança pelo BASE (sem offset)
              innerY = envYBase + envH + 16;

              dcMaxW = Math.max(dcMaxW, envXBase + envW - dcXBase);
              dcMaxY = Math.max(dcMaxY, envYBase + envH);
            }

            const dcWBase = dcMaxW + dcPad;
            const dcHBase = dcMaxY - dcYBase + dcPad;

            baseDcPos.set(dc, {
              x: dcXBase,
              y: dcYBase,
              w: dcWBase,
              h: dcHBase,
            });

            cursorY = dcYBase + dcHBase + 18; // BASE (sem offset)
            canvasW = Math.max(canvasW, dcXBase + dcWBase + pad);
            maxBaseY = Math.max(maxBaseY, cursorY);
          }

          // Canvas grande para permitir liberdade
          const BIG_W = 12000;
          const BIG_H = 8000;
          
          svg.setAttribute("width", String(BIG_W));
          svg.setAttribute("height", String(BIG_H));

          // =========================================================
          // Aplicar OFFSETS (com clamp por hierarquia)
          // =========================================================
          const actualDcPos = new Map();
          const actualEnvPos = new Map();
          const actualNsPos = new Map();
          const actualCmdbPos = new Map();
          const actualAppBox = new Map(); // appId -> {x,y,w,h, mid,in,out}

          const W = Number(svg.getAttribute("width") || 2000);
          const H = Number(svg.getAttribute("height") || 1200);

          function applyRootRect(key, baseRect, margin = pad) {
            const off = getOffset(key);
            const sz = getSize(key);

            // tamanho desejado (base + delta)
            const maxW = W - margin * 2;
            const maxH = H - margin * 2;
            const fixed = clampSize(
              key,
              baseRect.w,
              baseRect.h,
              sz.dw,
              sz.dh,
              maxW,
              maxH
            );
            sz.dw = fixed.dw;
            sz.dh = fixed.dh;

            const w = baseRect.w + sz.dw;
            const h = baseRect.h + sz.dh;

            const minX = margin;
            const maxX = W - margin - w;
            const minY = margin;
            const maxY = H - margin - h;

            off.dx = clamp(off.dx, minX - baseRect.x, maxX - baseRect.x);
            off.dy = clamp(off.dy, minY - baseRect.y, maxY - baseRect.y);

            return { x: baseRect.x + off.dx, y: baseRect.y + off.dy, w, h };
          }

          function applyChildRect(
            key,
            baseRect,
            baseParent,
            actualParent,
            padInside
          ) {
            const parentDeltaX = actualParent.x - baseParent.x;
            const parentDeltaY = actualParent.y - baseParent.y;

            const desiredX0 = baseRect.x + parentDeltaX;
            const desiredY0 = baseRect.y + parentDeltaY;

            const off = getOffset(key);
            const sz = getSize(key);

            // clamp do tamanho pelo pai atual
            const maxW = actualParent.w - padInside * 2;
            const maxH = actualParent.h - padInside * 2;
            const fixed = clampSize(
              key,
              baseRect.w,
              baseRect.h,
              sz.dw,
              sz.dh,
              maxW,
              maxH
            );
            sz.dw = fixed.dw;
            sz.dh = fixed.dh;

            const w = baseRect.w + sz.dw;
            const h = baseRect.h + sz.dh;

            const minX = actualParent.x + padInside;
            const maxX = actualParent.x + actualParent.w - padInside - w;
            const minY = actualParent.y + padInside;
            const maxY = actualParent.y + actualParent.h - padInside - h;

            off.dx = clamp(off.dx, minX - desiredX0, maxX - desiredX0);
            off.dy = clamp(off.dy, minY - desiredY0, maxY - desiredY0);

            return { x: desiredX0 + off.dx, y: desiredY0 + off.dy, w, h };
          }

          // ---------- camadas ----------
          const dcLayer = svgEl("g");
          const envLayer = svgEl("g");
          const nsLayer = svgEl("g");
          const cmdbLayer = svgEl("g");
          const edgeLayer = svgEl("g");
          const labelLayer = svgEl("g");
          const appLayer = svgEl("g");

          svg.appendChild(dcLayer);
          svg.appendChild(envLayer);
          svg.appendChild(nsLayer);
          svg.appendChild(cmdbLayer);
          svg.appendChild(edgeLayer);
          svg.appendChild(labelLayer);
          svg.appendChild(appLayer);

          // defs/clip
          const defs = svgEl("defs");
          svg.appendChild(defs);

          function addClip(id, x, y, w, h) {
            const cp = svgEl("clipPath", { id });
            cp.appendChild(
              svgEl("rect", { x, y, width: w, height: h, rx: "10", ry: "10" })
            );
            defs.appendChild(cp);
            return id;
          }

          function drawResizeHandle(layer, rect, key) {
            const s = 12;
            const hx = rect.x + rect.w - s - 6;
            const hy = rect.y + rect.h - s - 6;

            const h = svgEl("rect", {
              x: hx,
              y: hy,
              width: s,
              height: s,
              rx: "3",
              ry: "3",
              fill: "rgba(255,255,255,0.10)",
              stroke: "rgba(255,255,255,0.22)",
              "stroke-width": "1",
              "data-resizekey": key,
              style: "cursor:nwse-resize",
            });

            // uma “marcação” diagonal
            const l1 = svgEl("path", {
              d: `M ${hx + 3} ${hy + s - 3} L ${hx + s - 3} ${hy + 3}`,
              stroke: "rgba(255,255,255,0.25)",
              "stroke-width": "1",
              "pointer-events": "none",
            });

            layer.appendChild(h);
            layer.appendChild(l1);
          }

          // =========================================================
          // Draw DC / ENV / NS com posições "actual" (livres + clamp)
          // =========================================================
          for (const dc of dcs) {
            const bdc = baseDcPos.get(dc);
            if (!bdc) continue;

            const dcKey = "dc:" + dc;
            const adc = applyRootRect(dcKey, bdc, pad);
            actualDcPos.set(dc, adc);

            const dcG = svgEl("g", {
              "data-dragkey": dcKey,
              style: "cursor:move",
            });
            dcLayer.appendChild(dcG);

            dcG.appendChild(
              svgEl("rect", {
                x: adc.x,
                y: adc.y,
                width: adc.w,
                height: adc.h,
                rx: "20",
                ry: "20",
                fill: "rgba(255,255,255,0.02)",
                stroke: "rgba(122,162,255,0.22)",
                "stroke-width": "1.2",
              })
            );

            const t = svgEl("text", {
              x: adc.x + 14,
              y: adc.y + 21,
              fill: "var(--text)",
              "font-family": "var(--mono)",
              "font-size": "12.8",
              opacity: "0.9",
              "pointer-events": "none",
            });
            t.textContent = `DATACENTER: ${dc}`;
            dcG.appendChild(t);
            drawResizeHandle(dcG, adc, dcKey);

            const envMap = dcMap.get(dc);
            for (const [env, nsMap] of envMap.entries()) {
              const envKeyStr = dc + "||" + env;
              const benv = baseEnvPos.get(envKeyStr);
              if (!benv) continue;

              const envKey = "env:" + envKeyStr;
              const aenv = applyChildRect(envKey, benv, bdc, adc, dcPad);
              actualEnvPos.set(envKeyStr, aenv);

              const envG = svgEl("g", {
                "data-dragkey": envKey,
                style: "cursor:move",
              });
              envLayer.appendChild(envG);

              envG.appendChild(
                svgEl("rect", {
                  x: aenv.x,
                  y: aenv.y,
                  width: aenv.w,
                  height: aenv.h,
                  rx: "18",
                  ry: "18",
                  fill: "rgba(255,255,255,0.03)",
                  stroke: "rgba(255,255,255,0.08)",
                  "stroke-width": "1.0",
                })
              );

              const et = svgEl("text", {
                x: aenv.x + 14,
                y: aenv.y + 20,
                fill: "var(--muted)",
                "font-family": "var(--mono)",
                "font-size": "12.2",
                "pointer-events": "none",
              });
              et.textContent = `AMBIENTE: ${env}`;
              envG.appendChild(et);
              drawResizeHandle(envG, aenv, envKey);

              for (const ns of Array.from(nsMap.keys())) {
                const nsKeyStr = dc + "||" + env + "||" + ns;
                const bns = baseNsPos.get(nsKeyStr);
                if (!bns) continue;

                const nsKey = "ns:" + nsKeyStr;
                const ans = applyChildRect(nsKey, bns, benv, aenv, envPad);
                actualNsPos.set(nsKeyStr, ans);

                const nsG = svgEl("g", {
                  "data-dragkey": nsKey,
                  style: "cursor:move",
                });
                nsLayer.appendChild(nsG);

                nsG.appendChild(
                  svgEl("rect", {
                    x: ans.x,
                    y: ans.y,
                    width: ans.w,
                    height: ans.h,
                    rx: "16",
                    ry: "16",
                    fill: "rgba(255,255,255,0.028)",
                    stroke: "rgba(255,255,255,0.085)",
                    "stroke-width": "1.0",
                  })
                );

                const nt = svgEl("text", {
                  x: ans.x + 14,
                  y: ans.y + 18,
                  fill: "rgba(255,255,255,0.62)",
                  "font-family": "var(--mono)",
                  "font-size": "12.0",
                  "pointer-events": "none",
                });
                nt.textContent = `NAMESPACE: ${ns}`;
                nsG.appendChild(nt);
                drawResizeHandle(nsG, ans, nsKey);
              }
            }
          }

          // =========================================================
          // Draw CMDB + APP (CMDB livre dentro de NS, APP livre dentro de CMDB)
          // =========================================================
          const cmdbPosForEdges = new Map(); // cmdbId -> {appPos:Map}
          const appElsById = new Map();
          const remember = (appId, el) => {
            if (!appElsById.has(appId)) appElsById.set(appId, []);
            appElsById.get(appId).push(el);
          };

          // primeiro, precisamos de um lookup do nsKey de cada cmdb
          const cmdbToNsKey = new Map(); // cmdbId -> "dc||env||ns"
          for (const [dc, envMap] of dcMap.entries()) {
            for (const [env, nsMap] of envMap.entries()) {
              for (const [ns, list] of nsMap.entries()) {
                for (const c of list)
                  cmdbToNsKey.set(c.id, dc + "||" + env + "||" + ns);
              }
            }
          }

          for (const c of cmdbs) {
            const bcmdb = baseCmdbPos.get(c.id);
            if (!bcmdb) continue;

            const nsKeyStr = cmdbToNsKey.get(c.id);
            const bns = nsKeyStr ? baseNsPos.get(nsKeyStr) : null;
            const ans = nsKeyStr ? actualNsPos.get(nsKeyStr) : null;
            if (!bns || !ans) continue;

            const cmdbKey = "cmdb:" + c.id;
            const acmdb = applyChildRect(cmdbKey, bcmdb, bns, ans, nsPad);
            actualCmdbPos.set(c.id, acmdb);

            const appPosMap = new Map();
            cmdbPosForEdges.set(c.id, { ...acmdb, appPos: appPosMap });

            const cmdbIsolated = isIsolatedCmdb(c.id);
            const fill = cmdbIsolated
              ? "rgba(255,255,255,0.95)"
              : "rgba(255,255,255,0.04)";
            const stroke = cmdbIsolated
              ? "rgba(0,0,0,0.25)"
              : "rgba(122,162,255,0.35)";

            const cmdbG = svgEl("g", {
              "data-dragkey": cmdbKey,
              "data-nodeid": c.id,
              style: "cursor:move",
            });
            cmdbLayer.appendChild(cmdbG);

            cmdbG.appendChild(
              svgEl("rect", {
                x: acmdb.x,
                y: acmdb.y,
                width: acmdb.w,
                height: acmdb.h,
                rx: "16",
                ry: "16",
                fill,
                stroke,
                "stroke-width": "1.2",
              })
            );

            const clipId = addClip(
              "cmdbTitleClip_" + c.id,
              acmdb.x + 10,
              acmdb.y + 10,
              acmdb.w - 20,
              20
            );
            const titleG = svgEl("g", { "clip-path": `url(#${clipId})` });

            const titleText = `${c.name} • ${c.hostname || "-"} • ${
              c.ip || "-"
            }`;
            const tt = svgEl("text", {
              x: acmdb.x + 14,
              y: acmdb.y + 22,
              fill: cmdbIsolated ? "rgba(0,0,0,0.78)" : "var(--text)",
              "font-family": "var(--mono)",
              "font-size": "12",
              opacity: cmdbIsolated ? "1" : "0.80",
              "pointer-events": "none",
            });
            tt.textContent = titleText;
            titleG.appendChild(tt);
            cmdbG.appendChild(titleG);
            drawResizeHandle(cmdbG, acmdb, cmdbKey);

            // apps dentro do cmdb
            const list = appsByCmdb.get(c.id) || [];
            const baseY = acmdb.y + headerH;

            if (!list.length) {
              const cx = acmdb.x + acmdb.w / 2;
              const cy = baseY + 18;
              appPosMap.set("__none__", {
                mid: { x: cx, y: cy },
                in: { x: cx - 10, y: cy },
                out: { x: cx + 10, y: cy },
              });
              cmdbG.appendChild(
                svgEl("circle", {
                  cx,
                  cy,
                  r: "4.5",
                  fill: cmdbIsolated
                    ? "rgba(0,0,0,0.25)"
                    : "rgba(255,255,255,0.35)",
                })
              );
              continue;
            }

            list.forEach((a, i) => {
              const boxW = Math.min(286, acmdb.w - 36);
              const boxH = 18;

              // base app (sem offset próprio)
              const axBase = acmdb.x + 18;
              const ayBase = baseY + 18 + i * appH;
              const boxXBase = axBase;
              const boxYBase = ayBase - 10;

              // agora o app tem offset "livre", mas clamp dentro do CMDB
              const appKey = "app:" + a.id;
              const offA = getOffset(appKey);

              const minX = acmdb.x + 18;
              const maxX = acmdb.x + acmdb.w - 18 - boxW;
              const minY = acmdb.y + headerH + 6;
              const maxY = acmdb.y + acmdb.h - 12 - boxH;

              offA.dx = clamp(offA.dx, minX - boxXBase, maxX - boxXBase);
              offA.dy = clamp(offA.dy, minY - boxYBase, maxY - boxYBase);

              const boxX = boxXBase + offA.dx;
              const boxY = boxYBase + offA.dy;
              const ay = boxY + 10;

              const appIsolated = isIsolatedApp(a.id);
              const appHealth = getAppHealth(a.id);
              const hc = colorsForHealth(appHealth, appIsolated);

              const g = svgEl("g", {
                "data-appid": a.id,
                "data-dragkey": appKey,
                style: "cursor:move",
              });

              const box = svgEl("rect", {
                x: boxX,
                y: boxY,
                width: boxW,
                height: boxH,
                rx: "8",
                ry: "8",
                fill: hc.fill,
                stroke: hc.stroke,
                "pointer-events": "all",
              });
              g.appendChild(box);
              remember(a.id, box);

              const inX = boxX + 6;
              const outX = boxX + boxW - 6;
              const cy = ay;

              const inDot = svgEl("circle", {
                cx: inX,
                cy,
                r: "3.2",
                fill: appIsolated
                  ? "rgba(0,0,0,0.35)"
                  : "rgba(122,162,255,0.55)",
                stroke: "rgba(0,0,0,0.18)",
                "stroke-width": "0.6",
                "pointer-events": "all",
              });
              const outDot = svgEl("circle", {
                cx: outX,
                cy,
                r: "3.2",
                fill: appIsolated
                  ? "rgba(0,0,0,0.35)"
                  : "rgba(85,230,165,0.55)",
                stroke: "rgba(0,0,0,0.18)",
                "stroke-width": "0.6",
                "pointer-events": "all",
              });
              g.appendChild(inDot);
              g.appendChild(outDot);
              remember(a.id, inDot);
              remember(a.id, outDot);

              const label = svgEl("text", {
                x: boxX + 14,
                y: ay + 4,
                fill: appIsolated ? "rgba(0,0,0,0.82)" : "var(--text)",
                "font-family": "var(--mono)",
                "font-size": "12",
                "pointer-events": "all",
              });
              label.textContent = `${a.name}:${a.port}`;
              g.appendChild(label);
              remember(a.id, label);

              // anchors
              appPosMap.set(a.id, {
                mid: { x: boxX + boxW / 2, y: ay },
                in: { x: inX, y: cy },
                out: { x: outX, y: cy },
              });

              // exporta anchors
              state.ui = state.ui || {};
              state.ui.graphAnchors = state.ui.graphAnchors || {};
              state.ui.graphAnchors[a.id] = {
                x: appPosMap.get(a.id)?.mid?.x ?? boxX + boxW / 2,
                y: appPosMap.get(a.id)?.mid?.y ?? ay,
                cmdbId: a.cmdbId,
                cmdbName: nodeById(a.cmdbId)?.name || "",
                dc:
                  nodeById(a.cmdbId)?.datacenter ||
                  nodeById(a.cmdbId)?.dc ||
                  "",
                env:
                  nodeById(a.cmdbId)?.ambiente || nodeById(a.cmdbId)?.env || "",
                ns:
                  nodeById(a.cmdbId)?.namespace || nodeById(a.cmdbId)?.ns || "",
              };

              appLayer.appendChild(g);
              actualAppBox.set(a.id, { x: boxX, y: boxY, w: boxW, h: boxH });
            });
          }

          // =========================================================
          // Edges
          // =========================================================
          const edgeEls = [];

          function setEdgeVisible(edge, on) {
            edge.el.style.opacity = on ? "1" : "0";
            if (edge.labelEl) edge.labelEl.style.opacity = on ? "1" : "0";
          }
          function setEdgeEmphasis(edge, strong) {
            const baseW = Number(edge.el.getAttribute("data-basew") || "2.0");
            edge.el.setAttribute(
              "stroke-width",
              String(strong ? baseW + 1.2 : baseW)
            );
            edge.el.style.filter = strong
              ? "drop-shadow(0 0 1px rgba(255,255,255,0.35))"
              : "none";
          }

          for (const c of conns) {
            if (!allowConnByMode(c)) continue;

            const fa = nodeById(c.fromAppId);
            const ta = nodeById(c.toAppId);
            if (!fa || !ta) continue;

            const fp = cmdbPosForEdges.get(fa.cmdbId);
            const tp = cmdbPosForEdges.get(ta.cmdbId);
            if (!fp || !tp) continue;

            const fpt = fp.appPos.get(fa.id) || fp.appPos.get("__none__");
            const tpt = tp.appPos.get(ta.id) || tp.appPos.get("__none__");
            if (!fpt || !tpt) continue;

            const x1 = fpt.out?.x ?? fpt.mid.x,
              y1 = fpt.out?.y ?? fpt.mid.y;
            const x2 = tpt.in?.x ?? tpt.mid.x,
              y2 = tpt.in?.y ?? tpt.mid.y;

            const distX = Math.abs(x2 - x1);
            const dist = Math.hypot(distX, Math.abs(y2 - y1));

            const dx =
              dist < 140
                ? Math.max(10, distX * 0.08)
                : dist < 320
                ? Math.max(22, distX * 0.18)
                : Math.max(70, distX * 0.38);

            const { color, w, dash } = strokeForConn(c);

            const path = svgEl("path", {
              d: `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${
                x2 - dx
              } ${y2}, ${x2} ${y2}`,
              fill: "none",
              stroke: color,
              "stroke-width": String(w),
              "stroke-linecap": "round",
              "data-from": fa.id,
              "data-to": ta.id,
              "data-basew": String(w),
              "pointer-events": "none",
            });
            if (dash) path.setAttribute("stroke-dasharray", dash);

            if (mode === "hover") path.style.opacity = "0";
            else path.style.opacity = "1";

            edgeLayer.appendChild(path);

            const mx = (x1 + x2) / 2,
              my = (y1 + y2) / 2;
            const label = svgEl("text", {
              x: mx + 6,
              y: my - 6,
              fill: "var(--muted)",
              "font-family": "var(--mono)",
              "font-size": "11.5",
              "pointer-events": "none",
            });
            label.textContent = `${c.port} • ${c.connStatus}`;
            if (mode === "hover") label.style.opacity = "0";
            else label.style.opacity = "1";
            labelLayer.appendChild(label);

            edgeEls.push({
              el: path,
              labelEl: label,
              fromAppId: fa.id,
              toAppId: ta.id,
            });
          }

          // hover: edges só quando passar na app
          if (mode === "hover") {
            function showForApp(appId) {
              for (const e of edgeEls) {
                const rel = e.fromAppId === appId || e.toAppId === appId;
                setEdgeVisible(e, rel);
                setEdgeEmphasis(e, rel);
              }
            }
            function clearAll() {
              for (const e of edgeEls) {
                setEdgeVisible(e, false);
                setEdgeEmphasis(e, false);
              }
            }

            let hoverTimer = null;
            function enter(appId) {
              if (hoverTimer) {
                clearTimeout(hoverTimer);
                hoverTimer = null;
              }
              showForApp(appId);
            }
            function leave() {
              if (hoverTimer) clearTimeout(hoverTimer);
              hoverTimer = setTimeout(() => clearAll(), 60);
            }

            for (const [appId, els] of appElsById.entries()) {
              for (const el of els) {
                el.addEventListener("mouseenter", () => enter(appId));
                el.addEventListener("mouseleave", leave);
              }
            }
            clearAll();
          }
        }

        function attachSvgZoomPan(svg) {
          if (svg.__zoomPanAttached) return;
          svg.__zoomPanAttached = true;

          // garante viewBox inicial
          const initFromSize = () => {
            const w = Number(
              svg.getAttribute("width") || svg.clientWidth || 1200
            );
            const h = Number(
              svg.getAttribute("height") || svg.clientHeight || 800
            );
            if (!svg.getAttribute("viewBox")) {
              svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
            }
          };
          initFromSize();

          const getVB = () => {
            const [x, y, w, h] = (svg.getAttribute("viewBox") || "0 0 1200 800")
              .split(/\s+/)
              .map(Number);
            return { x, y, w, h };
          };
          const setVB = (vb) => {
            svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
          };

          const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

          // limites de zoom (ajuste)
          const MIN_W = 300; // máximo zoom-in (menor viewBox)
          const MAX_W = 20000; // máximo zoom-out (maior viewBox)

          // converte mouse -> coords do SVG (no espaço do viewBox)
          function svgPointFromEvent(evt) {
            const rect = svg.getBoundingClientRect();
            const vb = getVB();
            const mx = (evt.clientX - rect.left) / rect.width; // 0..1
            const my = (evt.clientY - rect.top) / rect.height; // 0..1
            return {
              x: vb.x + mx * vb.w,
              y: vb.y + my * vb.h,
            };
          }

          function zoomAt(factor, evt) {
            // factor <1 zoom in, >1 zoom out
            const vb = getVB();
            const p = evt
              ? svgPointFromEvent(evt)
              : { x: vb.x + vb.w / 2, y: vb.y + vb.h / 2 };

            let newW = vb.w * factor;
            newW = clamp(newW, MIN_W, MAX_W);
            const scale = newW / vb.w;
            const newH = vb.h * scale;

            // mantém o ponto p “parado” na tela
            const nx = p.x - (p.x - vb.x) * scale;
            const ny = p.y - (p.y - vb.y) * scale;

            setVB({ x: nx, y: ny, w: newW, h: newH });
          }

          // wheel: zoom (Ctrl opcional; se quiser sempre zoom, remova o if)
          svg.addEventListener(
            "wheel",
            (e) => {
              // Se quiser zoom só com Ctrl (estilo navegador), deixe assim:
              // if(!e.ctrlKey) return;
              e.preventDefault();

              const delta = e.deltaY;
              const factor = delta > 0 ? 1.12 : 0.89;
              zoomAt(factor, e);
            },
            { passive: false }
          );

          // pan: arrastar com botão do meio ou com espaço+mouse (configurável)
          let panning = false;
          let start = null;

          function startPan(e) {
            // escolha a regra:
            // - botão do meio (1)
            // - ou botão esquerdo + tecla Space
            const ok = e.button === 1 || (e.button === 0 && e.code === "Space");
            if (!ok) return;

            panning = true;
            svg.style.cursor = "grabbing";
            start = { ...svgPointFromEvent(e), vb: getVB() };
            e.preventDefault();
          }

          function movePan(e) {
            if (!panning || !start) return;
            const p = svgPointFromEvent(e);
            const dx = p.x - start.x;
            const dy = p.y - start.y;
            setVB({
              x: start.vb.x - dx,
              y: start.vb.y - dy,
              w: start.vb.w,
              h: start.vb.h,
            });
          }

          function endPan() {
            if (!panning) return;
            panning = false;
            start = null;
            svg.style.cursor = "";
          }

          svg.addEventListener("mousedown", startPan);
          window.addEventListener("mousemove", movePan);
          window.addEventListener("mouseup", endPan);

          // atalhos: + / - / 0 (reset)
          window.addEventListener("keydown", (e) => {
            if (
              e.target &&
              (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")
            )
              return;

            if (e.key === "+" || (e.key === "=" && e.ctrlKey)) {
              zoomAt(0.89, null);
            } else if (e.key === "-" || (e.key === "-" && e.ctrlKey)) {
              zoomAt(1.12, null);
            } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
              // reset: volta ao tamanho atual do svg (width/height)
              const w = Number(
                svg.getAttribute("width") || svg.clientWidth || 1200
              );
              const h = Number(
                svg.getAttribute("height") || svg.clientHeight || 800
              );
              setVB({ x: 0, y: 0, w, h });
            }
          });
        }

        // ---------------- Modal (multi-type) ----------------
        function fillAppDropdowns(selectedId) {
          const apps = allApps()
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name));
          const opt = (a) =>
            `<option value="${a.id}">${escapeHtml(a.name)} (port ${escapeHtml(
              String(a.port || "-")
            )}) • cmdb:${escapeHtml(nodeById(a.cmdbId)?.name || "-")}</option>`;
          mFrom.innerHTML = apps.map(opt).join("");
          mTo.innerHTML = apps.map(opt).join("");
          if (selectedId && apps.some((a) => a.id === selectedId)) return;
        }

        function openModal(id) {
          const n = nodeById(id);
          if (!n) return;
          editingId = id;

          // reset sections
          taskFields.style.display = "none";
          urlFields.style.display = "none";
          cmdbFields.style.display = "none";
          appFields.style.display = "none";
          connFields.style.display = "none";

          mName.value = n.name || "";
          mFolder.value = fullPathOf(n.parentId || "root");
          mPath.textContent = fullPathOf(id);

          if (isTask(n)) {
            mTitle.textContent = "Editar atividade (task)";
            taskFields.style.display = "";
            mResp.value = n.resp || "";
            mDue.value = n.due || "";
            mType.value = n.taskType || "";
            mStatus.value = n.status || "todo";
            mPrio.value = String(n.prio || 3);
            mNotes.value = n.notes || "";
            mUpdated.value = (n.updatedAt || "").replace("T", " ").slice(0, 19);
          } else if (isUrl(n)) {
            mTitle.textContent = "Editar favorito (url)";
            urlFields.style.display = "";
            mUrl.value = n.url || "";
          } else if (isCMDBDir(n)) {
            mTitle.textContent = "Editar pasta CMDB";
            cmdbFields.style.display = "";
            mHost.value = n.hostname || "";
            mIp.value = n.ip || "";
            mDc.value = n.datacenter || "";
            mEnv.value = n.ambiente || "";
            mNs.value = n.namespace || "";
          } else if (isApp(n)) {
            mTitle.textContent = "Editar application";
            appFields.style.display = "";
            mAppPort.value = String(n.port || "");
            mAppCmdb.value = nodeById(n.cmdbId)?.name || "-";
          } else if (isConn(n)) {
            mTitle.textContent = "Editar conectividade";
            connFields.style.display = "";
            fillAppDropdowns();
            mFrom.value = n.fromAppId || "";
            mTo.value = n.toAppId || "";
            mConnPort.value = String(n.port || "");
            mConnStatus.value = n.connStatus || "nao-testada";
            mConnUpdated.value = (n.updatedAt || "")
              .replace("T", " ")
              .slice(0, 19);
          } else {
            mTitle.textContent = "Editar";
          }

          modalOverlay.style.display = "flex";
        }

        function closeModal() {
          modalOverlay.style.display = "none";
          editingId = null;
        }
        modalOverlay.addEventListener("click", (e) => {
          if (e.target === modalOverlay) closeModal();
        });
        mClose.addEventListener("click", closeModal);

        mSave.addEventListener("click", () => {
          const n = nodeById(editingId);
          if (!n) return;

          const newName = (mName.value || "").trim();
          if (!newName) {
            alert("Nome inválido.");
            return;
          }

          const folderPath = (mFolder.value || "").trim() || "/";
          const folderId = resolvePath(folderPath);
          if (!folderId) {
            alert("Pasta inválida.");
            return;
          }
          const folderNode = nodeById(folderId);
          if (!(isDir(folderNode) || isCMDBDir(folderNode))) {
            alert("Destino não é pasta.");
            return;
          }

          // CMDB dir pode ir para dentro de dir/cmdb
          if (
            childrenOf(folderId).some(
              (x) => x.name === newName && x.id !== n.id
            )
          ) {
            alert("Já existe item com esse nome na pasta destino.");
            return;
          }

          const oldParent = n.parentId;

          // update common
          n.name = newName;
          n.parentId = folderId;
          n.updatedAt = nowISO();

          if (isTask(n)) {
            n.resp = (mResp.value || "").trim();
            n.due = (mDue.value || "").trim();
            n.taskType = (mType.value || "").trim();
            n.status = mStatus.value;
            n.prio = Number(mPrio.value || 3);
            n.notes = mNotes.value || "";
          } else if (isUrl(n)) {
            const u = (mUrl.value || "").trim();
            if (u && !/^https?:\/\//i.test(u)) {
              alert("URL inválida (use http/https).");
              return;
            }
            n.url = u;
          } else if (isCMDBDir(n)) {
            n.hostname = (mHost.value || "").trim();
            n.ip = (mIp.value || "").trim();
            n.datacenter = (mDc.value || "").trim();
            n.ambiente = (mEnv.value || "").trim();
            n.namespace = (mNs.value || "").trim();
          } else if (isApp(n)) {
            const port = Number(mAppPort.value || "");
            if (!(port >= 1 && port <= 65535)) {
              alert("Porta inválida (1..65535)");
              return;
            }
            n.port = port;
            // cmdbId ajusta conforme novo local
            const newCmdb = nearestCMDBDirId(folderId);
            if (newCmdb) n.cmdbId = newCmdb;
          } else if (isConn(n)) {
            const fromId = mFrom.value;
            const toId = mTo.value;
            const port = Number(mConnPort.value || "");
            if (!(port >= 1 && port <= 65535)) {
              alert("Porta inválida (1..65535)");
              return;
            }
            const st = mConnStatus.value;
            if (
              st !== "nao-testada" &&
              st !== "testada" &&
              st !== "bloqueada"
            ) {
              alert("Status inválido");
              return;
            }

            const fromApp = nodeById(fromId);
            const toApp = nodeById(toId);
            if (!fromApp || !isApp(fromApp)) {
              alert("Origem inválida");
              return;
            }
            if (!toApp || !isApp(toApp)) {
              alert("Destino inválido");
              return;
            }

            n.fromAppId = fromId;
            n.toAppId = toId;
            n.port = port;
            n.connStatus = st;
            n.name = `${fromApp.name} -> ${toApp.name}:${port}`;
            // cmdbId ajusta pelo local
            const newCmdb = nearestCMDBDirId(folderId);
            if (newCmdb) n.cmdbId = newCmdb;
          }

          touch(oldParent);
          touch(folderId);
          saveState();

          closeModal();
          printLine("Salvo.", "ok");
          updateCwd();
          renderSidebar();
        });

        mDelete.addEventListener("click", () => {
          const n = nodeById(editingId);
          if (!n) return;
          if (!confirm("Excluir este item?")) return;
          const r = removeNode(n.id);
          if (!r.ok) {
            alert(r.err);
            return;
          }
          closeModal();
          printLine("Excluído.", "ok");
          updateCwd();
          renderSidebar();
        });

        // ---------------- Config drawer ----------------
        $("btnConfig").addEventListener(
          "click",
          () => (drawerOverlay.style.display = "flex")
        );
        $("btnCloseConfig").addEventListener(
          "click",
          () => (drawerOverlay.style.display = "none")
        );

        function bindSaveGraphButton(){
          const btn = document.getElementById("btnSaveGraph");
          if(!btn) return false;
        
          // evita duplicar listener se você chamar de novo
          if(btn.__boundSaveGraph) return true;
          btn.__boundSaveGraph = true;
        
          btn.addEventListener("click", () => {
            try{
              state.ui = state.ui || {};
              state.ui.graphOffsets = state.ui.graphOffsets || {};
              state.ui.graphSizes   = state.ui.graphSizes   || {};
        
              localStorage.setItem("cmdbGraphLayout_offsets", JSON.stringify(state.ui.graphOffsets));
              localStorage.setItem("cmdbGraphLayout_sizes",   JSON.stringify(state.ui.graphSizes));
        
              if(typeof printLine === "function") printLine("Layout do CMDB Graph salvo com sucesso.", "ok");
              else alert("Layout do CMDB Graph salvo com sucesso.");
            }catch(e){
              console.error(e);
              if(typeof printLine === "function") printLine("Falha ao salvar layout do CMDB Graph.", "err");
              else alert("Falha ao salvar layout do CMDB Graph.");
            }
          });
        
          return true;
        }
        
        // tenta bind no load
        document.addEventListener("DOMContentLoaded", () => {
          bindSaveGraphButton();
        });
        
        // se seu modal/actions são montados depois, chame isso ao abrir o modal também:
        // bindSaveGraphButton();

        drawerOverlay.addEventListener("click", (e) => {
          if (e.target === drawerOverlay) drawerOverlay.style.display = "none";
        });

        defPriority.value = String(settings.defPriority || 3);
        defStatus.value = settings.defStatus || "todo";

        defPriority.addEventListener("change", () => {
          settings.defPriority = Number(defPriority.value || 3);
          saveSettings();
        });
        defStatus.addEventListener("change", () => {
          settings.defStatus = defStatus.value;
          saveSettings();
        });

        function ensureFontLevels() {
          if (!settings.sidebarFontLevels) settings.sidebarFontLevels = {};
          for (let lvl = 1; lvl <= 5; lvl++) {
            if (!settings.sidebarFontLevels[lvl]) {
              settings.sidebarFontLevels[lvl] = {
                size: 12,
                bold: false,
                italic: false,
                color: "",
              };
            }
            const c = settings.sidebarFontLevels[lvl];
            if (typeof c.size !== "number") c.size = 12;
            if (typeof c.bold !== "boolean") c.bold = false;
            if (typeof c.italic !== "boolean") c.italic = false;
            if (typeof c.color !== "string") c.color = "";
          }
        }

        function renderFontLevelsUI() {
          ensureFontLevels();
          const box = document.getElementById("fontLevelsBox");
          if (!box) return;

          box.innerHTML = "";

          for (let lvl = 1; lvl <= 5; lvl++) {
            const cfg = settings.sidebarFontLevels[lvl];

            const row = document.createElement("div");
            row.style.display = "grid";
            row.style.gridTemplateColumns = "70px 90px 80px 80px 1fr";
            row.style.gap = "8px";
            row.style.alignItems = "center";
            row.style.margin = "8px 0";

            const lab = document.createElement("div");
            lab.textContent = "Nível " + lvl;

            const size = document.createElement("input");
            size.type = "number";
            size.min = "8";
            size.max = "28";
            size.value = String(cfg.size);

            const bold = document.createElement("label");
            bold.style.display = "flex";
            bold.style.gap = "6px";
            bold.style.alignItems = "center";
            const boldCk = document.createElement("input");
            boldCk.type = "checkbox";
            boldCk.checked = !!cfg.bold;
            bold.appendChild(boldCk);
            bold.appendChild(document.createTextNode("Negrito"));

            const ital = document.createElement("label");
            ital.style.display = "flex";
            ital.style.gap = "6px";
            ital.style.alignItems = "center";
            const italCk = document.createElement("input");
            italCk.type = "checkbox";
            italCk.checked = !!cfg.italic;
            ital.appendChild(italCk);
            ital.appendChild(document.createTextNode("Itálico"));

            const color = document.createElement("input");
            color.type = "color";
            // se vazio, coloca uma cor “dummy” só pra UI funcionar
            color.value =
              cfg.color && cfg.color.startsWith("#") ? cfg.color : "#7aa2ff";

            const apply = () => {
              cfg.size = Number(size.value || 12);
              cfg.bold = !!boldCk.checked;
              cfg.italic = !!italCk.checked;
              // se usuário escolheu uma cor, grava; se quiser “limpar”, vamos tratar com duplo-clique (abaixo)
              cfg.color = color.value;

              saveSettings();
              renderSidebar();
            };

            size.addEventListener("change", apply);
            boldCk.addEventListener("change", apply);
            italCk.addEventListener("change", apply);
            color.addEventListener("change", apply);

            // “Limpar cor” (voltar pro padrão): duplo clique no seletor de cor
            color.addEventListener("dblclick", () => {
              cfg.color = "";
              saveSettings();
              renderSidebar();
              renderFontLevelsUI();
            });

            row.appendChild(lab);
            row.appendChild(size);
            row.appendChild(bold);
            row.appendChild(ital);
            row.appendChild(color);

            box.appendChild(row);
          }

          const tip = document.createElement("div");
          tip.style.opacity = "0.8";
          tip.style.fontSize = "12px";
          tip.style.marginTop = "6px";
          tip.textContent =
            "Dica: dê duplo clique na cor para voltar ao padrão do tema.";
          box.appendChild(tip);
        }

        // chame isso junto do renderAliasesUI()
        renderFontLevelsUI();

        function renderAliasesUI() {
          aliasesBox.innerHTML = "";
          const entries = Object.entries(settings.aliases).sort((a, b) =>
            a[0].localeCompare(b[0])
          );
          for (const [k, v] of entries) {
            const row = document.createElement("div");
            row.className = "aliasItem";

            const inK = document.createElement("input");
            inK.value = k;

            const inV = document.createElement("input");
            inV.value = v;

            const btn = document.createElement("button");
            btn.textContent = "Salvar";
            btn.onclick = () => {
              const nk = (inK.value || "").trim();
              const nv = (inV.value || "").trim();
              if (!nk || !nv) return;
              if (nk !== k) delete settings.aliases[k];
              settings.aliases[nk] = nv;
              saveSettings();
              renderAliasesUI();
              printLine(`Alias salvo: ${nk} → ${nv}`, "ok");
            };

            row.appendChild(inK);
            row.appendChild(inV);
            row.appendChild(btn);
            aliasesBox.appendChild(row);
          }
        }
        renderAliasesUI();

        $("btnAddAlias").addEventListener("click", () => {
          const k = prompt("Nome do alias:");
          if (!k) return;
          const v = prompt("Comando alvo:");
          if (!v) return;
          settings.aliases[k.trim()] = v.trim();
          saveSettings();
          renderAliasesUI();
          printLine(`Alias criado: ${k.trim()} → ${v.trim()}`, "ok");
        });

        // ---------------- Sidebar ----------------
        function isExpanded(id) {
          return !!settings.sidebarExpanded[id];
        }
        function toggleExpanded(id) {
          settings.sidebarExpanded[id] = !isExpanded(id);
          saveSettings();
          renderSidebar();
        }

        const hoverExpandTimers = new Map();
        function scheduleExpand(dirId) {
          if (isExpanded(dirId)) return;
          if (hoverExpandTimers.has(dirId)) return;
          const t = setTimeout(() => {
            settings.sidebarExpanded[dirId] = true;
            saveSettings();
            renderSidebar();
            hoverExpandTimers.delete(dirId);
          }, 550);
          hoverExpandTimers.set(dirId, t);
        }
        function cancelExpand(dirId) {
          const t = hoverExpandTimers.get(dirId);
          if (t) {
            clearTimeout(t);
            hoverExpandTimers.delete(dirId);
          }
        }

        function collapseAll() {
          settings.sidebarExpanded = { root: false };
          saveSettings();
          renderSidebar();
        }
        function expandAll() {
          const map = {};
          state.nodes
            .filter((n) => isDir(n) || isCMDBDir(n))
            .forEach((d) => (map[d.id] = true));
          settings.sidebarExpanded = map;
          saveSettings();
          renderSidebar();
        }
        btnCollapseAll.addEventListener("click", collapseAll);
        btnExpandAll.addEventListener("click", expandAll);

        function renderSidebar() {
          sidebarTree.innerHTML = "";
          const root = nodeById("root");
          if (!root) return;

          function sortKids(kids) {
            return kids.slice().sort((a, b) => {
              const aDir = isDir(a) || isCMDBDir(a);
              const bDir = isDir(b) || isCMDBDir(b);
              if (aDir !== bDir) return aDir ? -1 : 1;
              return a.name.localeCompare(b.name);
            });
          }

          function addRow(node, depth) {
            const row = document.createElement("div");
            row.className = "node" + (depth > 0 ? " indent" : "");
            row.style.marginLeft = depth * 10 + "px";
            row.dataset.nodeId = node.id;

            row.dataset.depth = String(depth);

            row.draggable = node.id !== "root";
            row.addEventListener("dragstart", (e) => {
              row.classList.add("dragging");
              e.dataTransfer.effectAllowed = "move";
              e.dataTransfer.setData("text/plain", node.id);
            });
            row.addEventListener("dragend", () => {
              row.classList.remove("dragging");
              sidebarTree
                .querySelectorAll(".dropTarget")
                .forEach((x) => x.classList.remove("dropTarget"));
            });

            if (isDir(node) || isCMDBDir(node)) {
              row.addEventListener("dragover", (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = "move";
                row.classList.add("dropTarget");
                scheduleExpand(node.id);
              });

              row.addEventListener("dragleave", (e) => {
                if (!row.contains(e.relatedTarget)) {
                  row.classList.remove("dropTarget");
                  cancelExpand(node.id);
                }
              });

              row.addEventListener("drop", (e) => {
                e.preventDefault();
                e.stopPropagation();
                row.classList.remove("dropTarget");
                cancelExpand(node.id);

                const srcId = e.dataTransfer.getData("text/plain");
                if (!srcId) return;

                const r = moveNodeToDir(srcId, node.id);
                if (!r.ok) {
                  printLine("drag/drop: " + r.err, "err");
                  return;
                }
                printLine(`Movido para: ${fullPathOf(node.id)}`, "ok");
                renderSidebar();
              });
            }

            const caret = document.createElement("span");
            if (isDir(node) || isCMDBDir(node)) {
              caret.textContent = isExpanded(node.id) ? "▼" : "▶";
              caret.style.width = "18px";
              caret.style.userSelect = "none";
              caret.onclick = (e) => {
                e.stopPropagation();
                toggleExpanded(node.id);
              };
            } else {
              caret.textContent = " ";
              caret.style.width = "18px";
            }

            const icon = document.createElement("span");
            if (isCMDBDir(node)) icon.textContent = "🗄️";
            else if (isDir(node)) icon.textContent = "📁";
            else if (isUrl(node)) icon.textContent = "🔗";
            else if (isApp(node)) icon.textContent = "🧩";
            else if (isConn(node)) icon.textContent = "🔌";
            else if (node.type === "flow") icon.textContent = "🧭";
            else if (isConnRef(node)) icon.textContent = "🔗";
            else icon.textContent = "📄";

            const name = document.createElement("span");
            name.className = "name";
            name.textContent =
              isDir(node) || isCMDBDir(node) ? node.name + "/" : node.name;

            // ---- Fonte por nível (somente pastas) ----
            if (isDir(node) || isCMDBDir(node)) {
              const lvl = Math.max(1, Math.min(5, depth)); // depth 1..5
              const cfg =
                settings.sidebarFontLevels && settings.sidebarFontLevels[lvl];
              if (cfg) {
                name.style.fontSize = (cfg.size || 12) + "px";
                name.style.fontWeight = cfg.bold ? "700" : "400";
                name.style.fontStyle = cfg.italic ? "italic" : "normal";
                name.style.color =
                  cfg.color && cfg.color.trim() ? cfg.color : "";
              }
            }

            if (isTask(node)) {
              name.classList.add(taskColorClass(node));
            }
            if (isConn(node)) {
              name.classList.add(connColorClass(node));
            }

            if (isConnRef(node)) {
              const target = nodeById(node.refConnId);
              if (target && isConn(target))
                name.classList.add(connColorClass(target));
              else name.classList.add("c-red");
            }

            row.appendChild(caret);
            row.appendChild(icon);
            row.appendChild(name);

            if (isDir(node) || isCMDBDir(node)) {
              row.onclick = () => {
                state.cwdId = node.id;
                saveState();
                updateCwd();
                renderSidebar();
                printLine(`${cwdPath()} $ cd ${fullPathOf(node.id)}`, "cmd");
                printLine(`Agora em: ${cwdPath()}`, "muted");
                runCommand("pwd"); // ← ajuste para o nome real da sua função
                runCommand("tree"); // ← ajuste para o nome real da sua função
              };
              row.ondblclick = (e) => {
                e.stopPropagation();
                toggleExpanded(node.id);
              };
            } else if (isUrl(node)) {
              row.ondblclick = () => {
                if (node.url)
                  window.open(node.url, "_blank", "noopener,noreferrer");
              };
            } else if (isConnRef(node)) {
              row.ondblclick = () => {
                const target = nodeById(node.refConnId);
                if (target && isConn(target)) {
                  openModal(target.id);
                  return;
                }
                // ✅ ref quebrada: dblclick apaga a connref
                const r = removeNode(node.id);
                if (!r.ok) printLine("ref: " + r.err, "err");
                else printLine("Ref quebrada removida.", "ok");
                updateCwd();
                renderSidebar();
              };
            } else {
              row.ondblclick = () => openModal(node.id);
            }
            sidebarTree.appendChild(row);
          }

          function walk(dirId, depth) {
            const kids = sortKids(childrenOf(dirId));
            for (const k of kids) {
              addRow(k, depth);
              if ((isDir(k) || isCMDBDir(k)) && isExpanded(k.id)) {
                walk(k.id, depth + 1);
              }
            }
          }

          if (settings.sidebarExpanded["root"] === undefined)
            settings.sidebarExpanded["root"] = true;

          addRow(root, 0);
          if (isExpanded("root")) walk("root", 1);

          sidebarTree.ondragover = (e) => e.preventDefault();
          sidebarTree.ondrop = (e) => {
            if (e.target && e.target.closest && e.target.closest(".node"))
              return;

            const srcId = e.dataTransfer.getData("text/plain");
            if (!srcId) return;

            const r = moveNodeToDir(srcId, "root");
            if (!r.ok) printLine("drag/drop: " + r.err, "err");
            else {
              printLine("Movido para: /", "ok");
              renderSidebar();
            }
          };
        }

        function appScopeHint(app) {
          const cmdb = app?.cmdbId ? nodeById(app.cmdbId) : null;

          const dc = (cmdb?.datacenter || cmdb?.dc || "(sem dc)").trim();
          const env = (cmdb?.ambiente || cmdb?.env || "(sem env)").trim();

          // namespace é atributo da instância (cmdb)
          const ns = (cmdb?.namespace || "(sem ns)").trim();

          // “instância” = o próprio CMDB/host (use o melhor campo que você tiver)
          const inst = (
            cmdb?.name ||
            cmdb?.hostname ||
            cmdb?.id ||
            "(sem instância)"
          )
            .toString()
            .trim();

          return `${dc} › ${env} › ${ns} › ${inst}`;
        }

        // ---------------- Autocomplete ----------------
        function getKnownScoped() {
          const items = itemsInScope(state.cwdId);

          const resps = Array.from(
            new Set(
              items
                .filter((n) => isTask(n) || isUrl(n))
                .map((t) => (t.resp || "").trim())
                .filter(Boolean)
            )
          ).sort((a, b) => a.localeCompare(b));
          const types = Array.from(
            new Set(
              items
                .filter(isTask)
                .map((t) => (t.taskType || "").trim())
                .filter(Boolean)
            )
          ).sort((a, b) => a.localeCompare(b));
          const dues = Array.from(
            new Set(
              items
                .filter((n) => isTask(n) || isUrl(n))
                .map((t) => (t.due || "").trim())
                .filter(Boolean)
            )
          ).sort((a, b) => a.localeCompare(b));

          const apps = allApps()
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name)); // <- mantém objeto

          return {
            resps,
            types,
            dues,
            statuses: ["todo", "doing", "blocked", "sequenciado", "done"],
            prios: ["1", "2", "3", "4", "5"],
            cmdbTags: CMDB_TAGS,
            appTags: APP_TAGS,
            connTags: CONN_TAGS,
            apps,
          };
        }

        function currentToken(text, caret) {
          const left = text.slice(0, caret);
          const m = left.match(/(^|[\s"])([^\s"]*)$/);
          return m ? m[2] : "";
        }

        function detectActiveTag(text, caret) {
          const left = text.slice(0, caret);

          // detect any @tag from known pools
          const ALL = [...TAGS, ...CMDB_TAGS, ...APP_TAGS, ...CONN_TAGS];
          let best = { tag: null, idx: -1 };
          for (const t of ALL) {
            const i = left.lastIndexOf(t);
            if (i > best.idx) best = { tag: t, idx: i };
          }
          if (best.idx < 0) return null;
          const after = left.slice(best.idx + best.tag.length);
          if (after.length && !/^\s/.test(after)) return null;
          return best.tag;
        }

        function showAC(items) {
          ac.innerHTML = "";
          if (!items.length) {
            ac.style.display = "none";
            return;
          }
          for (const it of items.slice(0, 60)) {
            const div = document.createElement("div");
            div.className = "item";
            div.innerHTML = `<span class="a">${escapeHtml(
              it.label
            )}</span><span class="b">${escapeHtml(it.hint || "")}</span>`;
            div.onclick = () => applyAC(it.insert);
            ac.appendChild(div);
          }
          ac.style.display = "block";
        }
        function hideAC() {
          ac.style.display = "none";
        }

        function applyAC(insert) {
          const text = cli.value;
          const caret = cli.selectionStart || 0;

          const left = text.slice(0, caret);
          const right = text.slice(caret);
          const m = left.match(/(^|[\s"])([^\s"]*)$/);
          const tokenStart = m ? left.length - m[2].length : caret;

          const before = text.slice(0, tokenStart);
          const after = right;
          const space = after.startsWith(" ") || after === "" ? "" : " ";
          cli.value = before + insert + space + after;

          const newCaret = (before + insert + space).length;
          cli.setSelectionRange(newCaret, newCaret);
          hideAC();
          cli.focus();
        }

        function refreshAC() {
          const text = cli.value;
          const caret = cli.selectionStart || 0;
          const tok = currentToken(text, caret);
          const activeTag = detectActiveTag(text, caret);
          const known = getKnownScoped();

          // autocomplete especial para flow
          // autocomplete especial para flow (INSERE ID)
          // autocomplete especial para flow
          if (text.startsWith("flow")) {
            const q = tok
              .replace(/^flow\s*/, "")
              .replace(/^>/, "")
              .toLowerCase();

            const apps = state.nodes.filter(isApp);

            const items = apps
              .filter((a) => a.name.toLowerCase().includes(q))
              .map((a) => ({
                label: a.name, // 👈 continua limpo na lista
                insert: `${a.name}#${a.id}`, // 👈 INSERE nome#id no CLI
                hint: "app cmdb",
              }));

            showAC(items);
            return;
          }

          if (tok.startsWith("@")) {
            const q = tok.toLowerCase();
            const ALL = [...TAGS, ...CMDB_TAGS, ...APP_TAGS, ...CONN_TAGS];
            const items = ALL.filter((t) => t.toLowerCase().startsWith(q)).map(
              (t) => ({ label: t, insert: t, hint: "tag" })
            );
            showAC(items);
            return;
          }

          if (activeTag) {
            const q = (tok || "").toLowerCase();

            if (activeTag === "@resp") {
              const list = known.resps;
              const items = list
                .filter((v) => v.toLowerCase().includes(q))
                .map((v) => ({ label: v, insert: v, hint: "responsável" }));
              showAC(
                items.length
                  ? items
                  : list.map((v) => ({
                      label: v,
                      insert: v,
                      hint: "responsável",
                    }))
              );
              return;
            }
            if (activeTag === "@type") {
              const list = known.types;
              const items = list
                .filter((v) => v.toLowerCase().includes(q))
                .map((v) => ({ label: v, insert: v, hint: "tipo" }));
              showAC(
                items.length
                  ? items
                  : list.map((v) => ({ label: v, insert: v, hint: "tipo" }))
              );
              return;
            }
            if (activeTag === "@due") {
              const list = known.dues;
              const items = list
                .filter((v) => v.toLowerCase().includes(q))
                .map((v) => ({ label: v, insert: v, hint: "due" }));
              if (items.length) {
                showAC(items);
                return;
              }
              showAC([
                { label: todayISODate(), insert: todayISODate(), hint: "hoje" },
              ]);
              return;
            }
            if (activeTag === "@status") {
              const list = known.statuses;
              const items = list
                .filter((v) => v.toLowerCase().includes(q))
                .map((v) => ({ label: v, insert: v, hint: "status" }));
              showAC(items);
              return;
            }
            if (activeTag === "@prio") {
              const list = known.prios;
              const items = list
                .filter((v) => v.includes(q))
                .map((v) => ({ label: v, insert: v, hint: "prioridade" }));
              showAC(items);
              return;
            }

            // CMDB tags values: no auto list (livre)
            if (
              activeTag === "@hostname" ||
              activeTag === "@ip" ||
              activeTag === "@dc" ||
              activeTag === "@env"
            ) {
              hideAC();
              return;
            }

            if (activeTag === "@from" || activeTag === "@to") {
              const list = known.apps; // agora é array de objetos app
              const ql = (q || "").toLowerCase();

              const filtered = list.filter((a) => {
                const name = (a?.name || "").toLowerCase();
                // se quiser também buscar pelo caminho, descomente:
                // const hint = appScopeHint(a).toLowerCase();
                // return name.includes(ql) || hint.includes(ql);
                return name.includes(ql);
              });

              const base = (filtered.length ? filtered : list).slice(0, 120);

              const items = base.map((a) => {
                const name = a?.name || "(sem nome)";
                const port = a?.port ? `:${a.port}` : "";
                return {
                  label: `${name}${port}`,
                  insert: `"${name}#${a.id}"`,
                  hint: appScopeHint(a),
                };
              });

              showAC(items);
              return;
            }
            if (activeTag === "@port") {
              hideAC();
              return;
            }
          }

          if (tok === ">" || tok.endsWith(">")) {
            const apps = allApps()
              .slice()
              .sort((a, b) => a.name.localeCompare(b.name));
            const items = apps.map((a) => ({
              label: a.name,
              insert: ` ${a.name}`,
              hint: `cmdb:${nodeById(a.cmdbId)?.name || "-"}`,
            }));
            showAC(items);
            return;
          }

          hideAC();
        }

        cli.addEventListener("input", refreshAC);
        cli.addEventListener("blur", () => setTimeout(hideAC, 120));
        cli.addEventListener("keydown", (e) => {
          if (e.key === "Tab" && ac.style.display === "block") {
            e.preventDefault();
            const first = ac.querySelector(".item");
            if (first) first.click();
            return;
          }
          if (e.key === "Escape") {
            hideAC();
            return;
          }

          if (e.key === "ArrowUp") {
            if (inputHistory.length) {
              e.preventDefault();
              if (histIdx < 0) histIdx = inputHistory.length;
              histIdx = Math.max(0, histIdx - 1);
              cli.value = inputHistory[histIdx] || "";
              cli.setSelectionRange(cli.value.length, cli.value.length);
              hideAC();
            }
            return;
          }
          if (e.key === "ArrowDown") {
            if (inputHistory.length) {
              e.preventDefault();
              if (histIdx < 0) return;
              histIdx = Math.min(inputHistory.length, histIdx + 1);
              cli.value = inputHistory[histIdx] || "";
              cli.setSelectionRange(cli.value.length, cli.value.length);
              hideAC();
            }
            return;
          }
          if (e.key === "Enter") {
            const cmd = cli.value;
            cli.value = "";
            hideAC();
            inputHistory.push(cmd);
            histIdx = -1;
            runCommand(cmd);
            return;
          }
          setTimeout(refreshAC, 0);
        });

        // ---------------- Top buttons ----------------
        $("btnCopy").addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(lastOutputText.trim());
            printLine("Copiado.", "ok");
          } catch {
            printLine("Falha ao copiar (permissão do navegador).", "err");
          }
        });

        $("btnExport").addEventListener("click", () => {
          const payload = { state, settings };
          const blob = new Blob([JSON.stringify(payload, null, 2)], {
            type: "application/json",
          });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "cli-projects-v9-export.json";
          a.click();
          URL.revokeObjectURL(a.href);
          printLine("Exportado.", "ok");
        });

        $("btnImport").addEventListener("click", () => {
          const inp = document.createElement("input");
          inp.type = "file";
          inp.accept = "application/json";
          inp.onchange = async () => {
            const file = inp.files && inp.files[0];
            if (!file) return;
            const txt = await file.text();
            try {
              const obj = JSON.parse(txt);
              if (obj.state && obj.state.nodes) state = obj.state;
              if (obj.settings) settings = obj.settings;
              settings.aliases = {
                ...defaultSettings().aliases,
                ...(settings.aliases || {}),
              };
              settings.sidebarExpanded = settings.sidebarExpanded || {
                root: true,
              };
              saveState();
              saveSettings();
              setTheme();
              defPriority.value = String(settings.defPriority || 3);
              defStatus.value = settings.defStatus || "todo";
              renderAliasesUI();
              updateCwd();
              renderSidebar();
              printLine("Importado.", "ok");
            } catch {
              printLine("JSON inválido.", "err");
            }
          };
          inp.click();
        });

        $("btnTheme").addEventListener("click", () => {
          settings.theme = settings.theme === "light" ? "dark" : "light";
          saveSettings();
          setTheme();
        });

        $("btnReset").addEventListener("click", () => {
          if (!confirm("Resetar tudo?")) return;
          localStorage.removeItem(LS_KEY);
          localStorage.removeItem(SET_KEY);
          state = defaultState();
          settings = defaultSettings();
          saveState();
          saveSettings();
          setTheme();
          defPriority.value = String(settings.defPriority);
          defStatus.value = settings.defStatus;
          renderAliasesUI();
          term.innerHTML = "";
          boot();
          renderSidebar();
        });

        // ---------------- Command runner ----------------
        function runCommand(raw) {
          const trimmed = (raw || "").trim();
          if (!trimmed) return;

          clearOutBuf();
          echoCmd(trimmed);

          const head = tokenize(trimmed)[0];
          if (settings.aliases[head] && head !== "aliases") {
            const replaced =
              settings.aliases[head] + trimmed.slice(head.length);
            return runCommand(replaced);
          }

          const parts = tokenize(trimmed);
          const cmd = parts[0];
          const args = parts.slice(1);

          switch (cmd) {
            case "help":
              cmd_help();
              break;
            case "ls":
              cmd_ls(args);
              break;
            case "tree":
              cmd_tree(args);
              break;
            case "incident":
              cmd_incident(trimmed);
              break;
            case "mkdir":
              cmd_mkdir(args);
              break;
            case "validate":
              cmd_validate(args);
              break;
            case "cd":
              cmd_cd(args);
              break;
            case "rm":
              cmd_rm(args);
              break;
            case "mv":
              cmd_mv(args);
              break;
            case "flow":
              cmd_flow(raw);
              break;
            case "add":
              cmd_add(trimmed);
              break;
            case "url":
              cmd_url(trimmed);
              break;
            case "mkcmdb":
              cmd_mkcmdb(trimmed);
              break;
            case "app":
              cmd_app(trimmed);
              break;
            case "operacao":
              cmd_operacao(raw);
              break;
            case "conn":
              if (
                args[0] === "pendentes" ||
                args[0] === "testadas" ||
                args[0] === "status"
              ) {
                cmd_conn_query(args);
              } else {
                cmd_conn(trimmed); // continua criando conectividade via @from/@to/@port
              }
              break;
            case "cmdb":
              cmd_cmdb(args);
              break;
            case "q":
              cmd_q(args);
              break;
            case "resumo":
              cmd_resumo();
              break;
            case "@resp":
              cmd_at_resp();
              break;
            case "focus":
              cmd_focus();
              break;
            case "aliases":
              cmd_aliases();
              break;
            case "pwd":
              cmd_pwd();
              break;
            case "clear":
              cmd_clear();
              break;
            default:
              printLine(`Comando não reconhecido: ${cmd} (digite help)`, "err");
          }

          updateCwd();
          renderSidebar();
        }

        function cmd_operacao(raw) {
          const name = raw.replace(/^operacao\s*/, "").trim();
          if (!name) {
            printLine("Use: operacao nome-do-flow", "muted");
            return;
          }

          const flow = state.nodes.find((n) => isFlow(n) && n.name === name);
          if (!flow) {
            printLine(`Flow não encontrado: ${name}`, "err");
            return;
          }

          const apps = flow.apps
            .map((id) => state.nodes.find((n) => isApp(n) && n.id === id))
            .filter(Boolean);

          if (!apps.length) {
            printLine("Flow sem apps válidas.", "err");
            return;
          }

          flow.status = "executada";
          flow.updatedAt = nowISO();

          openFlowModal(apps);
        }

        // ======== CONSULTAS DE CONECTIVIDADE (recursivo no escopo atual) ========
        function connsInScope(scopeDirId) {
          return state.nodes
            .filter(isConn)
            .filter((c) => isDescendantOrSelf(c.parentId, scopeDirId));
        }

        function fmtConnLine(c) {
          const fa = nodeById(c.fromAppId);
          const ta = nodeById(c.toAppId);
          const stCls = connColorClass(c);
          const fromCm = fa ? nodeById(fa.cmdbId) : null;
          const toCm = ta ? nodeById(ta.cmdbId) : null;

          const fromLabel = `${fromCm ? fromCm.name : "-"}:${
            fa ? fa.name : "-"
          }`;
          const toLabel = `${toCm ? toCm.name : "-"}:${ta ? ta.name : "-"}`;

          return (
            `🔌 <span class="${stCls}">${escapeHtml(
              c.connStatus || "nao-testada"
            )}</span> ` +
            `<span class="muted">${escapeHtml(fromLabel)} → ${escapeHtml(
              toLabel
            )}:${escapeHtml(String(c.port || "-"))}</span>` +
            ` <span class="muted">${escapeHtml(
              "(" + fullPathOf(c.id) + ")"
            )}</span>`
          );
        }

        function renderConnAsHTML(c, icon = "🔌") {
          const fa = nodeById(c.fromAppId);
          const ta = nodeById(c.toAppId);
          const stCls = connColorClass(c);

          const fromCm = fa ? nodeById(fa.cmdbId) : null;
          const toCm = ta ? nodeById(ta.cmdbId) : null;

          const fromLabel = `${fromCm ? fromCm.name : "-"}:${
            fa ? fa.name : "-"
          }`;
          const toLabel = `${toCm ? toCm.name : "-"}:${ta ? ta.name : "-"}`;

          // ✅ mesma estética sempre (status + “A → B:porta” + path)
          return (
            `${icon} <span class="${stCls}">${escapeHtml(
              c.connStatus || "nao-testada"
            )}</span> ` +
            `<span class="clickable" data-open="${c.id}">${escapeHtml(
              fromLabel
            )} → ${escapeHtml(toLabel)}:${escapeHtml(
              String(c.port || "-")
            )}</span>` +
            ` <span class="muted">${escapeHtml(
              "(" + fullPathOf(c.id) + ")"
            )}</span>`
          );
        }

        function cmd_conn_query(args) {
          const mode = (args[0] || "").toLowerCase();

          let wanted = null;
          if (mode === "pendentes") wanted = "nao-testada";
          else if (mode === "testadas") wanted = "testada";
          else if (mode === "status") wanted = (args[1] || "").toLowerCase();

          if (!wanted || (wanted !== "nao-testada" && wanted !== "testada")) {
            printLine(
              "conn: uso: conn pendentes | conn testadas | conn status <nao-testada|testada>",
              "muted"
            );
            return;
          }

          const all = connsInScope(state.cwdId);
          const list = all
            .filter((c) => (c.connStatus || "nao-testada") === wanted)
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name));

          const title =
            wanted === "nao-testada"
              ? "Conectividades pendentes (não-testadas)"
              : "Conectividades testadas";

          printLine(`${title} — escopo atual, recursivo:`, "out");
          if (!list.length) {
            printLine("(nenhuma)", "muted");
            return;
          }

          list.forEach((c) => printHTMLLine("  " + fmtConnLine(c), "out"));
          attachDblClickHandlers();
        }

        function norm(s) {
          return (s || "").toString().trim().toLowerCase();
        }

        function includesCI(hay, needle) {
          const h = norm(hay);
          const n = norm(needle);
          if (!n) return false;
          return h.includes(n);
        }

        function cmdbFind(query) {
          const q = (query || "").trim();
          if (!q) {
            printLine("cmdb find: uso: cmdb find <trecho>", "muted");
            return;
          }

          // fontes
          const cmdbs = state.nodes.filter(isCMDBDir);
          const apps = state.nodes.filter(isApp);
          const conns = state.nodes.filter(isConn);

          // match em campos relevantes (inclui namespace)
          const cmdbHits = cmdbs.filter(
            (c) =>
              includesCI(c.name, q) ||
              includesCI(c.hostname, q) ||
              includesCI(c.ip, q) ||
              includesCI(c.datacenter, q) ||
              includesCI(c.ambiente, q) ||
              includesCI(c.namespace, q)
          );

          const appHits = apps.filter((a) => {
            const cm = nodeById(a.cmdbId);
            return (
              includesCI(a.name, q) ||
              includesCI(String(a.port || ""), q) ||
              (cm &&
                (includesCI(cm.name, q) ||
                  includesCI(cm.datacenter, q) ||
                  includesCI(cm.ambiente, q) ||
                  includesCI(cm.namespace, q)))
            );
          });

          const connHits = conns.filter((c) => {
            const fa = nodeById(c.fromAppId);
            const ta = nodeById(c.toAppId);
            const fromCm = fa ? nodeById(fa.cmdbId) : null;
            const toCm = ta ? nodeById(ta.cmdbId) : null;

            return (
              includesCI(c.name, q) ||
              includesCI(c.connStatus, q) ||
              includesCI(String(c.port || ""), q) ||
              (fa && includesCI(fa.name, q)) ||
              (ta && includesCI(ta.name, q)) ||
              (fromCm &&
                (includesCI(fromCm.name, q) ||
                  includesCI(fromCm.datacenter, q) ||
                  includesCI(fromCm.ambiente, q) ||
                  includesCI(fromCm.namespace, q))) ||
              (toCm &&
                (includesCI(toCm.name, q) ||
                  includesCI(toCm.datacenter, q) ||
                  includesCI(toCm.ambiente, q) ||
                  includesCI(toCm.namespace, q)))
            );
          });

          // Agrupar por Datacenter > Ambiente > Namespace > Instância(CMDB)
          const tree = new Map(); // dc -> env -> ns -> cmdbId -> {cmdb, apps[], conns[]}

          function ensure(dc, env, ns, cmdb) {
            const kdc = dc || "(sem dc)";
            const kenv = env || "(sem ambiente)";
            const kns = ns || "(sem namespace)";

            if (!tree.has(kdc)) tree.set(kdc, new Map());
            const envMap = tree.get(kdc);

            if (!envMap.has(kenv)) envMap.set(kenv, new Map());
            const nsMap = envMap.get(kenv);

            if (!nsMap.has(kns)) nsMap.set(kns, new Map());
            const instMap = nsMap.get(kns);

            if (!instMap.has(cmdb.id))
              instMap.set(cmdb.id, { cmdb, apps: [], conns: [] });
            return instMap.get(cmdb.id);
          }

          // CMDB hits diretos
          for (const c of cmdbHits) {
            ensure(c.datacenter, c.ambiente, c.namespace, c);
          }

          // apps hit (garante cmdb pai)
          for (const a of appHits) {
            const cm = nodeById(a.cmdbId);
            if (!cm || !isCMDBDir(cm)) continue;
            const bucket = ensure(cm.datacenter, cm.ambiente, cm.namespace, cm);
            bucket.apps.push(a);
          }

          // conns hit (associa aos cmdbs de origem/destino e ao cmdbId do conn)
          for (const c of connHits) {
            const fa = nodeById(c.fromAppId);
            const ta = nodeById(c.toAppId);
            const fromCm = fa ? nodeById(fa.cmdbId) : null;
            const toCm = ta ? nodeById(ta.cmdbId) : null;
            const ownCm = c.cmdbId ? nodeById(c.cmdbId) : null;

            const targets = [fromCm, toCm, ownCm].filter(
              (x) => x && isCMDBDir(x)
            );
            const seen = new Set();
            for (const cm of targets) {
              if (seen.has(cm.id)) continue;
              seen.add(cm.id);
              const bucket = ensure(
                cm.datacenter,
                cm.ambiente,
                cm.namespace,
                cm
              );
              bucket.conns.push(c);
            }
          }

          // render
          const dcs = Array.from(tree.keys()).sort((a, b) =>
            a.localeCompare(b)
          );
          printLine(`CMDB find: "${q}"`, "out");
          if (!dcs.length) {
            printLine("(nenhum resultado)", "muted");
            return;
          }

          for (const dc of dcs) {
            printLine(`\n== Datacenter: ${dc} ==`, "muted");

            const envMap = tree.get(dc);
            const envs = Array.from(envMap.keys()).sort((a, b) =>
              a.localeCompare(b)
            );

            for (const env of envs) {
              printLine(`-- Ambiente: ${env}`, "muted");

              const nsMap = envMap.get(env);
              const nss = Array.from(nsMap.keys()).sort((a, b) =>
                a.localeCompare(b)
              );

              for (const ns of nss) {
                printLine(`   Namespace: ${ns}`, "muted");

                const instMap = nsMap.get(ns);
                const insts = Array.from(instMap.values()).sort((a, b) =>
                  (a.cmdb.name || "").localeCompare(b.cmdb.name || "")
                );

                for (const inst of insts) {
                  const c = inst.cmdb;

                  // INSTÂNCIA
                  const meta = `host=${c.hostname || "-"} ip=${c.ip || "-"}`;
                  printHTMLLine(
                    `• 🗄️ ${renderClickableName(
                      c
                    )} <span class="muted">${escapeHtml(
                      "{inst} " + meta + " (" + fullPathOf(c.id) + ")"
                    )}</span>`,
                    "out"
                  );

                  // APPS
                  const appsList = inst.apps
                    .slice()
                    .sort((x, y) => (x.name || "").localeCompare(y.name || ""));
                  if (appsList.length) {
                    printLine("   Apps:", "muted");
                    for (const a of appsList) {
                      printHTMLLine(
                        `     - 🧩 ${renderClickableName(
                          a
                        )} <span class="muted">${escapeHtml(
                          "{app} port=" +
                            (a.port || "-") +
                            " (" +
                            fullPathOf(a.id) +
                            ")"
                        )}</span>`,
                        "out"
                      );
                    }
                  }

                  // CONNS
                  const uniqConn = (() => {
                    const m = new Map();
                    for (const x of inst.conns) m.set(x.id, x);
                    return Array.from(m.values());
                  })().sort((x, y) =>
                    (x.name || "").localeCompare(y.name || "")
                  );

                  if (uniqConn.length) {
                    printLine("   Conectividades:", "muted");
                    for (const cn of uniqConn) {
                      printHTMLLine(`     - ${fmtConnLine(cn)}`, "out");
                    }
                  }
                }
              }
            }
          }

          attachDblClickHandlers();
        }

        // ---------------- Boot ----------------
        function boot() {
          updateCwd();
          printLine("Bem-vindo. Digite 'help' para ver comandos.", "muted");
          printLine("Exemplos CMDB:", "muted");
          printLine(
            `  mkcmdb srv01 @hostname srv01.local @ip 10.0.0.10 @dc DC1 @env prod`,
            "muted"
          );
          printLine(`  app "orders-api" @port 8080`, "muted");
          printLine(`  cd ..`, "muted");
          printLine(
            `  mkcmdb srv02 @hostname srv02.local @ip 10.0.0.11 @dc DC1 @env prod`,
            "muted"
          );
          printLine(`  app "db" @port 5432`, "muted");
          printLine(`  cd /infra/srv01`, "muted");
          printLine(
            `  conn @from "orders-api" @to "db" @port 5432 @status nao-testada`,
            "muted"
          );
          printLine(`  cmdb rel`, "muted");
          printLine("", "muted");
          printLine("Exemplos tarefas:", "muted");
          printLine(`  mkdir app`, "muted");
          printLine(
            `  add "Implementar login" @resp Darlan @due ${todayISODate()} @status todo @type feature @prio 1`,
            "muted"
          );
          printLine(
            "  cmdb graph [errors|nao-testada]  (grafo DC/ENV/CMDB; portas IN/OUT; no modo normal, hover na app destaca conexões)",
            "muted"
          );

          function loadGraphLayout(){
            try{
              const off = localStorage.getItem("cmdbGraphLayout_offsets");
              const sz  = localStorage.getItem("cmdbGraphLayout_sizes");
          
              state.ui = state.ui || {};
              state.ui.graphOffsets = off ? JSON.parse(off) : (state.ui.graphOffsets || {});
              state.ui.graphSizes   = sz  ? JSON.parse(sz)  : (state.ui.graphSizes   || {});
            }catch(e){
              console.error("loadGraphLayout:", e);
            }
          }
          
          // chame uma vez no boot:
          loadGraphLayout();
        }

        // init
        setTheme();
        defPriority.value = String(settings.defPriority || 3);
        defStatus.value = settings.defStatus || "todo";
        saveState();
        saveSettings();
        boot();
        renderSidebar();
      })();
    </script>
    <!-- ===== GRAPH MODAL FULLSCREEN ===== -->
    <div
      id="graphOverlay"
      style="
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: rgba(0, 0, 0, 0.88);
        display: none;
        flex-direction: column;
      "
    >
      <!-- HEADER -->
      <div
        style="
          height: 48px;
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 0 16px;
          background: #0f1117;
          color: #fff;
          border-bottom: 1px solid #222;
        "
      >
        <strong>CMDB — Visualização</strong>
        <button
          id="graphClose"
          style="
            background: #222;
            color: #fff;
            border: 0;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
          "
        >
          ✕ Fechar
        </button>
      </div>

      <!-- CANVAS -->
      <div
        id="graphViewport"
        style="
          flex: 1;
          position: relative;
          overflow: hidden;
          background: #0b0f14;
        "
      >
        <svg
          id="graphSvg"
          style="width: 100%; height: 100%; display: block"
        ></svg>
      </div>
    </div>

    <style>
      /* ===== FULLSCREEN GRAPH MODAL ===== */

      .modal.fullscreen {
        width: 100vw;
        height: 100vh;
        max-width: none;
        max-height: none;
        border-radius: 0;
        display: flex;
        flex-direction: column;
      }

      .modal .mh {
        flex: 0 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        background: var(--panel);
        border-bottom: 1px solid var(--line);
      }

      .graphViewport {
        flex: 1;
        overflow: hidden;
        position: relative;
        background: #0f1115;
        cursor: grab;
      }

      .graphViewport:active {
        cursor: grabbing;
      }

      #graphCanvas {
        position: absolute;
        inset: 0;
        transform-origin: 0 0;
      }

      #graphSvg {
        width: 3000px;
        height: 3000px;
      }

      /* Botões */
      .mh .ghost {
        padding: 6px 10px;
        border-radius: 6px;
        background: #222;
        border: 1px solid #333;
        color: #eee;
        cursor: pointer;
      }
      .mh .ghost:hover {
        background: #333;
      }
    </style>

    <script>
      (function () {
        const overlay = document.getElementById("graphOverlay");
        const svg = document.getElementById("graphSvg");
        const viewport = document.getElementById("graphViewport");

        let view = { x: 0, y: 0, w: 2000, h: 1200 };
        let dragging = false;
        let last = { x: 0, y: 0 };

        function applyView() {
          svg.setAttribute(
            "viewBox",
            `${view.x} ${view.y} ${view.w} ${view.h}`
          );
        }

        function zoomAt(px, py, factor) {
          const nx = view.x + (px / viewport.clientWidth) * view.w;
          const ny = view.y + (py / viewport.clientHeight) * view.h;

          view.w *= factor;
          view.h *= factor;

          view.x = nx - (px / viewport.clientWidth) * view.w;
          view.y = ny - (py / viewport.clientHeight) * view.h;

          applyView();
        }

        // Mouse wheel zoom
        viewport.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 1.1 : 0.9;
            zoomAt(e.offsetX, e.offsetY, factor);
          },
          { passive: false }
        );

        // Pan
        viewport.addEventListener("mousedown", (e) => {
          if (e.button !== 0) return;
          dragging = true;
          last = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener("mousemove", (e) => {
          if (!dragging) return;
          const dx = e.clientX - last.x;
          const dy = e.clientY - last.y;
          last = { x: e.clientX, y: e.clientY };
          view.x -= dx * (view.w / viewport.clientWidth);
          view.y -= dy * (view.h / viewport.clientHeight);
          applyView();
        });

        window.addEventListener("mouseup", () => (dragging = false));

        // API pública
        window.openGraph = function () {
          overlay.style.display = "flex";
          setTimeout(() => {
            view = { x: 0, y: 0, w: 2000, h: 1200 };
            applyView();
          }, 50);
        };

        document.getElementById("graphClose").onclick = () => {
          overlay.style.display = "none";
        };
      })();
    </script>

    <script></script>
  </body>
</html>
